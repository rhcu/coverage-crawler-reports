<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - xpcom/ds/nsTArray.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">xpcom/ds</a> - nsTArray.h<span style="font-size: 80%;"> (source / <a href="nsTArray.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">534</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-08-07 16:35:00</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef nsTArray_h__
<span class="lineNum">       8 </span>            : #define nsTArray_h__
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;nsTArrayForwardDeclare.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/Alignment.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/ArrayIterator.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/Assertions.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;mozilla/BinarySearch.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;mozilla/CheckedInt.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;mozilla/fallible.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;mozilla/MathAlgorithms.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;mozilla/Move.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/mozalloc.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;mozilla/ReverseIterator.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/TypeTraits.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mozilla/Span.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;nsCycleCollectionNoteChild.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsAlgorithm.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nscore.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsQuickSort.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;nsDebug.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsISupportsImpl.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nsRegionFwd.h&quot;
<span class="lineNum">      35 </span>            : #include &lt;functional&gt;
<span class="lineNum">      36 </span>            : #include &lt;initializer_list&gt;
<span class="lineNum">      37 </span>            : #include &lt;new&gt;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : namespace JS {
<span class="lineNum">      40 </span>            : template&lt;class T&gt;
<span class="lineNum">      41 </span>            : class Heap;
<span class="lineNum">      42 </span>            : class ObjectPtr;
<span class="lineNum">      43 </span>            : } /* namespace JS */
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : class nsRegion;
<span class="lineNum">      46 </span>            : namespace mozilla {
<span class="lineNum">      47 </span>            : namespace layers {
<span class="lineNum">      48 </span>            : struct TileClient;
<span class="lineNum">      49 </span>            : } // namespace layers
<span class="lineNum">      50 </span>            : } // namespace mozilla
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : namespace mozilla {
<span class="lineNum">      53 </span>            : struct SerializedStructuredCloneBuffer;
<span class="lineNum">      54 </span>            : class SourceBufferTask;
<span class="lineNum">      55 </span>            : } // namespace mozilla
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : namespace mozilla {
<span class="lineNum">      58 </span>            : namespace dom {
<span class="lineNum">      59 </span>            : namespace ipc {
<span class="lineNum">      60 </span>            : class StructuredCloneData;
<span class="lineNum">      61 </span>            : } // namespace ipc
<span class="lineNum">      62 </span>            : } // namespace dom
<span class="lineNum">      63 </span>            : } // namespace mozilla
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : namespace mozilla {
<span class="lineNum">      66 </span>            : namespace dom {
<span class="lineNum">      67 </span>            : class ClonedMessageData;
<span class="lineNum">      68 </span>            : class MessagePortMessage;
<span class="lineNum">      69 </span>            : namespace indexedDB {
<span class="lineNum">      70 </span>            : struct StructuredCloneReadInfo;
<span class="lineNum">      71 </span>            : class SerializedStructuredCloneReadInfo;
<span class="lineNum">      72 </span>            : class ObjectStoreCursorResponse;
<span class="lineNum">      73 </span>            : } // namespace indexedDB
<span class="lineNum">      74 </span>            : } // namespace dom
<span class="lineNum">      75 </span>            : } // namespace mozilla
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : class JSStructuredCloneData;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : //
<span class="lineNum">      80 </span>            : // nsTArray is a resizable array class, like std::vector.
<span class="lineNum">      81 </span>            : //
<span class="lineNum">      82 </span>            : // Unlike std::vector, which follows C++'s construction/destruction rules,
<span class="lineNum">      83 </span>            : // nsTArray assumes that your &quot;T&quot; can be memmoved()'ed safely.
<span class="lineNum">      84 </span>            : //
<span class="lineNum">      85 </span>            : // The public classes defined in this header are
<span class="lineNum">      86 </span>            : //
<span class="lineNum">      87 </span>            : //   nsTArray&lt;T&gt;,
<span class="lineNum">      88 </span>            : //   FallibleTArray&lt;T&gt;,
<span class="lineNum">      89 </span>            : //   AutoTArray&lt;T, N&gt;, and
<span class="lineNum">      90 </span>            : //
<span class="lineNum">      91 </span>            : // nsTArray and AutoTArray are infallible by default. To opt-in to fallible
<span class="lineNum">      92 </span>            : // behaviour, use the `mozilla::fallible` parameter and check the return value.
<span class="lineNum">      93 </span>            : //
<span class="lineNum">      94 </span>            : // If you just want to declare the nsTArray types (e.g., if you're in a header
<span class="lineNum">      95 </span>            : // file and don't need the full nsTArray definitions) consider including
<span class="lineNum">      96 </span>            : // nsTArrayForwardDeclare.h instead of nsTArray.h.
<span class="lineNum">      97 </span>            : //
<span class="lineNum">      98 </span>            : // The template parameter (i.e., T in nsTArray&lt;T&gt;) specifies the type of the
<span class="lineNum">      99 </span>            : // elements and has the following requirements:
<span class="lineNum">     100 </span>            : //
<span class="lineNum">     101 </span>            : //   T MUST be safely memmove()'able.
<span class="lineNum">     102 </span>            : //   T MUST define a copy-constructor.
<span class="lineNum">     103 </span>            : //   T MAY define operator&lt; for sorting.
<span class="lineNum">     104 </span>            : //   T MAY define operator== for searching.
<span class="lineNum">     105 </span>            : //
<span class="lineNum">     106 </span>            : // (Note that the memmove requirement may be relaxed for certain types - see
<span class="lineNum">     107 </span>            : // nsTArray_CopyChooser below.)
<span class="lineNum">     108 </span>            : //
<span class="lineNum">     109 </span>            : // For methods taking a Comparator instance, the Comparator must be a class
<span class="lineNum">     110 </span>            : // defining the following methods:
<span class="lineNum">     111 </span>            : //
<span class="lineNum">     112 </span>            : //   class Comparator {
<span class="lineNum">     113 </span>            : //     public:
<span class="lineNum">     114 </span>            : //       /** @return True if the elements are equals; false otherwise. */
<span class="lineNum">     115 </span>            : //       bool Equals(const elem_type&amp; a, const Item&amp; b) const;
<span class="lineNum">     116 </span>            : //
<span class="lineNum">     117 </span>            : //       /** @return True if (a &lt; b); false otherwise. */
<span class="lineNum">     118 </span>            : //       bool LessThan(const elem_type&amp; a, const Item&amp; b) const;
<span class="lineNum">     119 </span>            : //   };
<span class="lineNum">     120 </span>            : //
<span class="lineNum">     121 </span>            : // The Equals method is used for searching, and the LessThan method is used for
<span class="lineNum">     122 </span>            : // searching and sorting.  The |Item| type above can be arbitrary, but must
<span class="lineNum">     123 </span>            : // match the Item type passed to the sort or search function.
<span class="lineNum">     124 </span>            : //
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : //
<span class="lineNum">     128 </span>            : // nsTArrayFallibleResult and nsTArrayInfallibleResult types are proxy types
<span class="lineNum">     129 </span>            : // which are used because you cannot use a templated type which is bound to
<span class="lineNum">     130 </span>            : // void as an argument to a void function.  In order to work around that, we
<span class="lineNum">     131 </span>            : // encode either a void or a boolean inside these proxy objects, and pass them
<span class="lineNum">     132 </span>            : // to the aforementioned function instead, and then use the type information to
<span class="lineNum">     133 </span>            : // decide what to do in the function.
<span class="lineNum">     134 </span>            : //
<span class="lineNum">     135 </span>            : // Note that public nsTArray methods should never return a proxy type.  Such
<span class="lineNum">     136 </span>            : // types are only meant to be used in the internal nsTArray helper methods.
<span class="lineNum">     137 </span>            : // Public methods returning non-proxy types cannot be called from other
<span class="lineNum">     138 </span>            : // nsTArray members.
<span class="lineNum">     139 </span>            : //
<span class="lineNum">     140 </span>            : struct nsTArrayFallibleResult
<span class="lineNum">     141 </span>            : {
<span class="lineNum">     142 </span>            :   // Note: allows implicit conversions from and to bool
<span class="lineNum">     143 </span>            :   MOZ_IMPLICIT nsTArrayFallibleResult(bool aResult) : mResult(aResult) {}
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   MOZ_IMPLICIT operator bool() { return mResult; }</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : private:
<span class="lineNum">     148 </span>            :   bool mResult;
<span class="lineNum">     149 </span>            : };
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : struct nsTArrayInfallibleResult
<span class="lineNum">     152 </span>            : {
<span class="lineNum">     153 </span>            : };
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : //
<span class="lineNum">     156 </span>            : // nsTArray*Allocators must all use the same |free()|, to allow swap()'ing
<span class="lineNum">     157 </span>            : // between fallible and infallible variants.
<span class="lineNum">     158 </span>            : //
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            : struct nsTArrayFallibleAllocatorBase
<span class="lineNum">     161 </span>            : {
<span class="lineNum">     162 </span>            :   typedef bool ResultType;
<span class="lineNum">     163 </span>            :   typedef nsTArrayFallibleResult ResultTypeProxy;
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   static ResultType Result(ResultTypeProxy aResult) { return aResult; }</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   static bool Successful(ResultTypeProxy aResult) { return aResult; }</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   static ResultTypeProxy SuccessResult() { return true; }</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   static ResultTypeProxy FailureResult() { return false; }</span>
<span class="lineNum">     169 </span>            :   static ResultType ConvertBoolToResultType(bool aValue) { return aValue; }
<span class="lineNum">     170 </span>            : };
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : struct nsTArrayInfallibleAllocatorBase
<span class="lineNum">     173 </span>            : {
<span class="lineNum">     174 </span>            :   typedef void ResultType;
<span class="lineNum">     175 </span>            :   typedef nsTArrayInfallibleResult ResultTypeProxy;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   static ResultType Result(ResultTypeProxy aResult) {}
<span class="lineNum">     178 </span>            :   static bool Successful(ResultTypeProxy) { return true; }
<span class="lineNum">     179 </span>            :   static ResultTypeProxy SuccessResult() { return ResultTypeProxy(); }
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :   static ResultTypeProxy FailureResult()</span>
<span class="lineNum">     182 </span>            :   {
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     MOZ_CRASH(&quot;Infallible nsTArray should never fail&quot;);</span>
<span class="lineNum">     184 </span>            :     return ResultTypeProxy();
<span class="lineNum">     185 </span>            :   }
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   static ResultType ConvertBoolToResultType(bool aValue)</span>
<span class="lineNum">     188 </span>            :   {
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     if (!aValue) {</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       MOZ_CRASH(&quot;infallible nsTArray should never convert false to ResultType&quot;);</span>
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     193 </span>            : };
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : struct nsTArrayFallibleAllocator : nsTArrayFallibleAllocatorBase
<span class="lineNum">     196 </span>            : {
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   static void* Malloc(size_t aSize) { return malloc(aSize); }</span>
<span class="lineNum">     198 </span>            :   static void* Realloc(void* aPtr, size_t aSize)
<span class="lineNum">     199 </span>            :   {
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :     return realloc(aPtr, aSize);</span>
<span class="lineNum">     201 </span>            :   }
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :   static void Free(void* aPtr) { free(aPtr); }</span>
<span class="lineNum">     204 </span>            :   static void SizeTooBig(size_t) {}
<span class="lineNum">     205 </span>            : };
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : struct nsTArrayInfallibleAllocator : nsTArrayInfallibleAllocatorBase
<span class="lineNum">     208 </span>            : {
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   static void* Malloc(size_t aSize) { return moz_xmalloc(aSize); }</span>
<span class="lineNum">     210 </span>            :   static void* Realloc(void* aPtr, size_t aSize)
<span class="lineNum">     211 </span>            :   {
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     return moz_xrealloc(aPtr, aSize);</span>
<span class="lineNum">     213 </span>            :   }
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   static void Free(void* aPtr) { free(aPtr); }</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   static void SizeTooBig(size_t aSize) { NS_ABORT_OOM(aSize); }</span>
<span class="lineNum">     217 </span>            : };
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : // nsTArray_base stores elements into the space allocated beyond
<span class="lineNum">     220 </span>            : // sizeof(*this).  This is done to minimize the size of the nsTArray
<span class="lineNum">     221 </span>            : // object when it is empty.
<span class="lineNum">     222 </span>            : struct nsTArrayHeader
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span>            :   uint32_t mLength;
<span class="lineNum">     225 </span>            :   uint32_t mCapacity : 31;
<span class="lineNum">     226 </span>            :   uint32_t mIsAutoArray : 1;
<span class="lineNum">     227 </span>            : };
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            : extern &quot;C&quot; {
<span class="lineNum">     230 </span>            :   extern nsTArrayHeader sEmptyTArrayHeader;
<span class="lineNum">     231 </span>            : }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : // This class provides a SafeElementAt method to nsTArray&lt;T*&gt; which does
<span class="lineNum">     234 </span>            : // not take a second default value parameter.
<span class="lineNum">     235 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     236 </span>            : struct nsTArray_SafeElementAtHelper
<span class="lineNum">     237 </span>            : {
<span class="lineNum">     238 </span>            :   typedef E*       elem_type;
<span class="lineNum">     239 </span>            :   typedef size_t   index_type;
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :   // No implementation is provided for these two methods, and that is on
<span class="lineNum">     242 </span>            :   // purpose, since we don't support these functions on non-pointer type
<span class="lineNum">     243 </span>            :   // instantiations.
<span class="lineNum">     244 </span>            :   elem_type&amp; SafeElementAt(index_type aIndex);
<span class="lineNum">     245 </span>            :   const elem_type&amp; SafeElementAt(index_type aIndex) const;
<span class="lineNum">     246 </span>            : };
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     249 </span>            : struct nsTArray_SafeElementAtHelper&lt;E*, Derived&gt;
<span class="lineNum">     250 </span>            : {
<span class="lineNum">     251 </span>            :   typedef E*       elem_type;
<span class="lineNum">     252 </span>            :   //typedef const E* const_elem_type;   XXX: see below
<span class="lineNum">     253 </span>            :   typedef size_t   index_type;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :   elem_type SafeElementAt(index_type aIndex)</span>
<span class="lineNum">     256 </span>            :   {
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :     return static_cast&lt;Derived*&gt;(this)-&gt;SafeElementAt(aIndex, nullptr);</span>
<span class="lineNum">     258 </span>            :   }
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :   // XXX: Probably should return const_elem_type, but callsites must be fixed.
<span class="lineNum">     261 </span>            :   // Also, the use of const_elem_type for nsTArray&lt;xpcGCCallback&gt; in
<span class="lineNum">     262 </span>            :   // xpcprivate.h causes build failures on Windows because xpcGCCallback is a
<span class="lineNum">     263 </span>            :   // function pointer and MSVC doesn't like qualifying it with |const|.
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   elem_type SafeElementAt(index_type aIndex) const</span>
<span class="lineNum">     265 </span>            :   {
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     return static_cast&lt;const Derived*&gt;(this)-&gt;SafeElementAt(aIndex, nullptr);</span>
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span>            : };
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            : // E is the base type that the smart pointer is templated over; the
<span class="lineNum">     271 </span>            : // smart pointer can act as E*.
<span class="lineNum">     272 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     273 </span>            : struct nsTArray_SafeElementAtSmartPtrHelper
<span class="lineNum">     274 </span>            : {
<span class="lineNum">     275 </span>            :   typedef E*       elem_type;
<span class="lineNum">     276 </span>            :   typedef const E* const_elem_type;
<span class="lineNum">     277 </span>            :   typedef size_t   index_type;
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   elem_type SafeElementAt(index_type aIndex)</span>
<span class="lineNum">     280 </span>            :   {
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     return static_cast&lt;Derived*&gt;(this)-&gt;SafeElementAt(aIndex, nullptr);</span>
<span class="lineNum">     282 </span>            :   }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :   // XXX: Probably should return const_elem_type, but callsites must be fixed.
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   elem_type SafeElementAt(index_type aIndex) const</span>
<span class="lineNum">     286 </span>            :   {
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     return static_cast&lt;const Derived*&gt;(this)-&gt;SafeElementAt(aIndex, nullptr);</span>
<span class="lineNum">     288 </span>            :   }
<span class="lineNum">     289 </span>            : };
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : template&lt;class T&gt; class nsCOMPtr;
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     294 </span><span class="lineNoCov">          0 : struct nsTArray_SafeElementAtHelper&lt;nsCOMPtr&lt;E&gt;, Derived&gt;</span>
<span class="lineNum">     295 </span>            :   : public nsTArray_SafeElementAtSmartPtrHelper&lt;E, Derived&gt;
<span class="lineNum">     296 </span>            : {
<span class="lineNum">     297 </span>            : };
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     300 </span><span class="lineNoCov">          0 : struct nsTArray_SafeElementAtHelper&lt;RefPtr&lt;E&gt;, Derived&gt;</span>
<span class="lineNum">     301 </span>            :   : public nsTArray_SafeElementAtSmartPtrHelper&lt;E, Derived&gt;
<span class="lineNum">     302 </span>            : {
<span class="lineNum">     303 </span>            : };
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : namespace mozilla {
<span class="lineNum">     306 </span>            : template&lt;class T&gt; class OwningNonNull;
<span class="lineNum">     307 </span>            : } // namespace mozilla
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     310 </span>            : struct nsTArray_SafeElementAtHelper&lt;mozilla::OwningNonNull&lt;E&gt;, Derived&gt;
<span class="lineNum">     311 </span>            : {
<span class="lineNum">     312 </span>            :   typedef E*       elem_type;
<span class="lineNum">     313 </span>            :   typedef const E* const_elem_type;
<span class="lineNum">     314 </span>            :   typedef size_t   index_type;
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :   elem_type SafeElementAt(index_type aIndex)</span>
<span class="lineNum">     317 </span>            :   {
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     if (aIndex &lt; static_cast&lt;Derived*&gt;(this)-&gt;Length()) {</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :       return static_cast&lt;Derived*&gt;(this)-&gt;ElementAt(aIndex);</span>
<span class="lineNum">     320 </span>            :     }
<span class="lineNum">     321 </span>            :     return nullptr;
<span class="lineNum">     322 </span>            :   }
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :   // XXX: Probably should return const_elem_type, but callsites must be fixed.
<span class="lineNum">     325 </span>            :   elem_type SafeElementAt(index_type aIndex) const
<span class="lineNum">     326 </span>            :   {
<span class="lineNum">     327 </span>            :     if (aIndex &lt; static_cast&lt;const Derived*&gt;(this)-&gt;Length()) {
<span class="lineNum">     328 </span>            :       return static_cast&lt;const Derived*&gt;(this)-&gt;ElementAt(aIndex);
<span class="lineNum">     329 </span>            :     }
<span class="lineNum">     330 </span>            :     return nullptr;
<span class="lineNum">     331 </span>            :   }
<span class="lineNum">     332 </span>            : };
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : // Servo bindings.
<span class="lineNum">     335 </span>            : extern &quot;C&quot; void Gecko_EnsureTArrayCapacity(void* aArray,
<span class="lineNum">     336 </span>            :                                            size_t aCapacity,
<span class="lineNum">     337 </span>            :                                            size_t aElementSize);
<span class="lineNum">     338 </span>            : extern &quot;C&quot; void Gecko_ClearPODTArray(void* aArray,
<span class="lineNum">     339 </span>            :                                      size_t aElementSize,
<span class="lineNum">     340 </span>            :                                      size_t aElementAlign);
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : MOZ_NORETURN MOZ_COLD void
<span class="lineNum">     343 </span>            : InvalidArrayIndex_CRASH(size_t aIndex, size_t aLength);
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : //
<span class="lineNum">     346 </span>            : // This class serves as a base class for nsTArray.  It shouldn't be used
<span class="lineNum">     347 </span>            : // directly.  It holds common implementation code that does not depend on the
<span class="lineNum">     348 </span>            : // element type of the nsTArray.
<span class="lineNum">     349 </span>            : //
<span class="lineNum">     350 </span>            : template&lt;class Alloc, class Copy&gt;
<span class="lineNum">     351 </span>            : class nsTArray_base
<span class="lineNum">     352 </span>            : {
<span class="lineNum">     353 </span>            :   // Allow swapping elements with |nsTArray_base|s created using a
<span class="lineNum">     354 </span>            :   // different allocator.  This is kosher because all allocators use
<span class="lineNum">     355 </span>            :   // the same free().
<span class="lineNum">     356 </span>            :   template&lt;class Allocator, class Copier&gt;
<span class="lineNum">     357 </span>            :   friend class nsTArray_base;
<span class="lineNum">     358 </span>            :   friend void Gecko_EnsureTArrayCapacity(void* aArray, size_t aCapacity,
<span class="lineNum">     359 </span>            :                                          size_t aElemSize);
<span class="lineNum">     360 </span>            :   friend void Gecko_ClearPODTArray(void* aTArray, size_t aElementSize,
<span class="lineNum">     361 </span>            :                                    size_t aElementAlign);
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : protected:
<span class="lineNum">     364 </span>            :   typedef nsTArrayHeader Header;
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : public:
<span class="lineNum">     367 </span>            :   typedef size_t size_type;
<span class="lineNum">     368 </span>            :   typedef size_t index_type;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   // @return The number of elements in the array.
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :   size_type Length() const { return mHdr-&gt;mLength; }</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :   // @return True if the array is empty or false otherwise.
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   bool IsEmpty() const { return Length() == 0; }</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :   // @return The number of elements that can fit in the array without forcing
<span class="lineNum">     377 </span>            :   // the array to be re-allocated.  The length of an array is always less
<span class="lineNum">     378 </span>            :   // than or equal to its capacity.
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :   size_type Capacity() const {  return mHdr-&gt;mCapacity; }</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : #ifdef DEBUG
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   void* DebugGetHeader() const { return mHdr; }</span>
<span class="lineNum">     383 </span>            : #endif
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : protected:
<span class="lineNum">     386 </span>            :   nsTArray_base();
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   ~nsTArray_base();
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   // Resize the storage if necessary to achieve the requested capacity.
<span class="lineNum">     391 </span>            :   // @param aCapacity The requested number of array elements.
<span class="lineNum">     392 </span>            :   // @param aElemSize The size of an array element.
<span class="lineNum">     393 </span>            :   // @return False if insufficient memory is available; true otherwise.
<span class="lineNum">     394 </span>            :   template&lt;typename ActualAlloc&gt;
<span class="lineNum">     395 </span>            :   typename ActualAlloc::ResultTypeProxy EnsureCapacity(size_type aCapacity,
<span class="lineNum">     396 </span>            :                                                        size_type aElemSize);
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   // Tries to resize the storage to the minimum required amount. If this fails,
<span class="lineNum">     399 </span>            :   // the array is left as-is.
<span class="lineNum">     400 </span>            :   // @param aElemSize  The size of an array element.
<span class="lineNum">     401 </span>            :   // @param aElemAlign The alignment in bytes of an array element.
<span class="lineNum">     402 </span>            :   void ShrinkCapacity(size_type aElemSize, size_t aElemAlign);
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   // This method may be called to resize a &quot;gap&quot; in the array by shifting
<span class="lineNum">     405 </span>            :   // elements around.  It updates mLength appropriately.  If the resulting
<span class="lineNum">     406 </span>            :   // array has zero elements, then the array's memory is free'd.
<span class="lineNum">     407 </span>            :   // @param aStart     The starting index of the gap.
<span class="lineNum">     408 </span>            :   // @param aOldLen    The current length of the gap.
<span class="lineNum">     409 </span>            :   // @param aNewLen    The desired length of the gap.
<span class="lineNum">     410 </span>            :   // @param aElemSize  The size of an array element.
<span class="lineNum">     411 </span>            :   // @param aElemAlign The alignment in bytes of an array element.
<span class="lineNum">     412 </span>            :   template&lt;typename ActualAlloc&gt;
<span class="lineNum">     413 </span>            :   void ShiftData(index_type aStart, size_type aOldLen, size_type aNewLen,
<span class="lineNum">     414 </span>            :                  size_type aElemSize, size_t aElemAlign);
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :   // This method may be called to swap elements from the end of the array to
<span class="lineNum">     417 </span>            :   // fill a &quot;gap&quot; in the array. If the resulting array has zero elements, then
<span class="lineNum">     418 </span>            :   // the array's memory is free'd.
<span class="lineNum">     419 </span>            :   // @param aStart     The starting index of the gap.
<span class="lineNum">     420 </span>            :   // @param aCount     The length of the gap.
<span class="lineNum">     421 </span>            :   // @param aElemSize  The size of an array element.
<span class="lineNum">     422 </span>            :   // @param aElemAlign The alignment in bytes of an array element.
<span class="lineNum">     423 </span>            :   template&lt;typename ActualAlloc&gt;
<span class="lineNum">     424 </span>            :   void SwapFromEnd(index_type aStart, size_type aCount,
<span class="lineNum">     425 </span>            :                    size_type aElemSize, size_t aElemAlign);
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :   // This method increments the length member of the array's header.
<span class="lineNum">     428 </span>            :   // Note that mHdr may actually be sEmptyTArrayHeader in the case where a
<span class="lineNum">     429 </span>            :   // zero-length array is inserted into our array. But then aNum should
<span class="lineNum">     430 </span>            :   // always be 0.
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :   void IncrementLength(size_t aNum)</span>
<span class="lineNum">     432 </span>            :   {
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :     if (mHdr == EmptyHdr()) {</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       if (MOZ_UNLIKELY(aNum != 0)) {</span>
<span class="lineNum">     435 </span>            :         // Writing a non-zero length to the empty header would be extremely bad.
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         MOZ_CRASH();</span>
<span class="lineNum">     437 </span>            :       }
<span class="lineNum">     438 </span>            :     } else {
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :       mHdr-&gt;mLength += aNum;</span>
<span class="lineNum">     440 </span>            :     }
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :   // This method inserts blank slots into the array.
<span class="lineNum">     444 </span>            :   // @param aIndex the place to insert the new elements. This must be no
<span class="lineNum">     445 </span>            :   //               greater than the current length of the array.
<span class="lineNum">     446 </span>            :   // @param aCount the number of slots to insert
<span class="lineNum">     447 </span>            :   // @param aElementSize the size of an array element.
<span class="lineNum">     448 </span>            :   // @param aElemAlign the alignment in bytes of an array element.
<span class="lineNum">     449 </span>            :   template&lt;typename ActualAlloc&gt;
<span class="lineNum">     450 </span>            :   bool InsertSlotsAt(index_type aIndex, size_type aCount,
<span class="lineNum">     451 </span>            :                      size_type aElementSize, size_t aElemAlign);
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   template&lt;typename ActualAlloc, class Allocator&gt;
<span class="lineNum">     454 </span>            :   typename ActualAlloc::ResultTypeProxy
<span class="lineNum">     455 </span>            :   SwapArrayElements(nsTArray_base&lt;Allocator, Copy&gt;&amp; aOther,
<span class="lineNum">     456 </span>            :                     size_type aElemSize,
<span class="lineNum">     457 </span>            :                     size_t aElemAlign);
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :   // This is an RAII class used in SwapArrayElements.
<span class="lineNum">     460 </span>            :   class IsAutoArrayRestorer
<span class="lineNum">     461 </span>            :   {
<span class="lineNum">     462 </span>            :   public:
<span class="lineNum">     463 </span>            :     IsAutoArrayRestorer(nsTArray_base&lt;Alloc, Copy&gt;&amp; aArray, size_t aElemAlign);
<span class="lineNum">     464 </span>            :     ~IsAutoArrayRestorer();
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   private:
<span class="lineNum">     467 </span>            :     nsTArray_base&lt;Alloc, Copy&gt;&amp; mArray;
<span class="lineNum">     468 </span>            :     size_t mElemAlign;
<span class="lineNum">     469 </span>            :     bool mIsAuto;
<span class="lineNum">     470 </span>            :   };
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :   // Helper function for SwapArrayElements. Ensures that if the array
<span class="lineNum">     473 </span>            :   // is an AutoTArray that it doesn't use the built-in buffer.
<span class="lineNum">     474 </span>            :   template&lt;typename ActualAlloc&gt;
<span class="lineNum">     475 </span>            :   bool EnsureNotUsingAutoArrayBuffer(size_type aElemSize);
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   // Returns true if this nsTArray is an AutoTArray with a built-in buffer.
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   bool IsAutoArray() const { return mHdr-&gt;mIsAutoArray; }</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   // Returns a Header for the built-in buffer of this AutoTArray.
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   Header* GetAutoArrayBuffer(size_t aElemAlign)</span>
<span class="lineNum">     482 </span>            :   {
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(IsAutoArray(), &quot;Should be an auto array to call this&quot;);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :     return GetAutoArrayBufferUnsafe(aElemAlign);</span>
<span class="lineNum">     485 </span>            :   }
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :   const Header* GetAutoArrayBuffer(size_t aElemAlign) const</span>
<span class="lineNum">     487 </span>            :   {
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(IsAutoArray(), &quot;Should be an auto array to call this&quot;);</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :     return GetAutoArrayBufferUnsafe(aElemAlign);</span>
<span class="lineNum">     490 </span>            :   }
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :   // Returns a Header for the built-in buffer of this AutoTArray, but doesn't
<span class="lineNum">     493 </span>            :   // assert that we are an AutoTArray.
<span class="lineNum">     494 </span>            :   Header* GetAutoArrayBufferUnsafe(size_t aElemAlign)
<span class="lineNum">     495 </span>            :   {
<span class="lineNum">     496 </span>            :     return const_cast&lt;Header*&gt;(static_cast&lt;const nsTArray_base&lt;Alloc, Copy&gt;*&gt;(
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :       this)-&gt;GetAutoArrayBufferUnsafe(aElemAlign));</span>
<span class="lineNum">     498 </span>            :   }
<span class="lineNum">     499 </span>            :   const Header* GetAutoArrayBufferUnsafe(size_t aElemAlign) const;
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :   // Returns true if this is an AutoTArray and it currently uses the
<span class="lineNum">     502 </span>            :   // built-in buffer to store its elements.
<span class="lineNum">     503 </span>            :   bool UsesAutoArrayBuffer() const;
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            :   // The array's elements (prefixed with a Header).  This pointer is never
<span class="lineNum">     506 </span>            :   // null.  If the array is empty, then this will point to sEmptyTArrayHeader.
<span class="lineNum">     507 </span>            :   Header* mHdr;
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :   Header* Hdr() const { return mHdr; }</span>
<span class="lineNum">     510 </span>            :   Header** PtrToHdr() { return &amp;mHdr; }
<span class="lineNum">     511 </span>            :   static Header* EmptyHdr() { return &amp;sEmptyTArrayHeader; }
<span class="lineNum">     512 </span>            : };
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : //
<span class="lineNum">     515 </span>            : // This class defines convenience functions for element specific operations.
<span class="lineNum">     516 </span>            : // Specialize this template if necessary.
<span class="lineNum">     517 </span>            : //
<span class="lineNum">     518 </span>            : template&lt;class E&gt;
<span class="lineNum">     519 </span>            : class nsTArrayElementTraits
<span class="lineNum">     520 </span>            : {
<span class="lineNum">     521 </span>            : public:
<span class="lineNum">     522 </span>            :   // Invoke the default constructor in place.
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   static inline void Construct(E* aE)</span>
<span class="lineNum">     524 </span>            :   {
<span class="lineNum">     525 </span>            :     // Do NOT call &quot;E()&quot;! That triggers C++ &quot;default initialization&quot;
<span class="lineNum">     526 </span>            :     // which zeroes out POD (&quot;plain old data&quot;) types such as regular
<span class="lineNum">     527 </span>            :     // ints.  We don't want that because it can be a performance issue
<span class="lineNum">     528 </span>            :     // and people don't expect it; nsTArray should work like a regular
<span class="lineNum">     529 </span>            :     // C/C++ array in this respect.
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :     new (static_cast&lt;void*&gt;(aE)) E;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     532 </span>            :   // Invoke the copy-constructor in place.
<span class="lineNum">     533 </span>            :   template&lt;class A&gt;
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   static inline void Construct(E* aE, A&amp;&amp; aArg)</span>
<span class="lineNum">     535 </span>            :   {
<span class="lineNum">     536 </span>            :     typedef typename mozilla::RemoveCV&lt;E&gt;::Type E_NoCV;
<span class="lineNum">     537 </span>            :     typedef typename mozilla::RemoveCV&lt;A&gt;::Type A_NoCV;
<span class="lineNum">     538 </span>            :     static_assert(!mozilla::IsSame&lt;E_NoCV*, A_NoCV&gt;::value,
<span class="lineNum">     539 </span>            :                   &quot;For safety, we disallow constructing nsTArray&lt;E&gt; elements &quot;
<span class="lineNum">     540 </span>            :                   &quot;from E* pointers. See bug 960591.&quot;);
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     new (static_cast&lt;void*&gt;(aE)) E(std::forward&lt;A&gt;(aArg));</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     543 </span>            :   // Invoke the destructor in place.
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   static inline void Destruct(E* aE) { aE-&gt;~E(); }</span>
<span class="lineNum">     545 </span>            : };
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : // The default comparator used by nsTArray
<span class="lineNum">     548 </span>            : template&lt;class A, class B&gt;
<span class="lineNum">     549 </span>            : class nsDefaultComparator
<span class="lineNum">     550 </span>            : {
<span class="lineNum">     551 </span>            : public:
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   bool Equals(const A&amp; aA, const B&amp; aB) const { return aA == aB; }</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :   bool LessThan(const A&amp; aA, const B&amp; aB) const { return aA &lt; aB; }</span>
<span class="lineNum">     554 </span>            : };
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : template&lt;bool IsPod, bool IsSameType&gt;
<span class="lineNum">     557 </span>            : struct AssignRangeAlgorithm
<span class="lineNum">     558 </span>            : {
<span class="lineNum">     559 </span>            :   template&lt;class Item, class ElemType, class IndexType, class SizeType&gt;
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   static void implementation(ElemType* aElements, IndexType aStart,</span>
<span class="lineNum">     561 </span>            :                              SizeType aCount, const Item* aValues)
<span class="lineNum">     562 </span>            :   {
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     ElemType* iter = aElements + aStart;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     ElemType* end = iter + aCount;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     for (; iter != end; ++iter, ++aValues) {</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :       nsTArrayElementTraits&lt;ElemType&gt;::Construct(iter, *aValues);</span>
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     569 </span>            : };
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : template&lt;&gt;
<span class="lineNum">     572 </span>            : struct AssignRangeAlgorithm&lt;true, true&gt;
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span>            :   template&lt;class Item, class ElemType, class IndexType, class SizeType&gt;
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :   static void implementation(ElemType* aElements, IndexType aStart,</span>
<span class="lineNum">     576 </span>            :                              SizeType aCount, const Item* aValues)
<span class="lineNum">     577 </span>            :   {
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     memcpy(aElements + aStart, aValues, aCount * sizeof(ElemType));</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     580 </span>            : };
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            : //
<span class="lineNum">     583 </span>            : // Normally elements are copied with memcpy and memmove, but for some element
<span class="lineNum">     584 </span>            : // types that is problematic.  The nsTArray_CopyChooser template class can be
<span class="lineNum">     585 </span>            : // specialized to ensure that copying calls constructors and destructors
<span class="lineNum">     586 </span>            : // instead, as is done below for JS::Heap&lt;E&gt; elements.
<span class="lineNum">     587 </span>            : //
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            : //
<span class="lineNum">     590 </span>            : // A class that defines how to copy elements using memcpy/memmove.
<span class="lineNum">     591 </span>            : //
<span class="lineNum">     592 </span>            : struct nsTArray_CopyWithMemutils
<span class="lineNum">     593 </span>            : {
<span class="lineNum">     594 </span>            :   const static bool allowRealloc = true;
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :   static void MoveNonOverlappingRegionWithHeader(void* aDest, const void* aSrc,</span>
<span class="lineNum">     597 </span>            :                                                  size_t aCount, size_t aElemSize)
<span class="lineNum">     598 </span>            :   {
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :     memcpy(aDest, aSrc, sizeof(nsTArrayHeader) + aCount * aElemSize);</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   static void MoveOverlappingRegion(void* aDest, void* aSrc, size_t aCount,</span>
<span class="lineNum">     603 </span>            :                                     size_t aElemSize)
<span class="lineNum">     604 </span>            :   {
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :     memmove(aDest, aSrc, aCount * aElemSize);</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   static void MoveNonOverlappingRegion(void* aDest, void* aSrc, size_t aCount,</span>
<span class="lineNum">     609 </span>            :                                        size_t aElemSize)
<span class="lineNum">     610 </span>            :   {
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     memcpy(aDest, aSrc, aCount * aElemSize);</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     613 </span>            : };
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            : //
<span class="lineNum">     616 </span>            : // A template class that defines how to copy elements calling their constructors
<span class="lineNum">     617 </span>            : // and destructors appropriately.
<span class="lineNum">     618 </span>            : //
<span class="lineNum">     619 </span>            : template&lt;class ElemType&gt;
<span class="lineNum">     620 </span>            : struct nsTArray_CopyWithConstructors
<span class="lineNum">     621 </span>            : {
<span class="lineNum">     622 </span>            :   typedef nsTArrayElementTraits&lt;ElemType&gt; traits;
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            :   const static bool allowRealloc = false;
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   static void MoveNonOverlappingRegionWithHeader(void* aDest, void* aSrc, size_t aCount,</span>
<span class="lineNum">     627 </span>            :                                                  size_t aElemSize)
<span class="lineNum">     628 </span>            :   {
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     nsTArrayHeader* destHeader = static_cast&lt;nsTArrayHeader*&gt;(aDest);</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     nsTArrayHeader* srcHeader = static_cast&lt;nsTArrayHeader*&gt;(aSrc);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     *destHeader = *srcHeader;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :     MoveNonOverlappingRegion(static_cast&lt;uint8_t*&gt;(aDest) + sizeof(nsTArrayHeader),</span>
<span class="lineNum">     633 </span>            :                              static_cast&lt;uint8_t*&gt;(aSrc) + sizeof(nsTArrayHeader),
<span class="lineNum">     634 </span>            :                              aCount, aElemSize);
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :   // These functions are defined by analogy with memmove and memcpy.
<span class="lineNum">     638 </span>            :   // What they actually do is slightly different: MoveOverlappingRegion
<span class="lineNum">     639 </span>            :   // checks to see which direction the movement needs to take place,
<span class="lineNum">     640 </span>            :   // whether from back-to-front of the range to be moved or from
<span class="lineNum">     641 </span>            :   // front-to-back.  MoveNonOverlappingRegion assumes that moving
<span class="lineNum">     642 </span>            :   // front-to-back is always valid.  So they're really more like
<span class="lineNum">     643 </span>            :   // std::move{_backward,} in that respect.  We keep these names because
<span class="lineNum">     644 </span>            :   // we think they read slightly better, and MoveNonOverlappingRegion is
<span class="lineNum">     645 </span>            :   // only ever called on overlapping regions from MoveOverlappingRegion.
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   static void MoveOverlappingRegion(void* aDest, void* aSrc, size_t aCount,</span>
<span class="lineNum">     647 </span>            :                                     size_t aElemSize)
<span class="lineNum">     648 </span>            :   {
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :     ElemType* destElem = static_cast&lt;ElemType*&gt;(aDest);</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :     ElemType* srcElem = static_cast&lt;ElemType*&gt;(aSrc);</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     ElemType* destElemEnd = destElem + aCount;</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     ElemType* srcElemEnd = srcElem + aCount;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     if (destElem == srcElem) {</span>
<span class="lineNum">     654 </span>            :       return;  // In practice, we don't do this.
<span class="lineNum">     655 </span>            :     }
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :     // Figure out whether to copy back-to-front or front-to-back.
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     if (srcElemEnd &gt; destElem &amp;&amp; srcElemEnd &lt; destElemEnd) {</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       while (destElemEnd != destElem) {</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         --destElemEnd;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         --srcElemEnd;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         traits::Construct(destElemEnd, std::move(*srcElemEnd));</span>
<span class="lineNum">     663 </span>            :         traits::Destruct(srcElemEnd);
<span class="lineNum">     664 </span>            :       }
<span class="lineNum">     665 </span>            :     } else {
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :       MoveNonOverlappingRegion(aDest, aSrc, aCount, aElemSize);</span>
<span class="lineNum">     667 </span>            :     }
<span class="lineNum">     668 </span>            :   }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   static void MoveNonOverlappingRegion(void* aDest, void* aSrc, size_t aCount,</span>
<span class="lineNum">     671 </span>            :                                        size_t aElemSize)
<span class="lineNum">     672 </span>            :   {
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     ElemType* destElem = static_cast&lt;ElemType*&gt;(aDest);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :     ElemType* srcElem = static_cast&lt;ElemType*&gt;(aSrc);</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     ElemType* destElemEnd = destElem + aCount;</span>
<span class="lineNum">     676 </span>            : #ifdef DEBUG
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :     ElemType* srcElemEnd = srcElem + aCount;</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(srcElemEnd &lt;= destElem || srcElemEnd &gt; destElemEnd);</span>
<span class="lineNum">     679 </span>            : #endif
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     while (destElem != destElemEnd) {</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :       traits::Construct(destElem, std::move(*srcElem));</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :       traits::Destruct(srcElem);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :       ++destElem;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :       ++srcElem;</span>
<span class="lineNum">     685 </span>            :     }
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     687 </span>            : };
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            : //
<span class="lineNum">     690 </span>            : // The default behaviour is to use memcpy/memmove for everything.
<span class="lineNum">     691 </span>            : //
<span class="lineNum">     692 </span>            : template&lt;class E&gt;
<span class="lineNum">     693 </span>            : struct MOZ_NEEDS_MEMMOVABLE_TYPE nsTArray_CopyChooser
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span>            :   using Type = nsTArray_CopyWithMemutils;
<span class="lineNum">     696 </span>            : };
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : //
<span class="lineNum">     699 </span>            : // Some classes require constructors/destructors to be called, so they are
<span class="lineNum">     700 </span>            : // specialized here.
<span class="lineNum">     701 </span>            : //
<span class="lineNum">     702 </span>            : #define DECLARE_USE_COPY_CONSTRUCTORS(T)                \
<span class="lineNum">     703 </span>            :   template&lt;&gt;                                            \
<span class="lineNum">     704 </span>            :   struct nsTArray_CopyChooser&lt;T&gt;                        \
<span class="lineNum">     705 </span>            :   {                                                     \
<span class="lineNum">     706 </span>            :     using Type = nsTArray_CopyWithConstructors&lt;T&gt;;      \
<span class="lineNum">     707 </span>            :   };
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            : #define DECLARE_USE_COPY_CONSTRUCTORS_FOR_TEMPLATE(T)   \
<span class="lineNum">     710 </span>            :   template&lt;typename S&gt;                                  \
<span class="lineNum">     711 </span>            :   struct nsTArray_CopyChooser&lt;T&lt;S&gt;&gt;                     \
<span class="lineNum">     712 </span>            :   {                                                     \
<span class="lineNum">     713 </span>            :     using Type = nsTArray_CopyWithConstructors&lt;T&lt;S&gt;&gt;;   \
<span class="lineNum">     714 </span>            :   };
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : DECLARE_USE_COPY_CONSTRUCTORS_FOR_TEMPLATE(JS::Heap)
<span class="lineNum">     717 </span>            : DECLARE_USE_COPY_CONSTRUCTORS_FOR_TEMPLATE(std::function)
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(nsRegion)
<span class="lineNum">     720 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(nsIntRegion)
<span class="lineNum">     721 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::layers::TileClient)
<span class="lineNum">     722 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::SerializedStructuredCloneBuffer)
<span class="lineNum">     723 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::dom::ipc::StructuredCloneData)
<span class="lineNum">     724 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::dom::ClonedMessageData)
<span class="lineNum">     725 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::dom::indexedDB::StructuredCloneReadInfo);
<span class="lineNum">     726 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::dom::indexedDB::ObjectStoreCursorResponse)
<span class="lineNum">     727 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::dom::indexedDB::SerializedStructuredCloneReadInfo);
<span class="lineNum">     728 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(JSStructuredCloneData)
<span class="lineNum">     729 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::dom::MessagePortMessage)
<span class="lineNum">     730 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(mozilla::SourceBufferTask)
<span class="lineNum">     731 </span>            : DECLARE_USE_COPY_CONSTRUCTORS(JS::ObjectPtr)
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : //
<span class="lineNum">     734 </span>            : // Base class for nsTArray_Impl that is templated on element type and derived
<span class="lineNum">     735 </span>            : // nsTArray_Impl class, to allow extra conversions to be added for specific
<span class="lineNum">     736 </span>            : // types.
<span class="lineNum">     737 </span>            : //
<span class="lineNum">     738 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     739 </span><span class="lineNoCov">          0 : struct nsTArray_TypedBase : public nsTArray_SafeElementAtHelper&lt;E, Derived&gt;</span>
<span class="lineNum">     740 </span>            : {
<span class="lineNum">     741 </span>            : };
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : //
<span class="lineNum">     744 </span>            : // Specialization of nsTArray_TypedBase for arrays containing JS::Heap&lt;E&gt;
<span class="lineNum">     745 </span>            : // elements.
<span class="lineNum">     746 </span>            : //
<span class="lineNum">     747 </span>            : // These conversions are safe because JS::Heap&lt;E&gt; and E share the same
<span class="lineNum">     748 </span>            : // representation, and since the result of the conversions are const references
<span class="lineNum">     749 </span>            : // we won't miss any barriers.
<span class="lineNum">     750 </span>            : //
<span class="lineNum">     751 </span>            : // The static_cast is necessary to obtain the correct address for the derived
<span class="lineNum">     752 </span>            : // class since we are a base class used in multiple inheritance.
<span class="lineNum">     753 </span>            : //
<span class="lineNum">     754 </span>            : template&lt;class E, class Derived&gt;
<span class="lineNum">     755 </span><span class="lineNoCov">          0 : struct nsTArray_TypedBase&lt;JS::Heap&lt;E&gt;, Derived&gt;</span>
<span class="lineNum">     756 </span>            :   : public nsTArray_SafeElementAtHelper&lt;JS::Heap&lt;E&gt;, Derived&gt;
<span class="lineNum">     757 </span>            : {
<span class="lineNum">     758 </span>            :   operator const nsTArray&lt;E&gt;&amp;()
<span class="lineNum">     759 </span>            :   {
<span class="lineNum">     760 </span>            :     static_assert(sizeof(E) == sizeof(JS::Heap&lt;E&gt;),
<span class="lineNum">     761 </span>            :                   &quot;JS::Heap&lt;E&gt; must be binary compatible with E.&quot;);
<span class="lineNum">     762 </span>            :     Derived* self = static_cast&lt;Derived*&gt;(this);
<span class="lineNum">     763 </span>            :     return *reinterpret_cast&lt;nsTArray&lt;E&gt; *&gt;(self);
<span class="lineNum">     764 </span>            :   }
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            :   operator const FallibleTArray&lt;E&gt;&amp;()
<span class="lineNum">     767 </span>            :   {
<span class="lineNum">     768 </span>            :     Derived* self = static_cast&lt;Derived*&gt;(this);
<span class="lineNum">     769 </span>            :     return *reinterpret_cast&lt;FallibleTArray&lt;E&gt; *&gt;(self);
<span class="lineNum">     770 </span>            :   }
<span class="lineNum">     771 </span>            : };
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : namespace detail {
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : template&lt;class Item, class Comparator&gt;
<span class="lineNum">     776 </span>            : struct ItemComparatorEq
<span class="lineNum">     777 </span>            : {
<span class="lineNum">     778 </span>            :   const Item&amp; mItem;
<span class="lineNum">     779 </span>            :   const Comparator&amp; mComp;
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :   ItemComparatorEq(const Item&amp; aItem, const Comparator&amp; aComp)</span>
<span class="lineNum">     781 </span>            :     : mItem(aItem)
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     , mComp(aComp)</span>
<span class="lineNum">     783 </span>            :   {}
<span class="lineNum">     784 </span>            :   template&lt;class T&gt;
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   int operator()(const T&amp; aElement) const {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     if (mComp.Equals(aElement, mItem)) {</span>
<span class="lineNum">     787 </span>            :       return 0;
<span class="lineNum">     788 </span>            :     }
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     return mComp.LessThan(aElement, mItem) ? 1 : -1;</span>
<span class="lineNum">     791 </span>            :   }
<span class="lineNum">     792 </span>            : };
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            : template&lt;class Item, class Comparator&gt;
<span class="lineNum">     795 </span>            : struct ItemComparatorFirstElementGT
<span class="lineNum">     796 </span>            : {
<span class="lineNum">     797 </span>            :   const Item&amp; mItem;
<span class="lineNum">     798 </span>            :   const Comparator&amp; mComp;
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :   ItemComparatorFirstElementGT(const Item&amp; aItem, const Comparator&amp; aComp)</span>
<span class="lineNum">     800 </span>            :     : mItem(aItem)
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     , mComp(aComp)</span>
<span class="lineNum">     802 </span>            :   {}
<span class="lineNum">     803 </span>            :   template&lt;class T&gt;
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   int operator()(const T&amp; aElement) const {</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     if (mComp.LessThan(aElement, mItem) ||</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         mComp.Equals(aElement, mItem)) {</span>
<span class="lineNum">     807 </span>            :       return 1;
<span class="lineNum">     808 </span>            :     } else {
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">     810 </span>            :     }
<span class="lineNum">     811 </span>            :   }
<span class="lineNum">     812 </span>            : };
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : } // namespace detail
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            : //
<span class="lineNum">     817 </span>            : // nsTArray_Impl contains most of the guts supporting nsTArray, FallibleTArray,
<span class="lineNum">     818 </span>            : // AutoTArray.
<span class="lineNum">     819 </span>            : //
<span class="lineNum">     820 </span>            : // The only situation in which you might need to use nsTArray_Impl in your code
<span class="lineNum">     821 </span>            : // is if you're writing code which mutates a TArray which may or may not be
<span class="lineNum">     822 </span>            : // infallible.
<span class="lineNum">     823 </span>            : //
<span class="lineNum">     824 </span>            : // Code which merely reads from a TArray which may or may not be infallible can
<span class="lineNum">     825 </span>            : // simply cast the TArray to |const nsTArray&amp;|; both fallible and infallible
<span class="lineNum">     826 </span>            : // TArrays can be cast to |const nsTArray&amp;|.
<span class="lineNum">     827 </span>            : //
<span class="lineNum">     828 </span>            : template&lt;class E, class Alloc&gt;
<span class="lineNum">     829 </span>            : class nsTArray_Impl
<span class="lineNum">     830 </span>            :   : public nsTArray_base&lt;Alloc, typename nsTArray_CopyChooser&lt;E&gt;::Type&gt;
<span class="lineNum">     831 </span>            :   , public nsTArray_TypedBase&lt;E, nsTArray_Impl&lt;E, Alloc&gt;&gt;
<span class="lineNum">     832 </span>            : {
<span class="lineNum">     833 </span>            : private:
<span class="lineNum">     834 </span>            :   typedef nsTArrayFallibleAllocator FallibleAlloc;
<span class="lineNum">     835 </span>            :   typedef nsTArrayInfallibleAllocator InfallibleAlloc;
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            : public:
<span class="lineNum">     838 </span>            :   typedef typename nsTArray_CopyChooser&lt;E&gt;::Type     copy_type;
<span class="lineNum">     839 </span>            :   typedef nsTArray_base&lt;Alloc, copy_type&gt;            base_type;
<span class="lineNum">     840 </span>            :   typedef typename base_type::size_type              size_type;
<span class="lineNum">     841 </span>            :   typedef typename base_type::index_type             index_type;
<span class="lineNum">     842 </span>            :   typedef E                                          elem_type;
<span class="lineNum">     843 </span>            :   typedef nsTArray_Impl&lt;E, Alloc&gt;                    self_type;
<span class="lineNum">     844 </span>            :   typedef nsTArrayElementTraits&lt;E&gt;                   elem_traits;
<span class="lineNum">     845 </span>            :   typedef nsTArray_SafeElementAtHelper&lt;E, self_type&gt; safeelementat_helper_type;
<span class="lineNum">     846 </span>            :   typedef mozilla::ArrayIterator&lt;elem_type&amp;, nsTArray&lt;E&gt;&gt;       iterator;
<span class="lineNum">     847 </span>            :   typedef mozilla::ArrayIterator&lt;const elem_type&amp;, nsTArray&lt;E&gt;&gt; const_iterator;
<span class="lineNum">     848 </span>            :   typedef mozilla::ReverseIterator&lt;iterator&gt;         reverse_iterator;
<span class="lineNum">     849 </span>            :   typedef mozilla::ReverseIterator&lt;const_iterator&gt;   const_reverse_iterator;
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :   using safeelementat_helper_type::SafeElementAt;
<span class="lineNum">     852 </span>            :   using base_type::EmptyHdr;
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :   // A special value that is used to indicate an invalid or unknown index
<span class="lineNum">     855 </span>            :   // into the array.
<span class="lineNum">     856 </span>            :   static const index_type NoIndex = index_type(-1);
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span>            :   using base_type::Length;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :   //
<span class="lineNum">     861 </span>            :   // Finalization method
<span class="lineNum">     862 </span>            :   //
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   ~nsTArray_Impl()</span>
<span class="lineNum">     865 </span>            :   {
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :     if (!base_type::IsEmpty()) {</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       ClearAndRetainStorage();</span>
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span>            :     // mHdr cleanup will be handled by base destructor
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :   //
<span class="lineNum">     873 </span>            :   // Initialization methods
<span class="lineNum">     874 </span>            :   //
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :   nsTArray_Impl() {}</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   // Initialize this array and pre-allocate some number of elements.
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   explicit nsTArray_Impl(size_type aCapacity) { SetCapacity(aCapacity); }</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :   // Initialize this array with an r-value.
<span class="lineNum">     882 </span>            :   // Allow different types of allocators, since the allocator doesn't matter.
<span class="lineNum">     883 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :   explicit nsTArray_Impl(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     SwapElements(aOther);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :   // The array's copy-constructor performs a 'deep' copy of the given array.
<span class="lineNum">     890 </span>            :   // @param aOther The array object to copy.
<span class="lineNum">     891 </span>            :   //
<span class="lineNum">     892 </span>            :   // It's very important that we declare this method as taking |const
<span class="lineNum">     893 </span>            :   // self_type&amp;| as opposed to taking |const nsTArray_Impl&lt;E, OtherAlloc&gt;| for
<span class="lineNum">     894 </span>            :   // an arbitrary OtherAlloc.
<span class="lineNum">     895 </span>            :   //
<span class="lineNum">     896 </span>            :   // If we don't declare a constructor taking |const self_type&amp;|, C++ generates
<span class="lineNum">     897 </span>            :   // a copy-constructor for this class which merely copies the object's
<span class="lineNum">     898 </span>            :   // members, which is obviously wrong.
<span class="lineNum">     899 </span>            :   //
<span class="lineNum">     900 </span>            :   // You can pass an nsTArray_Impl&lt;E, OtherAlloc&gt; to this method because
<span class="lineNum">     901 </span>            :   // nsTArray_Impl&lt;E, X&gt; can be cast to const nsTArray_Impl&lt;E, Y&gt;&amp;.  So the
<span class="lineNum">     902 </span>            :   // effect on the API is the same as if we'd declared this method as taking
<span class="lineNum">     903 </span>            :   // |const nsTArray_Impl&lt;E, OtherAlloc&gt;&amp;|.
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :   explicit nsTArray_Impl(const self_type&amp; aOther) { AppendElements(aOther); }</span>
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   explicit nsTArray_Impl(std::initializer_list&lt;E&gt; aIL) { AppendElements(aIL.begin(), aIL.size()); }</span>
<span class="lineNum">     907 </span>            :   // Allow converting to a const array with a different kind of allocator,
<span class="lineNum">     908 </span>            :   // Since the allocator doesn't matter for const arrays
<span class="lineNum">     909 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">     910 </span>            :   operator const nsTArray_Impl&lt;E, Allocator&gt;&amp;() const
<span class="lineNum">     911 </span>            :   {
<span class="lineNum">     912 </span>            :     return *reinterpret_cast&lt;const nsTArray_Impl&lt;E, Allocator&gt;*&gt;(this);
<span class="lineNum">     913 </span>            :   }
<span class="lineNum">     914 </span>            :   // And we have to do this for our subclasses too
<span class="lineNum">     915 </span>            :   operator const nsTArray&lt;E&gt;&amp;() const
<span class="lineNum">     916 </span>            :   {
<span class="lineNum">     917 </span>            :     return *reinterpret_cast&lt;const InfallibleTArray&lt;E&gt;*&gt;(this);
<span class="lineNum">     918 </span>            :   }
<span class="lineNum">     919 </span>            :   operator const FallibleTArray&lt;E&gt;&amp;() const
<span class="lineNum">     920 </span>            :   {
<span class="lineNum">     921 </span>            :     return *reinterpret_cast&lt;const FallibleTArray&lt;E&gt;*&gt;(this);
<span class="lineNum">     922 </span>            :   }
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :   // The array's assignment operator performs a 'deep' copy of the given
<span class="lineNum">     925 </span>            :   // array.  It is optimized to reuse existing storage if possible.
<span class="lineNum">     926 </span>            :   // @param aOther The array object to copy.
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   self_type&amp; operator=(const self_type&amp; aOther)</span>
<span class="lineNum">     928 </span>            :   {
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     if (this != &amp;aOther) {</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :       ReplaceElementsAt(0, Length(), aOther.Elements(), aOther.Length());</span>
<span class="lineNum">     931 </span>            :     }
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     933 </span>            :   }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :   // The array's move assignment operator steals the underlying data from
<span class="lineNum">     936 </span>            :   // the other array.
<span class="lineNum">     937 </span>            :   // @param other  The array object to move from.
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   self_type&amp; operator=(self_type&amp;&amp; aOther)</span>
<span class="lineNum">     939 </span>            :   {
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     if (this != &amp;aOther) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       Clear();</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :       SwapElements(aOther);</span>
<span class="lineNum">     943 </span>            :     }
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     945 </span>            :   }
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            :   // Return true if this array has the same length and the same
<span class="lineNum">     948 </span>            :   // elements as |aOther|.
<span class="lineNum">     949 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :   bool operator==(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther) const</span>
<span class="lineNum">     951 </span>            :   {
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :     size_type len = Length();</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     if (len != aOther.Length()) {</span>
<span class="lineNum">     954 </span>            :       return false;
<span class="lineNum">     955 </span>            :     }
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     // XXX std::equal would be as fast or faster here
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     for (index_type i = 0; i &lt; len; ++i) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :       if (!(operator[](i) == aOther[i])) {</span>
<span class="lineNum">     960 </span>            :         return false;
<span class="lineNum">     961 </span>            :       }
<span class="lineNum">     962 </span>            :     }
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :     return true;
<span class="lineNum">     965 </span>            :   }
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :   // Return true if this array does not have the same length and the same
<span class="lineNum">     968 </span>            :   // elements as |aOther|.
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :   bool operator!=(const self_type&amp; aOther) const { return !operator==(aOther); }</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   self_type&amp; operator=(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)</span>
<span class="lineNum">     973 </span>            :   {
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :     ReplaceElementsAt(0, Length(), aOther.Elements(), aOther.Length());</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :     return *this;</span>
<span class="lineNum">     976 </span>            :   }
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">     979 </span>            :   self_type&amp; operator=(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)
<span class="lineNum">     980 </span>            :   {
<span class="lineNum">     981 </span>            :     Clear();
<span class="lineNum">     982 </span>            :     SwapElements(aOther);
<span class="lineNum">     983 </span>            :     return *this;
<span class="lineNum">     984 </span>            :   }
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            :   // @return The amount of memory used by this nsTArray_Impl, excluding
<span class="lineNum">     987 </span>            :   // sizeof(*this). If you want to measure anything hanging off the array, you
<span class="lineNum">     988 </span>            :   // must iterate over the elements and measure them individually; hence the
<span class="lineNum">     989 </span>            :   // &quot;Shallow&quot; prefix.
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :   size_t ShallowSizeOfExcludingThis(mozilla::MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">     991 </span>            :   {
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :     if (this-&gt;UsesAutoArrayBuffer() || Hdr() == EmptyHdr()) {</span>
<span class="lineNum">     993 </span>            :       return 0;
<span class="lineNum">     994 </span>            :     }
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :     return aMallocSizeOf(this-&gt;Hdr());</span>
<span class="lineNum">     996 </span>            :   }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            :   // @return The amount of memory used by this nsTArray_Impl, including
<span class="lineNum">     999 </span>            :   // sizeof(*this). If you want to measure anything hanging off the array, you
<span class="lineNum">    1000 </span>            :   // must iterate over the elements and measure them individually; hence the
<span class="lineNum">    1001 </span>            :   // &quot;Shallow&quot; prefix.
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   size_t ShallowSizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf) const</span>
<span class="lineNum">    1003 </span>            :   {
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :     return aMallocSizeOf(this) + ShallowSizeOfExcludingThis(aMallocSizeOf);</span>
<span class="lineNum">    1005 </span>            :   }
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            :   //
<span class="lineNum">    1008 </span>            :   // Accessor methods
<span class="lineNum">    1009 </span>            :   //
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :   // This method provides direct access to the array elements.
<span class="lineNum">    1012 </span>            :   // @return A pointer to the first element of the array.  If the array is
<span class="lineNum">    1013 </span>            :   // empty, then this pointer must not be dereferenced.
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   elem_type* Elements() { return reinterpret_cast&lt;elem_type*&gt;(Hdr() + 1); }</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            :   // This method provides direct, readonly access to the array elements.
<span class="lineNum">    1017 </span>            :   // @return A pointer to the first element of the array.  If the array is
<span class="lineNum">    1018 </span>            :   // empty, then this pointer must not be dereferenced.
<span class="lineNum">    1019 </span>            :   const elem_type* Elements() const
<span class="lineNum">    1020 </span>            :   {
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;const elem_type*&gt;(Hdr() + 1);</span>
<span class="lineNum">    1022 </span>            :   }
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :   // This method provides direct access to an element of the array. The given
<span class="lineNum">    1025 </span>            :   // index must be within the array bounds.
<span class="lineNum">    1026 </span>            :   // @param aIndex The index of an element in the array.
<span class="lineNum">    1027 </span>            :   // @return A reference to the i'th element of the array.
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :   elem_type&amp; ElementAt(index_type aIndex)</span>
<span class="lineNum">    1029 </span>            :   {
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :     if (MOZ_UNLIKELY(aIndex &gt;= Length())) {</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :       InvalidArrayIndex_CRASH(aIndex, Length());</span>
<span class="lineNum">    1032 </span>            :     }
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :     return Elements()[aIndex];</span>
<span class="lineNum">    1034 </span>            :   }
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :   // This method provides direct, readonly access to an element of the array
<span class="lineNum">    1037 </span>            :   // The given index must be within the array bounds.
<span class="lineNum">    1038 </span>            :   // @param aIndex The index of an element in the array.
<span class="lineNum">    1039 </span>            :   // @return A const reference to the i'th element of the array.
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   const elem_type&amp; ElementAt(index_type aIndex) const</span>
<span class="lineNum">    1041 </span>            :   {
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :     if (MOZ_UNLIKELY(aIndex &gt;= Length())) {</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :       InvalidArrayIndex_CRASH(aIndex, Length());</span>
<span class="lineNum">    1044 </span>            :     }
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :     return Elements()[aIndex];</span>
<span class="lineNum">    1046 </span>            :   }
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            :   // This method provides direct access to an element of the array in a bounds
<span class="lineNum">    1049 </span>            :   // safe manner. If the requested index is out of bounds the provided default
<span class="lineNum">    1050 </span>            :   // value is returned.
<span class="lineNum">    1051 </span>            :   // @param aIndex The index of an element in the array.
<span class="lineNum">    1052 </span>            :   // @param aDef   The value to return if the index is out of bounds.
<span class="lineNum">    1053 </span>            :   elem_type&amp; SafeElementAt(index_type aIndex, elem_type&amp; aDef)
<span class="lineNum">    1054 </span>            :   {
<span class="lineNum">    1055 </span>            :     return aIndex &lt; Length() ? Elements()[aIndex] : aDef;
<span class="lineNum">    1056 </span>            :   }
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :   // This method provides direct access to an element of the array in a bounds
<span class="lineNum">    1059 </span>            :   // safe manner. If the requested index is out of bounds the provided default
<span class="lineNum">    1060 </span>            :   // value is returned.
<span class="lineNum">    1061 </span>            :   // @param aIndex The index of an element in the array.
<span class="lineNum">    1062 </span>            :   // @param aDef   The value to return if the index is out of bounds.
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   const elem_type&amp; SafeElementAt(index_type aIndex, const elem_type&amp; aDef) const</span>
<span class="lineNum">    1064 </span>            :   {
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     return aIndex &lt; Length() ? Elements()[aIndex] : aDef;</span>
<span class="lineNum">    1066 </span>            :   }
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :   // Shorthand for ElementAt(aIndex)
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :   elem_type&amp; operator[](index_type aIndex) { return ElementAt(aIndex); }</span>
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :   // Shorthand for ElementAt(aIndex)
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :   const elem_type&amp; operator[](index_type aIndex) const { return ElementAt(aIndex); }</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :   // Shorthand for ElementAt(length - 1)
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :   elem_type&amp; LastElement() { return ElementAt(Length() - 1); }</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            :   // Shorthand for ElementAt(length - 1)
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :   const elem_type&amp; LastElement() const { return ElementAt(Length() - 1); }</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            :   // Shorthand for SafeElementAt(length - 1, def)
<span class="lineNum">    1081 </span>            :   elem_type&amp; SafeLastElement(elem_type&amp; aDef)
<span class="lineNum">    1082 </span>            :   {
<span class="lineNum">    1083 </span>            :     return SafeElementAt(Length() - 1, aDef);
<span class="lineNum">    1084 </span>            :   }
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :   // Shorthand for SafeElementAt(length - 1, def)
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   const elem_type&amp; SafeLastElement(const elem_type&amp; aDef) const</span>
<span class="lineNum">    1088 </span>            :   {
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :     return SafeElementAt(Length() - 1, aDef);</span>
<span class="lineNum">    1090 </span>            :   }
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :   // Methods for range-based for loops.
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   iterator begin() { return iterator(*this, 0); }</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :   const_iterator begin() const { return const_iterator(*this, 0); }</span>
<span class="lineNum">    1095 </span>            :   const_iterator cbegin() const { return begin(); }
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   iterator end() { return iterator(*this, Length()); }</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :   const_iterator end() const { return const_iterator(*this, Length()); }</span>
<span class="lineNum">    1098 </span>            :   const_iterator cend() const { return end(); }
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            :   // Methods for reverse iterating.
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :   reverse_iterator rbegin() { return reverse_iterator(end()); }</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }</span>
<span class="lineNum">    1103 </span>            :   const_reverse_iterator crbegin() const { return rbegin(); }
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :   reverse_iterator rend() { return reverse_iterator(begin()); }</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }</span>
<span class="lineNum">    1106 </span>            :   const_reverse_iterator crend() const { return rend(); }
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            :   // Span integration
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :   operator mozilla::Span&lt;elem_type&gt;()</span>
<span class="lineNum">    1111 </span>            :   {
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     return mozilla::Span&lt;elem_type&gt;(Elements(), Length());</span>
<span class="lineNum">    1113 </span>            :   }
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :   operator mozilla::Span&lt;const elem_type&gt;() const</span>
<span class="lineNum">    1116 </span>            :   {
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     return mozilla::Span&lt;const elem_type&gt;(Elements(), Length());</span>
<span class="lineNum">    1118 </span>            :   }
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :   //
<span class="lineNum">    1121 </span>            :   // Search methods
<span class="lineNum">    1122 </span>            :   //
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span>            :   // This method searches for the first element in this array that is equal
<span class="lineNum">    1125 </span>            :   // to the given element.
<span class="lineNum">    1126 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1127 </span>            :   // @param aComp  The Comparator used to determine element equality.
<span class="lineNum">    1128 </span>            :   // @return       true if the element was found.
<span class="lineNum">    1129 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :   bool Contains(const Item&amp; aItem, const Comparator&amp; aComp) const</span>
<span class="lineNum">    1131 </span>            :   {
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :     return IndexOf(aItem, 0, aComp) != NoIndex;</span>
<span class="lineNum">    1133 </span>            :   }
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            :   // Like Contains(), but assumes a sorted array.
<span class="lineNum">    1136 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1137 </span>            :   bool ContainsSorted(const Item&amp; aItem, const Comparator&amp; aComp) const
<span class="lineNum">    1138 </span>            :   {
<span class="lineNum">    1139 </span>            :     return BinaryIndexOf(aItem, aComp) != NoIndex;
<span class="lineNum">    1140 </span>            :   }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :   // This method searches for the first element in this array that is equal
<span class="lineNum">    1143 </span>            :   // to the given element.  This method assumes that 'operator==' is defined
<span class="lineNum">    1144 </span>            :   // for elem_type.
<span class="lineNum">    1145 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1146 </span>            :   // @return       true if the element was found.
<span class="lineNum">    1147 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :   bool Contains(const Item&amp; aItem) const</span>
<span class="lineNum">    1149 </span>            :   {
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :     return IndexOf(aItem) != NoIndex;</span>
<span class="lineNum">    1151 </span>            :   }
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :   // Like Contains(), but assumes a sorted array.
<span class="lineNum">    1154 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   bool ContainsSorted(const Item&amp; aItem) const</span>
<span class="lineNum">    1156 </span>            :   {
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :     return BinaryIndexOf(aItem) != NoIndex;</span>
<span class="lineNum">    1158 </span>            :   }
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            :   // This method searches for the offset of the first element in this
<span class="lineNum">    1161 </span>            :   // array that is equal to the given element.
<span class="lineNum">    1162 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1163 </span>            :   // @param aStart The index to start from.
<span class="lineNum">    1164 </span>            :   // @param aComp  The Comparator used to determine element equality.
<a name="1165"><span class="lineNum">    1165 </span>            :   // @return       The index of the found element or NoIndex if not found.</a>
<span class="lineNum">    1166 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   index_type IndexOf(const Item&amp; aItem, index_type aStart,</span>
<span class="lineNum">    1168 </span>            :                      const Comparator&amp; aComp) const
<span class="lineNum">    1169 </span>            :   {
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     const elem_type* iter = Elements() + aStart;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     const elem_type* iend = Elements() + Length();</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :     for (; iter != iend; ++iter) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :       if (aComp.Equals(*iter, aItem)) {</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         return index_type(iter - Elements());</span>
<span class="lineNum">    1175 </span>            :       }
<span class="lineNum">    1176 </span>            :     }
<span class="lineNum">    1177 </span>            :     return NoIndex;
<span class="lineNum">    1178 </span>            :   }
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :   // This method searches for the offset of the first element in this
<span class="lineNum">    1181 </span>            :   // array that is equal to the given element.  This method assumes
<span class="lineNum">    1182 </span>            :   // that 'operator==' is defined for elem_type.
<span class="lineNum">    1183 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1184 </span>            :   // @param aStart The index to start from.
<span class="lineNum">    1185 </span>            :   // @return       The index of the found element or NoIndex if not found.
<span class="lineNum">    1186 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1187 </span>            :   index_type IndexOf(const Item&amp; aItem, index_type aStart = 0) const
<span class="lineNum">    1188 </span>            :   {
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :     return IndexOf(aItem, aStart, nsDefaultComparator&lt;elem_type, Item&gt;());</span>
<span class="lineNum">    1190 </span>            :   }
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            :   // This method searches for the offset of the last element in this
<span class="lineNum">    1193 </span>            :   // array that is equal to the given element.
<span class="lineNum">    1194 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1195 </span>            :   // @param aStart The index to start from.  If greater than or equal to the
<span class="lineNum">    1196 </span>            :   //               length of the array, then the entire array is searched.
<span class="lineNum">    1197 </span>            :   // @param aComp  The Comparator used to determine element equality.
<span class="lineNum">    1198 </span>            :   // @return       The index of the found element or NoIndex if not found.
<span class="lineNum">    1199 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :   index_type LastIndexOf(const Item&amp; aItem, index_type aStart,</span>
<span class="lineNum">    1201 </span>            :                          const Comparator&amp; aComp) const
<span class="lineNum">    1202 </span>            :   {
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :     size_type endOffset = aStart &gt;= Length() ? Length() : aStart + 1;</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :     const elem_type* iend = Elements() - 1;</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :     const elem_type* iter = iend + endOffset;</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     for (; iter != iend; --iter) {</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :       if (aComp.Equals(*iter, aItem)) {</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :         return index_type(iter - Elements());</span>
<span class="lineNum">    1209 </span>            :       }
<span class="lineNum">    1210 </span>            :     }
<span class="lineNum">    1211 </span>            :     return NoIndex;
<span class="lineNum">    1212 </span>            :   }
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            :   // This method searches for the offset of the last element in this
<span class="lineNum">    1215 </span>            :   // array that is equal to the given element.  This method assumes
<span class="lineNum">    1216 </span>            :   // that 'operator==' is defined for elem_type.
<span class="lineNum">    1217 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1218 </span>            :   // @param aStart The index to start from.  If greater than or equal to the
<span class="lineNum">    1219 </span>            :   //               length of the array, then the entire array is searched.
<span class="lineNum">    1220 </span>            :   // @return       The index of the found element or NoIndex if not found.
<span class="lineNum">    1221 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1222 </span>            :   index_type LastIndexOf(const Item&amp; aItem,
<span class="lineNum">    1223 </span>            :                          index_type aStart = NoIndex) const
<span class="lineNum">    1224 </span>            :   {
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     return LastIndexOf(aItem, aStart, nsDefaultComparator&lt;elem_type, Item&gt;());</span>
<span class="lineNum">    1226 </span>            :   }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            :   // This method searches for the offset for the element in this array
<span class="lineNum">    1229 </span>            :   // that is equal to the given element. The array is assumed to be sorted.
<span class="lineNum">    1230 </span>            :   // If there is more than one equivalent element, there is no guarantee
<span class="lineNum">    1231 </span>            :   // on which one will be returned.
<span class="lineNum">    1232 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1233 </span>            :   // @param aComp  The Comparator used.
<span class="lineNum">    1234 </span>            :   // @return       The index of the found element or NoIndex if not found.
<span class="lineNum">    1235 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   index_type BinaryIndexOf(const Item&amp; aItem, const Comparator&amp; aComp) const</span>
<span class="lineNum">    1237 </span>            :   {
<span class="lineNum">    1238 </span>            :     using mozilla::BinarySearchIf;
<span class="lineNum">    1239 </span>            :     typedef ::detail::ItemComparatorEq&lt;Item, Comparator&gt; Cmp;
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :     size_t index;
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     bool found = BinarySearchIf(*this, 0, Length(), Cmp(aItem, aComp), &amp;index);</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :     return found ? index : NoIndex;</span>
<span class="lineNum">    1244 </span>            :   }
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :   // This method searches for the offset for the element in this array
<span class="lineNum">    1247 </span>            :   // that is equal to the given element. The array is assumed to be sorted.
<span class="lineNum">    1248 </span>            :   // This method assumes that 'operator==' and 'operator&lt;' are defined.
<span class="lineNum">    1249 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1250 </span>            :   // @return       The index of the found element or NoIndex if not found.
<span class="lineNum">    1251 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   index_type BinaryIndexOf(const Item&amp; aItem) const</span>
<span class="lineNum">    1253 </span>            :   {
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :     return BinaryIndexOf(aItem, nsDefaultComparator&lt;elem_type, Item&gt;());</span>
<span class="lineNum">    1255 </span>            :   }
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            :   //
<span class="lineNum">    1258 </span>            :   // Mutation methods
<span class="lineNum">    1259 </span>            :   //
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :   template&lt;class Allocator, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :   typename ActualAlloc::ResultType Assign(</span>
<span class="lineNum">    1263 </span>            :       const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)
<span class="lineNum">    1264 </span>            :   {
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :     return ActualAlloc::ConvertBoolToResultType(</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :       !!ReplaceElementsAt&lt;E, ActualAlloc&gt;(0, Length(),</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :                                           aOther.Elements(), aOther.Length()));</span>
<span class="lineNum">    1268 </span>            :   }
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    1271 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1272 </span>            :   bool Assign(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther,
<span class="lineNum">    1273 </span>            :               const mozilla::fallible_t&amp;)
<span class="lineNum">    1274 </span>            :   {
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     return Assign&lt;Allocator, FallibleAlloc&gt;(aOther);</span>
<span class="lineNum">    1276 </span>            :   }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    1279 </span>            :   void Assign(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)
<span class="lineNum">    1280 </span>            :   {
<span class="lineNum">    1281 </span>            :     Clear();
<span class="lineNum">    1282 </span>            :     SwapElements(aOther);
<span class="lineNum">    1283 </span>            :   }
<span class="lineNum">    1284 </span>            : 
<span class="lineNum">    1285 </span>            :   // This method call the destructor on each element of the array, empties it,
<span class="lineNum">    1286 </span>            :   // but does not shrink the array's capacity.
<span class="lineNum">    1287 </span>            :   // See also SetLengthAndRetainStorage.
<span class="lineNum">    1288 </span>            :   // Make sure to call Compact() if needed to avoid keeping a huge array
<span class="lineNum">    1289 </span>            :   // around.
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   void ClearAndRetainStorage()</span>
<span class="lineNum">    1291 </span>            :   {
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :     if (base_type::mHdr == EmptyHdr()) {</span>
<span class="lineNum">    1293 </span>            :       return;
<span class="lineNum">    1294 </span>            :     }
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :     DestructRange(0, Length());</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :     base_type::mHdr-&gt;mLength = 0;</span>
<span class="lineNum">    1298 </span>            :   }
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            :   // This method modifies the length of the array, but unlike SetLength
<span class="lineNum">    1301 </span>            :   // it doesn't deallocate/reallocate the current internal storage.
<span class="lineNum">    1302 </span>            :   // The new length MUST be shorter than or equal to the current capacity.
<span class="lineNum">    1303 </span>            :   // If the new length is larger than the existing length of the array,
<span class="lineNum">    1304 </span>            :   // then new elements will be constructed using elem_type's default
<span class="lineNum">    1305 </span>            :   // constructor.  If shorter, elements will be destructed and removed.
<span class="lineNum">    1306 </span>            :   // See also ClearAndRetainStorage.
<span class="lineNum">    1307 </span>            :   // @param aNewLen  The desired length of this array.
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :   void SetLengthAndRetainStorage(size_type aNewLen)</span>
<span class="lineNum">    1309 </span>            :   {
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aNewLen &lt;= base_type::Capacity());</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :     size_type oldLen = Length();</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     if (aNewLen &gt; oldLen) {</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       InsertElementsAt(oldLen, aNewLen - oldLen);</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1315 </span>            :     }
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :     if (aNewLen &lt; oldLen) {</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :       DestructRange(aNewLen, oldLen - aNewLen);</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :       base_type::mHdr-&gt;mLength = aNewLen;</span>
<span class="lineNum">    1319 </span>            :     }
<span class="lineNum">    1320 </span>            :   }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :   // This method replaces a range of elements in this array.
<span class="lineNum">    1323 </span>            :   // @param aStart    The starting index of the elements to replace.
<span class="lineNum">    1324 </span>            :   // @param aCount    The number of elements to replace.  This may be zero to
<span class="lineNum">    1325 </span>            :   //                  insert elements without removing any existing elements.
<span class="lineNum">    1326 </span>            :   // @param aArray    The values to copy into this array.  Must be non-null,
<span class="lineNum">    1327 </span>            :   //                  and these elements must not already exist in the array
<span class="lineNum">    1328 </span>            :   //                  being modified.
<span class="lineNum">    1329 </span>            :   // @param aArrayLen The number of values to copy into this array.
<span class="lineNum">    1330 </span>            :   // @return          A pointer to the new elements in the array, or null if
<span class="lineNum">    1331 </span>            :   //                  the operation failed due to insufficient memory.
<span class="lineNum">    1332 </span>            : protected:
<span class="lineNum">    1333 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1334 </span>            :   elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
<span class="lineNum">    1335 </span>            :                                const Item* aArray, size_type aArrayLen);
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span>            : public:
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1340 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1341 </span>            :   elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
<span class="lineNum">    1342 </span>            :                                const Item* aArray, size_type aArrayLen,
<span class="lineNum">    1343 </span>            :                                const mozilla::fallible_t&amp;)
<span class="lineNum">    1344 </span>            :   {
<span class="lineNum">    1345 </span>            :     return ReplaceElementsAt&lt;Item, FallibleAlloc&gt;(aStart, aCount,
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :                                                   aArray, aArrayLen);</span>
<span class="lineNum">    1347 </span>            :   }
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :   // A variation on the ReplaceElementsAt method defined above.
<span class="lineNum">    1350 </span>            : protected:
<span class="lineNum">    1351 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,</span>
<span class="lineNum">    1353 </span>            :                                const nsTArray&lt;Item&gt;&amp; aArray)
<span class="lineNum">    1354 </span>            :   {
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :     return ReplaceElementsAt&lt;Item, ActualAlloc&gt;(</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :       aStart, aCount, aArray.Elements(), aArray.Length());</span>
<span class="lineNum">    1357 </span>            :   }
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1360 </span>            :   elem_type* ReplaceElementsAt(index_type aStart,
<span class="lineNum">    1361 </span>            :                                size_type aCount,
<span class="lineNum">    1362 </span>            :                                mozilla::Span&lt;const Item&gt; aSpan)
<span class="lineNum">    1363 </span>            :   {
<span class="lineNum">    1364 </span>            :     return ReplaceElementsAt&lt;Item, ActualAlloc&gt;(
<span class="lineNum">    1365 </span>            :       aStart, aCount, aSpan.Elements(), aSpan.Length());
<span class="lineNum">    1366 </span>            :   }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            : public:
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1371 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1372 </span>            :   elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
<span class="lineNum">    1373 </span>            :                                const nsTArray&lt;Item&gt;&amp; aArray,
<span class="lineNum">    1374 </span>            :                                const mozilla::fallible_t&amp;)
<span class="lineNum">    1375 </span>            :   {
<span class="lineNum">    1376 </span>            :     return ReplaceElementsAt&lt;Item, FallibleAlloc&gt;(aStart, aCount, aArray);
<span class="lineNum">    1377 </span>            :   }
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1380 </span>            :   MOZ_MUST_USE elem_type* ReplaceElementsAt(index_type aStart,
<span class="lineNum">    1381 </span>            :                                             size_type aCount,
<span class="lineNum">    1382 </span>            :                                             mozilla::Span&lt;const Item&gt; aSpan,
<span class="lineNum">    1383 </span>            :                                             const mozilla::fallible_t&amp;)
<span class="lineNum">    1384 </span>            :   {
<span class="lineNum">    1385 </span>            :     return ReplaceElementsAt&lt;Item, FallibleAlloc&gt;(aStart, aCount, aSpan);
<span class="lineNum">    1386 </span>            :   }
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            :   // A variation on the ReplaceElementsAt method defined above.
<span class="lineNum">    1389 </span>            : protected:
<span class="lineNum">    1390 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :   elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,</span>
<span class="lineNum">    1392 </span>            :                                const Item&amp; aItem)
<span class="lineNum">    1393 </span>            :   {
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :     return ReplaceElementsAt&lt;Item, ActualAlloc&gt;(aStart, aCount, &amp;aItem, 1);</span>
<span class="lineNum">    1395 </span>            :   }
<span class="lineNum">    1396 </span>            : public:
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1399 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1400 </span>            :   elem_type* ReplaceElementsAt(index_type aStart, size_type aCount,
<span class="lineNum">    1401 </span>            :                                const Item&amp; aItem, const mozilla::fallible_t&amp;)
<span class="lineNum">    1402 </span>            :   {
<span class="lineNum">    1403 </span>            :     return ReplaceElementsAt&lt;Item, FallibleAlloc&gt;(aStart, aCount, aItem);
<span class="lineNum">    1404 </span>            :   }
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :   // A variation on the ReplaceElementsAt method defined above.
<span class="lineNum">    1407 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   elem_type* ReplaceElementAt(index_type aIndex, const Item&amp; aItem)</span>
<span class="lineNum">    1409 </span>            :   {
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :     return ReplaceElementsAt(aIndex, 1, &amp;aItem, 1);</span>
<span class="lineNum">    1411 </span>            :   }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span>            :   // A variation on the ReplaceElementsAt method defined above.
<span class="lineNum">    1414 </span>            : protected:
<span class="lineNum">    1415 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   elem_type* InsertElementsAt(index_type aIndex, const Item* aArray,</span>
<span class="lineNum">    1417 </span>            :                               size_type aArrayLen)
<span class="lineNum">    1418 </span>            :   {
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :     return ReplaceElementsAt&lt;Item, ActualAlloc&gt;(aIndex, 0, aArray, aArrayLen);</span>
<span class="lineNum">    1420 </span>            :   }
<span class="lineNum">    1421 </span>            : public:
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1424 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1425 </span>            :   elem_type* InsertElementsAt(index_type aIndex, const Item* aArray,
<span class="lineNum">    1426 </span>            :                               size_type aArrayLen, const mozilla::fallible_t&amp;)
<span class="lineNum">    1427 </span>            :   {
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :     return InsertElementsAt&lt;Item, FallibleAlloc&gt;(aIndex, aArray, aArrayLen);</span>
<span class="lineNum">    1429 </span>            :   }
<span class="lineNum">    1430 </span>            : 
<span class="lineNum">    1431 </span>            :   // A variation on the ReplaceElementsAt method defined above.
<span class="lineNum">    1432 </span>            : protected:
<span class="lineNum">    1433 </span>            :   template&lt;class Item, class Allocator, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   elem_type* InsertElementsAt(index_type aIndex,</span>
<span class="lineNum">    1435 </span>            :                               const nsTArray_Impl&lt;Item, Allocator&gt;&amp; aArray)
<span class="lineNum">    1436 </span>            :   {
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :     return ReplaceElementsAt&lt;Item, ActualAlloc&gt;(</span>
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :       aIndex, 0, aArray.Elements(), aArray.Length());</span>
<span class="lineNum">    1439 </span>            :   }
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1442 </span>            :   elem_type* InsertElementsAt(index_type aIndex,
<span class="lineNum">    1443 </span>            :                               mozilla::Span&lt;const Item&gt; aSpan)
<span class="lineNum">    1444 </span>            :   {
<span class="lineNum">    1445 </span>            :     return ReplaceElementsAt&lt;Item, ActualAlloc&gt;(
<span class="lineNum">    1446 </span>            :       aIndex, 0, aSpan.Elements(), aSpan.Length());
<span class="lineNum">    1447 </span>            :   }
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            : public:
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            :   template&lt;class Item, class Allocator&gt;
<span class="lineNum">    1452 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1453 </span>            :   elem_type* InsertElementsAt(index_type aIndex,
<span class="lineNum">    1454 </span>            :                               const nsTArray_Impl&lt;Item, Allocator&gt;&amp; aArray,
<span class="lineNum">    1455 </span>            :                               const mozilla::fallible_t&amp;)
<span class="lineNum">    1456 </span>            :   {
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :     return InsertElementsAt&lt;Item, Allocator, FallibleAlloc&gt;(aIndex, aArray);</span>
<span class="lineNum">    1458 </span>            :   }
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1461 </span>            :   MOZ_MUST_USE elem_type* InsertElementsAt(index_type aIndex,
<span class="lineNum">    1462 </span>            :                                            mozilla::Span&lt;const Item&gt; aSpan,
<span class="lineNum">    1463 </span>            :                                            const mozilla::fallible_t&amp;)
<span class="lineNum">    1464 </span>            :   {
<span class="lineNum">    1465 </span>            :     return InsertElementsAt&lt;Item, FallibleAlloc&gt;(aIndex, aSpan);
<span class="lineNum">    1466 </span>            :   }
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span>            :   // Insert a new element without copy-constructing. This is useful to avoid
<span class="lineNum">    1469 </span>            :   // temporaries.
<span class="lineNum">    1470 </span>            :   // @return A pointer to the newly inserted element, or null on OOM.
<span class="lineNum">    1471 </span>            : protected:
<span class="lineNum">    1472 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1473 </span>            :   elem_type* InsertElementAt(index_type aIndex);
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            : public:
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1478 </span>            :   elem_type* InsertElementAt(index_type aIndex, const mozilla::fallible_t&amp;)
<span class="lineNum">    1479 </span>            :   {
<span class="lineNum">    1480 </span>            :     return InsertElementAt&lt;FallibleAlloc&gt;(aIndex);
<span class="lineNum">    1481 </span>            :   }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span>            :   // Insert a new element, move constructing if possible.
<span class="lineNum">    1484 </span>            : protected:
<span class="lineNum">    1485 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1486 </span>            :   elem_type* InsertElementAt(index_type aIndex, Item&amp;&amp; aItem);
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            : public:
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1491 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1492 </span>            :   elem_type* InsertElementAt(index_type aIndex, Item&amp;&amp; aItem,
<span class="lineNum">    1493 </span>            :                              const mozilla::fallible_t&amp;)
<span class="lineNum">    1494 </span>            :   {
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :     return InsertElementAt&lt;Item, FallibleAlloc&gt;(aIndex,</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :                                                 std::forward&lt;Item&gt;(aItem));</span>
<span class="lineNum">    1497 </span>            :   }
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            :   // Reconstruct the element at the given index, and return a pointer to the
<span class="lineNum">    1500 </span>            :   // reconstructed element.  This will destroy the existing element and
<span class="lineNum">    1501 </span>            :   // default-construct a new one, giving you a state much like what single-arg
<span class="lineNum">    1502 </span>            :   // InsertElementAt(), or no-arg AppendElement() does, but without changing the
<span class="lineNum">    1503 </span>            :   // length of the array.
<span class="lineNum">    1504 </span>            :   //
<span class="lineNum">    1505 </span>            :   // array[idx] = T()
<span class="lineNum">    1506 </span>            :   //
<span class="lineNum">    1507 </span>            :   // would accomplish the same thing as long as T has the appropriate moving
<span class="lineNum">    1508 </span>            :   // operator=, but some types don't for various reasons.
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   elem_type* ReconstructElementAt(index_type aIndex)</span>
<span class="lineNum">    1510 </span>            :   {
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :     elem_type* elem = &amp;ElementAt(aIndex);</span>
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :     elem_traits::Destruct(elem);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :     elem_traits::Construct(elem);</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :     return elem;</span>
<span class="lineNum">    1515 </span>            :   }
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            :   // This method searches for the smallest index of an element that is strictly
<span class="lineNum">    1518 </span>            :   // greater than |aItem|. If |aItem| is inserted at this index, the array will
<span class="lineNum">    1519 </span>            :   // remain sorted and |aItem| would come after all elements that are equal to
<span class="lineNum">    1520 </span>            :   // it. If |aItem| is greater than or equal to all elements in the array, the
<span class="lineNum">    1521 </span>            :   // array length is returned.
<span class="lineNum">    1522 </span>            :   //
<span class="lineNum">    1523 </span>            :   // Note that consumers who want to know whether there are existing items equal
<span class="lineNum">    1524 </span>            :   // to |aItem| in the array can just check that the return value here is &gt; 0
<span class="lineNum">    1525 </span>            :   // and indexing into the previous slot gives something equal to |aItem|.
<span class="lineNum">    1526 </span>            :   //
<span class="lineNum">    1527 </span>            :   //
<span class="lineNum">    1528 </span>            :   // @param aItem  The item to search for.
<span class="lineNum">    1529 </span>            :   // @param aComp  The Comparator used.
<span class="lineNum">    1530 </span>            :   // @return        The index of greatest element &lt;= to |aItem|
<span class="lineNum">    1531 </span>            :   // @precondition The array is sorted
<span class="lineNum">    1532 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   index_type IndexOfFirstElementGt(const Item&amp; aItem,</span>
<span class="lineNum">    1534 </span>            :                                    const Comparator&amp; aComp) const
<span class="lineNum">    1535 </span>            :   {
<span class="lineNum">    1536 </span>            :     using mozilla::BinarySearchIf;
<span class="lineNum">    1537 </span>            :     typedef ::detail::ItemComparatorFirstElementGT&lt;Item, Comparator&gt; Cmp;
<span class="lineNum">    1538 </span>            : 
<span class="lineNum">    1539 </span>            :     size_t index;
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :     BinarySearchIf(*this, 0, Length(), Cmp(aItem, aComp), &amp;index);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     return index;</span>
<span class="lineNum">    1542 </span>            :   }
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span>            :   // A variation on the IndexOfFirstElementGt method defined above.
<span class="lineNum">    1545 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1546 </span>            :   index_type
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :   IndexOfFirstElementGt(const Item&amp; aItem) const</span>
<span class="lineNum">    1548 </span>            :   {
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :     return IndexOfFirstElementGt(aItem, nsDefaultComparator&lt;elem_type, Item&gt;());</span>
<span class="lineNum">    1550 </span>            :   }
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            :   // Inserts |aItem| at such an index to guarantee that if the array
<span class="lineNum">    1553 </span>            :   // was previously sorted, it will remain sorted after this
<span class="lineNum">    1554 </span>            :   // insertion.
<span class="lineNum">    1555 </span>            : protected:
<span class="lineNum">    1556 </span>            :   template&lt;class Item, class Comparator, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   elem_type* InsertElementSorted(Item&amp;&amp; aItem, const Comparator&amp; aComp)</span>
<span class="lineNum">    1558 </span>            :   {
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     index_type index = IndexOfFirstElementGt&lt;Item, Comparator&gt;(aItem, aComp);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :     return InsertElementAt&lt;Item, ActualAlloc&gt;(</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :       index, std::forward&lt;Item&gt;(aItem));</span>
<span class="lineNum">    1562 </span>            :   }
<span class="lineNum">    1563 </span>            : public:
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1566 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1567 </span>            :   elem_type* InsertElementSorted(Item&amp;&amp; aItem, const Comparator&amp; aComp,
<span class="lineNum">    1568 </span>            :                                  const mozilla::fallible_t&amp;)
<span class="lineNum">    1569 </span>            :   {
<span class="lineNum">    1570 </span>            :     return InsertElementSorted&lt;Item, Comparator, FallibleAlloc&gt;(
<span class="lineNum">    1571 </span>            :       std::forward&lt;Item&gt;(aItem), aComp);
<span class="lineNum">    1572 </span>            :   }
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span>            :   // A variation on the InsertElementSorted method defined above.
<span class="lineNum">    1575 </span>            : protected:
<span class="lineNum">    1576 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :   elem_type* InsertElementSorted(Item&amp;&amp; aItem)</span>
<span class="lineNum">    1578 </span>            :   {
<span class="lineNum">    1579 </span>            :     nsDefaultComparator&lt;elem_type, Item&gt; comp;
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :     return InsertElementSorted&lt;Item, decltype(comp), ActualAlloc&gt;(</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :       std::forward&lt;Item&gt;(aItem), comp);</span>
<span class="lineNum">    1582 </span>            :   }
<span class="lineNum">    1583 </span>            : public:
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1586 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1587 </span>            :   elem_type* InsertElementSorted(Item&amp;&amp; aItem, const mozilla::fallible_t&amp;)
<span class="lineNum">    1588 </span>            :   {
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :     return InsertElementSorted&lt;Item, FallibleAlloc&gt;(</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :       std::forward&lt;Item&gt;(aItem));</span>
<span class="lineNum">    1591 </span>            :   }
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            :   // This method appends elements to the end of this array.
<span class="lineNum">    1594 </span>            :   // @param aArray    The elements to append to this array.
<span class="lineNum">    1595 </span>            :   // @param aArrayLen The number of elements to append to this array.
<span class="lineNum">    1596 </span>            :   // @return          A pointer to the new elements in the array, or null if
<span class="lineNum">    1597 </span>            :   //                  the operation failed due to insufficient memory.
<span class="lineNum">    1598 </span>            : protected:
<span class="lineNum">    1599 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1600 </span>            :   elem_type* AppendElements(const Item* aArray, size_type aArrayLen);
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   elem_type* AppendElements(mozilla::Span&lt;const Item&gt; aSpan)</span>
<span class="lineNum">    1604 </span>            :   {
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :     return AppendElements&lt;Item, FallibleAlloc&gt;(aSpan.Elements(),</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :                                                aSpan.Length());</span>
<span class="lineNum">    1607 </span>            :   }
<span class="lineNum">    1608 </span>            : 
<span class="lineNum">    1609 </span>            :   template&lt;class Item, size_t Length, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1610 </span>            :   elem_type* AppendElements(const mozilla::Array&lt;Item, Length&gt;&amp; aArray)
<span class="lineNum">    1611 </span>            :   {
<span class="lineNum">    1612 </span>            :     return AppendElements&lt;Item, ActualAlloc&gt;(&amp;aArray[0], Length);
<span class="lineNum">    1613 </span>            :   }
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            : public:
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1618 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :   elem_type* AppendElements(const Item* aArray, size_type aArrayLen,</span>
<span class="lineNum">    1620 </span>            :                             const mozilla::fallible_t&amp;)
<span class="lineNum">    1621 </span>            :   {
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :     return AppendElements&lt;Item, FallibleAlloc&gt;(aArray, aArrayLen);</span>
<span class="lineNum">    1623 </span>            :   }
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1626 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1627 </span>            :   elem_type* AppendElements(mozilla::Span&lt;const Item&gt; aSpan,
<span class="lineNum">    1628 </span>            :                             const mozilla::fallible_t&amp;)
<span class="lineNum">    1629 </span>            :   {
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :     return AppendElements&lt;Item, FallibleAlloc&gt;(aSpan.Elements(),</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :                                                aSpan.Length());</span>
<span class="lineNum">    1632 </span>            :   }
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            :   // A variation on the AppendElements method defined above.
<span class="lineNum">    1635 </span>            : protected:
<span class="lineNum">    1636 </span>            :   template&lt;class Item, class Allocator, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :   elem_type* AppendElements(const nsTArray_Impl&lt;Item, Allocator&gt;&amp; aArray)</span>
<span class="lineNum">    1638 </span>            :   {
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :     return AppendElements&lt;Item, ActualAlloc&gt;(aArray.Elements(), aArray.Length());</span>
<span class="lineNum">    1640 </span>            :   }
<span class="lineNum">    1641 </span>            : public:
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            :   template&lt;class Item, class Allocator&gt;
<span class="lineNum">    1644 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   elem_type* AppendElements(const nsTArray_Impl&lt;Item, Allocator&gt;&amp; aArray,</span>
<span class="lineNum">    1646 </span>            :                             const mozilla::fallible_t&amp;)
<span class="lineNum">    1647 </span>            :   {
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :     return AppendElements&lt;Item, Allocator, FallibleAlloc&gt;(aArray);</span>
<span class="lineNum">    1649 </span>            :   }
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            :   // Move all elements from another array to the end of this array.
<span class="lineNum">    1652 </span>            :   // @return A pointer to the newly appended elements, or null on OOM.
<span class="lineNum">    1653 </span>            : protected:
<span class="lineNum">    1654 </span>            :   template&lt;class Item, class Allocator, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1655 </span>            :   elem_type* AppendElements(nsTArray_Impl&lt;Item, Allocator&gt;&amp;&amp; aArray);
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            : public:
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :   template&lt;class Item, class Allocator, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1660 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1661 </span>            :   elem_type* AppendElements(nsTArray_Impl&lt;Item, Allocator&gt;&amp;&amp; aArray,
<span class="lineNum">    1662 </span>            :                             const mozilla::fallible_t&amp;)
<span class="lineNum">    1663 </span>            :   {
<span class="lineNum">    1664 </span>            :     return AppendElements&lt;Item, Allocator&gt;(std::move(aArray));
<span class="lineNum">    1665 </span>            :   }
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :   // Append a new element, move constructing if possible.
<span class="lineNum">    1668 </span>            : protected:
<span class="lineNum">    1669 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1670 </span>            :   elem_type* AppendElement(Item&amp;&amp; aItem);
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            : public:
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1675 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :   elem_type* AppendElement(Item&amp;&amp; aItem,</span>
<span class="lineNum">    1677 </span>            :                            const mozilla::fallible_t&amp;)
<span class="lineNum">    1678 </span>            :   {
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     return AppendElement&lt;Item, FallibleAlloc&gt;(std::forward&lt;Item&gt;(aItem));</span>
<span class="lineNum">    1680 </span>            :   }
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :   // Append new elements without copy-constructing. This is useful to avoid
<span class="lineNum">    1683 </span>            :   // temporaries.
<span class="lineNum">    1684 </span>            :   // @return A pointer to the newly appended elements, or null on OOM.
<span class="lineNum">    1685 </span>            : protected:
<span class="lineNum">    1686 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :   elem_type* AppendElements(size_type aCount) {</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     if (!ActualAlloc::Successful(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :           Length() + aCount, sizeof(elem_type)))) {</span>
<span class="lineNum">    1690 </span>            :       return nullptr;
<span class="lineNum">    1691 </span>            :     }
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :     elem_type* elems = Elements() + Length();</span>
<span class="lineNum">    1693 </span>            :     size_type i;
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; aCount; ++i) {</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :       elem_traits::Construct(elems + i);</span>
<span class="lineNum">    1696 </span>            :     }
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :     this-&gt;IncrementLength(aCount);</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :     return elems;</span>
<span class="lineNum">    1699 </span>            :   }
<span class="lineNum">    1700 </span>            : public:
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1703 </span>            :   elem_type* AppendElements(size_type aCount,
<span class="lineNum">    1704 </span>            :                             const mozilla::fallible_t&amp;)
<span class="lineNum">    1705 </span>            :   {
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :     return AppendElements&lt;FallibleAlloc&gt;(aCount);</span>
<span class="lineNum">    1707 </span>            :   }
<span class="lineNum">    1708 </span>            : 
<span class="lineNum">    1709 </span>            :   // Append a new element without copy-constructing. This is useful to avoid
<span class="lineNum">    1710 </span>            :   // temporaries.
<span class="lineNum">    1711 </span>            :   // @return A pointer to the newly appended element, or null on OOM.
<span class="lineNum">    1712 </span>            : protected:
<span class="lineNum">    1713 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :   elem_type* AppendElement()</span>
<span class="lineNum">    1715 </span>            :   {
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :     return AppendElements&lt;ActualAlloc&gt;(1);</span>
<span class="lineNum">    1717 </span>            :   }
<span class="lineNum">    1718 </span>            : public:
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :   /* MOZ_MUST_USE */
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 :   elem_type* AppendElement(const mozilla::fallible_t&amp;)</span>
<span class="lineNum">    1722 </span>            :   {
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :     return AppendElement&lt;FallibleAlloc&gt;();</span>
<span class="lineNum">    1724 </span>            :   }
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :   // This method removes a range of elements from this array.
<span class="lineNum">    1727 </span>            :   // @param aStart The starting index of the elements to remove.
<span class="lineNum">    1728 </span>            :   // @param aCount The number of elements to remove.
<span class="lineNum">    1729 </span>            :   void RemoveElementsAt(index_type aStart, size_type aCount);
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :   // A variation on the RemoveElementsAt method defined above.
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :   void RemoveElementAt(index_type aIndex) { RemoveElementsAt(aIndex, 1); }</span>
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :   // A variation on the RemoveElementAt that removes the last element.
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :   void RemoveLastElement() { RemoveElementAt(Length() - 1); }</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            :   // Removes the last element of the array and returns a copy of it.
<span class="lineNum">    1738 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :   elem_type PopLastElement()</span>
<span class="lineNum">    1740 </span>            :   {
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :     elem_type elem = std::move(LastElement());</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     RemoveLastElement();</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     return elem;</span>
<span class="lineNum">    1744 </span>            :   }
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :   // This method performs index-based removals from an array without preserving
<span class="lineNum">    1747 </span>            :   // the order of the array. This is useful if you are using the array as a
<span class="lineNum">    1748 </span>            :   // set-like data structure.
<span class="lineNum">    1749 </span>            :   //
<span class="lineNum">    1750 </span>            :   // These removals are efficient, as they move as few elements as possible. At
<span class="lineNum">    1751 </span>            :   // most N elements, where N is the number of removed elements, will have to
<span class="lineNum">    1752 </span>            :   // be relocated.
<span class="lineNum">    1753 </span>            :   //
<span class="lineNum">    1754 </span>            :   // ## Examples
<span class="lineNum">    1755 </span>            :   //
<span class="lineNum">    1756 </span>            :   // When removing an element from the end of the array, it can be removed in
<span class="lineNum">    1757 </span>            :   // place, by destroying it and decrementing the length.
<span class="lineNum">    1758 </span>            :   //
<span class="lineNum">    1759 </span>            :   // [ 1, 2, 3 ] =&gt; [ 1, 2 ]
<span class="lineNum">    1760 </span>            :   //         ^
<span class="lineNum">    1761 </span>            :   //
<span class="lineNum">    1762 </span>            :   // When removing any other single element, it is removed by swapping it with
<span class="lineNum">    1763 </span>            :   // the last element, and then decrementing the length as before.
<span class="lineNum">    1764 </span>            :   //
<span class="lineNum">    1765 </span>            :   // [ 1, 2, 3, 4, 5, 6 ]  =&gt; [ 1, 6, 3, 4, 5 ]
<span class="lineNum">    1766 </span>            :   //      ^
<span class="lineNum">    1767 </span>            :   //
<span class="lineNum">    1768 </span>            :   // This method also supports efficiently removing a range of elements. If they
<span class="lineNum">    1769 </span>            :   // are at the end, then they can all be removed like in the one element case.
<span class="lineNum">    1770 </span>            :   //
<span class="lineNum">    1771 </span>            :   // [ 1, 2, 3, 4, 5, 6 ] =&gt; [ 1, 2 ]
<span class="lineNum">    1772 </span>            :   //         ^--------^
<span class="lineNum">    1773 </span>            :   //
<span class="lineNum">    1774 </span>            :   // If more elements are removed than exist after the removed section, the
<span class="lineNum">    1775 </span>            :   // remaining elements will be shifted down like in a normal removal.
<span class="lineNum">    1776 </span>            :   //
<span class="lineNum">    1777 </span>            :   // [ 1, 2, 3, 4, 5, 6, 7, 8 ] =&gt; [ 1, 2, 7, 8 ]
<span class="lineNum">    1778 </span>            :   //         ^--------^
<span class="lineNum">    1779 </span>            :   //
<span class="lineNum">    1780 </span>            :   // And if fewer elements are removed than exist after the removed section,
<span class="lineNum">    1781 </span>            :   // elements will be moved from the end of the array to fill the vacated space.
<span class="lineNum">    1782 </span>            :   //
<span class="lineNum">    1783 </span>            :   // [ 1, 2, 3, 4, 5, 6, 7, 8 ] =&gt; [ 1, 7, 8, 4, 5, 6 ]
<span class="lineNum">    1784 </span>            :   //      ^--^
<span class="lineNum">    1785 </span>            :   //
<span class="lineNum">    1786 </span>            :   // @param aStart The starting index of the elements to remove. @param aCount
<span class="lineNum">    1787 </span>            :   // The number of elements to remove.
<span class="lineNum">    1788 </span>            :   void UnorderedRemoveElementsAt(index_type aStart, size_type aCount);
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            :   // A variation on the UnorderedRemoveElementsAt method defined above to remove
<span class="lineNum">    1791 </span>            :   // a single element. This operation is sometimes called `SwapRemove`.
<span class="lineNum">    1792 </span>            :   //
<span class="lineNum">    1793 </span>            :   // This method is O(1), but does not preserve the order of the elements.
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :   void UnorderedRemoveElementAt(index_type aIndex) {</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :     UnorderedRemoveElementsAt(aIndex, 1);</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :   void Clear() {</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     ClearAndRetainStorage();</span>
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :     Compact();</span>
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1802 </span>            : 
<span class="lineNum">    1803 </span>            :   // This method removes elements based on the return value of the
<span class="lineNum">    1804 </span>            :   // callback function aPredicate. If the function returns true for
<span class="lineNum">    1805 </span>            :   // an element, the element is removed. aPredicate will be called
<span class="lineNum">    1806 </span>            :   // for each element in order. It is not safe to access the array
<span class="lineNum">    1807 </span>            :   // inside aPredicate.
<span class="lineNum">    1808 </span>            :   template&lt;typename Predicate&gt;
<span class="lineNum">    1809 </span>            :   void RemoveElementsBy(Predicate aPredicate);
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span>            :   // This helper function combines IndexOf with RemoveElementAt to &quot;search
<span class="lineNum">    1812 </span>            :   // and destroy&quot; the first element that is equal to the given element.
<span class="lineNum">    1813 </span>            :   // @param aItem The item to search for.
<span class="lineNum">    1814 </span>            :   // @param aComp The Comparator used to determine element equality.
<span class="lineNum">    1815 </span>            :   // @return true if the element was found
<span class="lineNum">    1816 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :   bool RemoveElement(const Item&amp; aItem, const Comparator&amp; aComp)</span>
<span class="lineNum">    1818 </span>            :   {
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :     index_type i = IndexOf(aItem, 0, aComp);</span>
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :     if (i == NoIndex) {</span>
<span class="lineNum">    1821 </span>            :       return false;
<span class="lineNum">    1822 </span>            :     }
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :     RemoveElementAt(i);</span>
<span class="lineNum">    1825 </span>            :     return true;
<span class="lineNum">    1826 </span>            :   }
<span class="lineNum">    1827 </span>            : 
<span class="lineNum">    1828 </span>            :   // A variation on the RemoveElement method defined above that assumes
<span class="lineNum">    1829 </span>            :   // that 'operator==' is defined for elem_type.
<span class="lineNum">    1830 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :   bool RemoveElement(const Item&amp; aItem)</span>
<span class="lineNum">    1832 </span>            :   {
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :     return RemoveElement(aItem, nsDefaultComparator&lt;elem_type, Item&gt;());</span>
<span class="lineNum">    1834 </span>            :   }
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            :   // This helper function combines IndexOfFirstElementGt with
<span class="lineNum">    1837 </span>            :   // RemoveElementAt to &quot;search and destroy&quot; the last element that
<span class="lineNum">    1838 </span>            :   // is equal to the given element.
<span class="lineNum">    1839 </span>            :   // @param aItem The item to search for.
<span class="lineNum">    1840 </span>            :   // @param aComp The Comparator used to determine element equality.
<span class="lineNum">    1841 </span>            :   // @return true if the element was found
<span class="lineNum">    1842 </span>            :   template&lt;class Item, class Comparator&gt;
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :   bool RemoveElementSorted(const Item&amp; aItem, const Comparator&amp; aComp)</span>
<span class="lineNum">    1844 </span>            :   {
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :     index_type index = IndexOfFirstElementGt(aItem, aComp);</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     if (index &gt; 0 &amp;&amp; aComp.Equals(ElementAt(index - 1), aItem)) {</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :       RemoveElementAt(index - 1);</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1849 </span>            :     }
<span class="lineNum">    1850 </span>            :     return false;
<span class="lineNum">    1851 </span>            :   }
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span>            :   // A variation on the RemoveElementSorted method defined above.
<span class="lineNum">    1854 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :   bool RemoveElementSorted(const Item&amp; aItem)</span>
<span class="lineNum">    1856 </span>            :   {
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :     return RemoveElementSorted(aItem, nsDefaultComparator&lt;elem_type, Item&gt;());</span>
<span class="lineNum">    1858 </span>            :   }
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span>            :   // This method causes the elements contained in this array and the given
<span class="lineNum">    1861 </span>            :   // array to be swapped.
<span class="lineNum">    1862 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :   typename Alloc::ResultType SwapElements(nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)</span>
<span class="lineNum">    1864 </span>            :   {
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     return Alloc::Result(this-&gt;template SwapArrayElements&lt;Alloc&gt;(</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :       aOther, sizeof(elem_type), MOZ_ALIGNOF(elem_type)));</span>
<span class="lineNum">    1867 </span>            :   }
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span>            :   //
<span class="lineNum">    1870 </span>            :   // Allocation
<span class="lineNum">    1871 </span>            :   //
<span class="lineNum">    1872 </span>            : 
<span class="lineNum">    1873 </span>            :   // This method may increase the capacity of this array object to the
<span class="lineNum">    1874 </span>            :   // specified amount.  This method may be called in advance of several
<span class="lineNum">    1875 </span>            :   // AppendElement operations to minimize heap re-allocations.  This method
<span class="lineNum">    1876 </span>            :   // will not reduce the number of elements in this array.
<span class="lineNum">    1877 </span>            :   // @param aCapacity The desired capacity of this array.
<span class="lineNum">    1878 </span>            :   // @return True if the operation succeeded; false if we ran out of memory
<span class="lineNum">    1879 </span>            : protected:
<span class="lineNum">    1880 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :   typename ActualAlloc::ResultType SetCapacity(size_type aCapacity)</span>
<span class="lineNum">    1882 </span>            :   {
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     return ActualAlloc::Result(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :       aCapacity, sizeof(elem_type)));</span>
<span class="lineNum">    1885 </span>            :   }
<span class="lineNum">    1886 </span>            : public:
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1889 </span>            :   bool SetCapacity(size_type aCapacity, const mozilla::fallible_t&amp;)
<span class="lineNum">    1890 </span>            :   {
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :     return SetCapacity&lt;FallibleAlloc&gt;(aCapacity);</span>
<span class="lineNum">    1892 </span>            :   }
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            :   // This method modifies the length of the array.  If the new length is
<span class="lineNum">    1895 </span>            :   // larger than the existing length of the array, then new elements will be
<span class="lineNum">    1896 </span>            :   // constructed using elem_type's default constructor.  Otherwise, this call
<span class="lineNum">    1897 </span>            :   // removes elements from the array (see also RemoveElementsAt).
<span class="lineNum">    1898 </span>            :   // @param aNewLen The desired length of this array.
<span class="lineNum">    1899 </span>            :   // @return True if the operation succeeded; false otherwise.
<span class="lineNum">    1900 </span>            :   // See also TruncateLength if the new length is guaranteed to be smaller than
<span class="lineNum">    1901 </span>            :   // the old.
<span class="lineNum">    1902 </span>            : protected:
<span class="lineNum">    1903 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :   typename ActualAlloc::ResultType SetLength(size_type aNewLen)</span>
<span class="lineNum">    1905 </span>            :   {
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :     size_type oldLen = Length();</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     if (aNewLen &gt; oldLen) {</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :       return ActualAlloc::ConvertBoolToResultType(</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :         InsertElementsAt&lt;ActualAlloc&gt;(oldLen, aNewLen - oldLen) != nullptr);</span>
<span class="lineNum">    1910 </span>            :     }
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :     TruncateLength(aNewLen);</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :     return ActualAlloc::ConvertBoolToResultType(true);</span>
<span class="lineNum">    1914 </span>            :   }
<span class="lineNum">    1915 </span>            : public:
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1918 </span>            :   bool SetLength(size_type aNewLen, const mozilla::fallible_t&amp;)
<span class="lineNum">    1919 </span>            :   {
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :     return SetLength&lt;FallibleAlloc&gt;(aNewLen);</span>
<span class="lineNum">    1921 </span>            :   }
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            :   // This method modifies the length of the array, but may only be
<span class="lineNum">    1924 </span>            :   // called when the new length is shorter than the old.  It can
<span class="lineNum">    1925 </span>            :   // therefore be called when elem_type has no default constructor,
<span class="lineNum">    1926 </span>            :   // unlike SetLength.  It removes elements from the array (see also
<span class="lineNum">    1927 </span>            :   // RemoveElementsAt).
<span class="lineNum">    1928 </span>            :   // @param aNewLen The desired length of this array.
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :   void TruncateLength(size_type aNewLen)</span>
<span class="lineNum">    1930 </span>            :   {
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :     size_type oldLen = Length();</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(aNewLen &lt;= oldLen,</span>
<span class="lineNum">    1933 </span>            :                &quot;caller should use SetLength instead&quot;);
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :     RemoveElementsAt(aNewLen, oldLen - aNewLen);</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span>            :   // This method ensures that the array has length at least the given
<span class="lineNum">    1938 </span>            :   // length.  If the current length is shorter than the given length,
<span class="lineNum">    1939 </span>            :   // then new elements will be constructed using elem_type's default
<span class="lineNum">    1940 </span>            :   // constructor.
<span class="lineNum">    1941 </span>            :   // @param aMinLen The desired minimum length of this array.
<span class="lineNum">    1942 </span>            :   // @return True if the operation succeeded; false otherwise.
<span class="lineNum">    1943 </span>            : protected:
<span class="lineNum">    1944 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :   typename ActualAlloc::ResultType EnsureLengthAtLeast(size_type aMinLen)</span>
<span class="lineNum">    1946 </span>            :   {
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :     size_type oldLen = Length();</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :     if (aMinLen &gt; oldLen) {</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :       return ActualAlloc::ConvertBoolToResultType(</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :         !!InsertElementsAt&lt;ActualAlloc&gt;(oldLen, aMinLen - oldLen));</span>
<span class="lineNum">    1951 </span>            :     }
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :     return ActualAlloc::ConvertBoolToResultType(true);</span>
<span class="lineNum">    1953 </span>            :   }
<span class="lineNum">    1954 </span>            : public:
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1957 </span>            :   bool EnsureLengthAtLeast(size_type aMinLen, const mozilla::fallible_t&amp;)
<span class="lineNum">    1958 </span>            :   {
<span class="lineNum">    1959 </span>            :     return EnsureLengthAtLeast&lt;FallibleAlloc&gt;(aMinLen);
<span class="lineNum">    1960 </span>            :   }
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span>            :   // This method inserts elements into the array, constructing
<span class="lineNum">    1963 </span>            :   // them using elem_type's default constructor.
<span class="lineNum">    1964 </span>            :   // @param aIndex the place to insert the new elements. This must be no
<span class="lineNum">    1965 </span>            :   //               greater than the current length of the array.
<span class="lineNum">    1966 </span>            :   // @param aCount the number of elements to insert
<span class="lineNum">    1967 </span>            : protected:
<span class="lineNum">    1968 </span>            :   template&lt;typename ActualAlloc = Alloc&gt;
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :   elem_type* InsertElementsAt(index_type aIndex, size_type aCount)</span>
<span class="lineNum">    1970 </span>            :   {
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     if (!base_type::template InsertSlotsAt&lt;ActualAlloc&gt;(aIndex, aCount,</span>
<span class="lineNum">    1972 </span>            :                                                         sizeof(elem_type),
<span class="lineNum">    1973 </span>            :                                                         MOZ_ALIGNOF(elem_type))) {
<span class="lineNum">    1974 </span>            :       return nullptr;
<span class="lineNum">    1975 </span>            :     }
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            :     // Initialize the extra array elements
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :     elem_type* iter = Elements() + aIndex;</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :     elem_type* iend = iter + aCount;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     for (; iter != iend; ++iter) {</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :       elem_traits::Construct(iter);</span>
<span class="lineNum">    1982 </span>            :     }
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :     return Elements() + aIndex;</span>
<span class="lineNum">    1985 </span>            :   }
<span class="lineNum">    1986 </span>            : public:
<span class="lineNum">    1987 </span>            : 
<span class="lineNum">    1988 </span>            :   MOZ_MUST_USE
<span class="lineNum">    1989 </span>            :   elem_type* InsertElementsAt(index_type aIndex, size_type aCount,
<span class="lineNum">    1990 </span>            :                               const mozilla::fallible_t&amp;)
<span class="lineNum">    1991 </span>            :   {
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :     return InsertElementsAt&lt;FallibleAlloc&gt;(aIndex, aCount);</span>
<span class="lineNum">    1993 </span>            :   }
<span class="lineNum">    1994 </span>            : 
<span class="lineNum">    1995 </span>            :   // This method inserts elements into the array, constructing them
<span class="lineNum">    1996 </span>            :   // elem_type's copy constructor (or whatever one-arg constructor
<span class="lineNum">    1997 </span>            :   // happens to match the Item type).
<span class="lineNum">    1998 </span>            :   // @param aIndex the place to insert the new elements. This must be no
<span class="lineNum">    1999 </span>            :   //               greater than the current length of the array.
<span class="lineNum">    2000 </span>            :   // @param aCount the number of elements to insert.
<span class="lineNum">    2001 </span>            :   // @param aItem the value to use when constructing the new elements.
<span class="lineNum">    2002 </span>            : protected:
<span class="lineNum">    2003 </span>            :   template&lt;class Item, typename ActualAlloc = Alloc&gt;
<span class="lineNum">    2004 </span>            :   elem_type* InsertElementsAt(index_type aIndex, size_type aCount,
<span class="lineNum">    2005 </span>            :                               const Item&amp; aItem);
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span>            : public:
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    2010 </span>            :   MOZ_MUST_USE
<span class="lineNum">    2011 </span>            :   elem_type* InsertElementsAt(index_type aIndex, size_type aCount,
<span class="lineNum">    2012 </span>            :                               const Item&amp; aItem, const mozilla::fallible_t&amp;)
<span class="lineNum">    2013 </span>            :   {
<span class="lineNum">    2014 </span>            :     return InsertElementsAt&lt;Item, FallibleAlloc&gt;(aIndex, aCount, aItem);
<span class="lineNum">    2015 </span>            :   }
<span class="lineNum">    2016 </span>            : 
<span class="lineNum">    2017 </span>            :   // This method may be called to minimize the memory used by this array.
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :   void Compact()</span>
<span class="lineNum">    2019 </span>            :   {
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :     ShrinkCapacity(sizeof(elem_type), MOZ_ALIGNOF(elem_type));</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span>            :   //
<span class="lineNum">    2024 </span>            :   // Sorting
<span class="lineNum">    2025 </span>            :   //
<span class="lineNum">    2026 </span>            : 
<span class="lineNum">    2027 </span>            :   // This function is meant to be used with the NS_QuickSort function.  It
<span class="lineNum">    2028 </span>            :   // maps the callback API expected by NS_QuickSort to the Comparator API
<span class="lineNum">    2029 </span>            :   // used by nsTArray_Impl.  See nsTArray_Impl::Sort.
<span class="lineNum">    2030 </span>            :   template&lt;class Comparator&gt;
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :   static int Compare(const void* aE1, const void* aE2, void* aData)</span>
<span class="lineNum">    2032 </span>            :   {
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :     const Comparator* c = reinterpret_cast&lt;const Comparator*&gt;(aData);</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :     const elem_type* a = static_cast&lt;const elem_type*&gt;(aE1);</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :     const elem_type* b = static_cast&lt;const elem_type*&gt;(aE2);</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :     return c-&gt;LessThan(*a, *b) ? -1 : (c-&gt;Equals(*a, *b) ? 0 : 1);</span>
<span class="lineNum">    2037 </span>            :   }
<span class="lineNum">    2038 </span>            : 
<span class="lineNum">    2039 </span>            :   // This method sorts the elements of the array.  It uses the LessThan
<span class="lineNum">    2040 </span>            :   // method defined on the given Comparator object to collate elements.
<span class="lineNum">    2041 </span>            :   // @param aComp The Comparator used to collate elements.
<span class="lineNum">    2042 </span>            :   template&lt;class Comparator&gt;
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :   void Sort(const Comparator&amp; aComp)</span>
<span class="lineNum">    2044 </span>            :   {
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :     NS_QuickSort(Elements(), Length(), sizeof(elem_type),</span>
<span class="lineNum">    2046 </span>            :                  Compare&lt;Comparator&gt;, const_cast&lt;Comparator*&gt;(&amp;aComp));
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2048 </span>            : 
<span class="lineNum">    2049 </span>            :   // A variation on the Sort method defined above that assumes that
<span class="lineNum">    2050 </span>            :   // 'operator&lt;' is defined for elem_type.
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :   void Sort() { Sort(nsDefaultComparator&lt;elem_type, elem_type&gt;()); }</span>
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :   // This method reverses the array in place.
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :   void Reverse()</span>
<span class="lineNum">    2055 </span>            :   {
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :     elem_type* elements = Elements();</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :     const size_type len = Length();</span>
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :     for (index_type i = 0, iend = len / 2; i &lt; iend; ++i) {</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :       mozilla::Swap(elements[i], elements[len - i - 1]);</span>
<span class="lineNum">    2060 </span>            :     }
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span>            : protected:
<span class="lineNum">    2064 </span>            :   using base_type::Hdr;
<span class="lineNum">    2065 </span>            :   using base_type::ShrinkCapacity;
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span>            :   // This method invokes elem_type's destructor on a range of elements.
<span class="lineNum">    2068 </span>            :   // @param aStart The index of the first element to destroy.
<span class="lineNum">    2069 </span>            :   // @param aCount The number of elements to destroy.
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :   void DestructRange(index_type aStart, size_type aCount)</span>
<span class="lineNum">    2071 </span>            :   {
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     elem_type* iter = Elements() + aStart;</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :     elem_type *iend = iter + aCount;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :     for (; iter != iend; ++iter) {</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :       elem_traits::Destruct(iter);</span>
<span class="lineNum">    2076 </span>            :     }
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            :   // This method invokes elem_type's copy-constructor on a range of elements.
<span class="lineNum">    2080 </span>            :   // @param aStart  The index of the first element to construct.
<span class="lineNum">    2081 </span>            :   // @param aCount  The number of elements to construct.
<span class="lineNum">    2082 </span>            :   // @param aValues The array of elements to copy.
<span class="lineNum">    2083 </span>            :   template&lt;class Item&gt;
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :   void AssignRange(index_type aStart, size_type aCount, const Item* aValues)</span>
<span class="lineNum">    2085 </span>            :   {
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :     AssignRangeAlgorithm&lt;mozilla::IsPod&lt;Item&gt;::value,</span>
<span class="lineNum">    2087 </span>            :                          mozilla::IsSame&lt;Item, elem_type&gt;::value&gt;
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :                          ::implementation(Elements(), aStart, aCount, aValues);</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2090 </span>            : };
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2093 </span>            : template&lt;class Item, typename ActualAlloc&gt;
<span class="lineNum">    2094 </span>            : auto
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::ReplaceElementsAt(index_type aStart, size_type aCount,</span>
<span class="lineNum">    2096 </span>            :                                            const Item* aArray, size_type aArrayLen) -&gt; elem_type*
<span class="lineNum">    2097 </span>            : {
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :   if (MOZ_UNLIKELY(aStart &gt; Length())) {</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :     InvalidArrayIndex_CRASH(aStart, Length());</span>
<span class="lineNum">    2100 </span>            :   }
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            :   // Adjust memory allocation up-front to catch errors.
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :   if (!ActualAlloc::Successful(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :         Length() + aArrayLen - aCount, sizeof(elem_type)))) {</span>
<span class="lineNum">    2105 </span>            :     return nullptr;
<span class="lineNum">    2106 </span>            :   }
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :   DestructRange(aStart, aCount);</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :   this-&gt;template ShiftData&lt;ActualAlloc&gt;(aStart, aCount, aArrayLen,</span>
<span class="lineNum">    2109 </span>            :                                         sizeof(elem_type),
<span class="lineNum">    2110 </span>            :                                         MOZ_ALIGNOF(elem_type));
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :   AssignRange(aStart, aArrayLen, aArray);</span>
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :   return Elements() + aStart;</span>
<span class="lineNum">    2113 </span>            : }
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2116 </span>            : void
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::RemoveElementsAt(index_type aStart, size_type aCount)</span>
<span class="lineNum">    2118 </span>            : {
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aCount == 0 || aStart &lt; Length(), &quot;Invalid aStart index&quot;);</span>
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :   mozilla::CheckedInt&lt;index_type&gt; rangeEnd = aStart;</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :   rangeEnd += aCount;</span>
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :   if (MOZ_UNLIKELY(!rangeEnd.isValid() || rangeEnd.value() &gt; Length())) {</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     InvalidArrayIndex_CRASH(aStart, Length());</span>
<span class="lineNum">    2126 </span>            :   }
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :   DestructRange(aStart, aCount);</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :   this-&gt;template ShiftData&lt;InfallibleAlloc&gt;(aStart, aCount, 0,</span>
<span class="lineNum">    2130 </span>            :                                             sizeof(elem_type),
<span class="lineNum">    2131 </span>            :                                             MOZ_ALIGNOF(elem_type));
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2133 </span>            : 
<span class="lineNum">    2134 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2135 </span>            : void
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::UnorderedRemoveElementsAt(index_type aStart, size_type aCount)</span>
<span class="lineNum">    2137 </span>            : {
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aCount == 0 || aStart &lt; Length(), &quot;Invalid aStart index&quot;);</span>
<span class="lineNum">    2139 </span>            : 
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :   mozilla::CheckedInt&lt;index_type&gt; rangeEnd = aStart;</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :   rangeEnd += aCount;</span>
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :   if (MOZ_UNLIKELY(!rangeEnd.isValid() || rangeEnd.value() &gt; Length())) {</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :     InvalidArrayIndex_CRASH(aStart, Length());</span>
<span class="lineNum">    2145 </span>            :   }
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span>            :   // Destroy the elements which are being removed, and then swap elements in to
<span class="lineNum">    2148 </span>            :   // replace them from the end. See the docs on the declaration of this
<span class="lineNum">    2149 </span>            :   // function.
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :   DestructRange(aStart, aCount);</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :   this-&gt;template SwapFromEnd&lt;InfallibleAlloc&gt;(aStart, aCount,</span>
<span class="lineNum">    2152 </span>            :                                               sizeof(elem_type),
<span class="lineNum">    2153 </span>            :                                               MOZ_ALIGNOF(elem_type));
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2157 </span>            : template&lt;typename Predicate&gt;
<span class="lineNum">    2158 </span>            : void
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::RemoveElementsBy(Predicate aPredicate)</span>
<span class="lineNum">    2160 </span>            : {
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :   if (base_type::mHdr == EmptyHdr()) {</span>
<span class="lineNum">    2162 </span>            :     return;
<span class="lineNum">    2163 </span>            :   }
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :   index_type j = 0;</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :   index_type len = Length();</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :   for (index_type i = 0; i &lt; len; ++i) {</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :     if (aPredicate(Elements()[i])) {</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :       elem_traits::Destruct(Elements() + i);</span>
<span class="lineNum">    2170 </span>            :     } else {
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :       if (j &lt; i) {</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         copy_type::MoveNonOverlappingRegion(Elements() + j, Elements() + i,</span>
<span class="lineNum">    2173 </span>            :                                             1, sizeof(elem_type));
<span class="lineNum">    2174 </span>            :       }
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :       ++j;</span>
<span class="lineNum">    2176 </span>            :     }
<span class="lineNum">    2177 </span>            :   }
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :   base_type::mHdr-&gt;mLength = j;</span>
<span class="lineNum">    2179 </span>            : }
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2182 </span>            : template&lt;class Item, typename ActualAlloc&gt;
<span class="lineNum">    2183 </span>            : auto
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::InsertElementsAt(index_type aIndex, size_type aCount,</span>
<span class="lineNum">    2185 </span>            :                                           const Item&amp; aItem) -&gt; elem_type*
<span class="lineNum">    2186 </span>            : {
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :   if (!base_type::template InsertSlotsAt&lt;ActualAlloc&gt;(aIndex, aCount,</span>
<span class="lineNum">    2188 </span>            :                                                       sizeof(elem_type),
<span class="lineNum">    2189 </span>            :                                                       MOZ_ALIGNOF(elem_type))) {
<span class="lineNum">    2190 </span>            :     return nullptr;
<span class="lineNum">    2191 </span>            :   }
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span>            :   // Initialize the extra array elements
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :   elem_type* iter = Elements() + aIndex;</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :   elem_type* iend = iter + aCount;</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :   for (; iter != iend; ++iter) {</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :     elem_traits::Construct(iter, aItem);</span>
<span class="lineNum">    2198 </span>            :   }
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :   return Elements() + aIndex;</span>
<span class="lineNum">    2201 </span>            : }
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2204 </span>            : template&lt;typename ActualAlloc&gt;
<span class="lineNum">    2205 </span>            : auto
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::InsertElementAt(index_type aIndex) -&gt; elem_type*</span>
<span class="lineNum">    2207 </span>            : {
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :   if (MOZ_UNLIKELY(aIndex &gt; Length())) {</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     InvalidArrayIndex_CRASH(aIndex, Length());</span>
<span class="lineNum">    2210 </span>            :   }
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :   if (!ActualAlloc::Successful(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 :         Length() + 1, sizeof(elem_type)))) {</span>
<span class="lineNum">    2214 </span>            :     return nullptr;
<span class="lineNum">    2215 </span>            :   }
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :   this-&gt;template ShiftData&lt;ActualAlloc&gt;(aIndex, 0, 1, sizeof(elem_type),</span>
<span class="lineNum">    2217 </span>            :                                         MOZ_ALIGNOF(elem_type));
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :   elem_type* elem = Elements() + aIndex;</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :   elem_traits::Construct(elem);</span>
<span class="lineNum">    2220 </span>            :   return elem;
<span class="lineNum">    2221 </span>            : }
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2224 </span>            : template&lt;class Item, typename ActualAlloc&gt;
<span class="lineNum">    2225 </span>            : auto
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::InsertElementAt(index_type aIndex, Item&amp;&amp; aItem) -&gt; elem_type*</span>
<span class="lineNum">    2227 </span>            : {
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :   if (MOZ_UNLIKELY(aIndex &gt; Length())) {</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :     InvalidArrayIndex_CRASH(aIndex, Length());</span>
<span class="lineNum">    2230 </span>            :   }
<span class="lineNum">    2231 </span>            : 
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :   if (!ActualAlloc::Successful(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :          Length() + 1, sizeof(elem_type)))) {</span>
<span class="lineNum">    2234 </span>            :     return nullptr;
<span class="lineNum">    2235 </span>            :   }
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :   this-&gt;template ShiftData&lt;ActualAlloc&gt;(aIndex, 0, 1, sizeof(elem_type),</span>
<span class="lineNum">    2237 </span>            :                                         MOZ_ALIGNOF(elem_type));
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :   elem_type* elem = Elements() + aIndex;</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :   elem_traits::Construct(elem, std::forward&lt;Item&gt;(aItem));</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :   return elem;</span>
<span class="lineNum">    2241 </span>            : }
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2244 </span>            : template&lt;class Item, typename ActualAlloc&gt;
<span class="lineNum">    2245 </span>            : auto
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::AppendElements(const Item* aArray, size_type aArrayLen) -&gt; elem_type*</span>
<span class="lineNum">    2247 </span>            : {
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :   if (!ActualAlloc::Successful(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :         Length() + aArrayLen, sizeof(elem_type)))) {</span>
<span class="lineNum">    2250 </span>            :     return nullptr;
<span class="lineNum">    2251 </span>            :   }
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :   index_type len = Length();</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :   AssignRange(len, aArrayLen, aArray);</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :   this-&gt;IncrementLength(aArrayLen);</span>
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :   return Elements() + len;</span>
<span class="lineNum">    2256 </span>            : }
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2259 </span>            : template&lt;class Item, class Allocator, typename ActualAlloc&gt;
<span class="lineNum">    2260 </span>            : auto
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::AppendElements(nsTArray_Impl&lt;Item, Allocator&gt;&amp;&amp; aArray) -&gt; elem_type*</span>
<span class="lineNum">    2262 </span>            : {
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(&amp;aArray != this, &quot;argument must be different aArray&quot;);</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :   if (Length() == 0) {</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :     SwapElements&lt;ActualAlloc&gt;(aArray);</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :     return Elements();</span>
<span class="lineNum">    2267 </span>            :   }
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :   index_type len = Length();</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :   index_type otherLen = aArray.Length();</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :   if (!Alloc::Successful(this-&gt;template EnsureCapacity&lt;Alloc&gt;(</span>
<span class="lineNum">    2272 </span>            :         len + otherLen, sizeof(elem_type)))) {
<span class="lineNum">    2273 </span>            :     return nullptr;
<span class="lineNum">    2274 </span>            :   }
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :   copy_type::MoveNonOverlappingRegion(Elements() + len, aArray.Elements(), otherLen,</span>
<span class="lineNum">    2276 </span>            :                                       sizeof(elem_type));
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :   this-&gt;IncrementLength(otherLen);</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :   aArray.template ShiftData&lt;Alloc&gt;(0, otherLen, 0, sizeof(elem_type),</span>
<span class="lineNum">    2279 </span>            :                                    MOZ_ALIGNOF(elem_type));
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :   return Elements() + len;</span>
<span class="lineNum">    2281 </span>            : }
<span class="lineNum">    2282 </span>            : 
<span class="lineNum">    2283 </span>            : template&lt;typename E, class Alloc&gt;
<span class="lineNum">    2284 </span>            : template&lt;class Item, typename ActualAlloc&gt;
<span class="lineNum">    2285 </span>            : auto
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 : nsTArray_Impl&lt;E, Alloc&gt;::AppendElement(Item&amp;&amp; aItem) -&gt; elem_type*</span>
<span class="lineNum">    2287 </span>            : {
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :   if (!ActualAlloc::Successful(this-&gt;template EnsureCapacity&lt;ActualAlloc&gt;(</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :          Length() + 1, sizeof(elem_type)))) {</span>
<span class="lineNum">    2290 </span>            :     return nullptr;
<span class="lineNum">    2291 </span>            :   }
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :   elem_type* elem = Elements() + Length();</span>
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :   elem_traits::Construct(elem, std::forward&lt;Item&gt;(aItem));</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :   this-&gt;mHdr-&gt;mLength += 1;</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :   return elem;</span>
<span class="lineNum">    2296 </span>            : }
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span>            : template&lt;typename E, typename Alloc&gt;
<span class="lineNum">    2299 </span>            : inline void
<span class="lineNum">    2300 </span>            : ImplCycleCollectionUnlink(nsTArray_Impl&lt;E, Alloc&gt;&amp; aField)
<span class="lineNum">    2301 </span>            : {
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :   aField.Clear();</span>
<span class="lineNum">    2303 </span>            : }
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span>            : template&lt;typename E, typename Alloc&gt;
<span class="lineNum">    2306 </span>            : inline void
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 : ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback&amp; aCallback,</span>
<span class="lineNum">    2308 </span>            :                             nsTArray_Impl&lt;E, Alloc&gt;&amp; aField,
<span class="lineNum">    2309 </span>            :                             const char* aName,
<span class="lineNum">    2310 </span>            :                             uint32_t aFlags = 0)
<span class="lineNum">    2311 </span>            : {
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :   aFlags |= CycleCollectionEdgeNameArrayFlag;</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :   size_t length = aField.Length();</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :   for (size_t i = 0; i &lt; length; ++i) {</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :     ImplCycleCollectionTraverse(aCallback, aField[i], aName, aFlags);</span>
<span class="lineNum">    2316 </span>            :   }
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2318 </span>            : 
<span class="lineNum">    2319 </span>            : //
<span class="lineNum">    2320 </span>            : // nsTArray is an infallible vector class.  See the comment at the top of this
<span class="lineNum">    2321 </span>            : // file for more details.
<span class="lineNum">    2322 </span>            : //
<span class="lineNum">    2323 </span>            : template&lt;class E&gt;
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 : class nsTArray : public nsTArray_Impl&lt;E, nsTArrayInfallibleAllocator&gt;</span>
<span class="lineNum">    2325 </span>            : {
<span class="lineNum">    2326 </span>            : public:
<span class="lineNum">    2327 </span>            :   typedef nsTArray_Impl&lt;E, nsTArrayInfallibleAllocator&gt; base_type;
<span class="lineNum">    2328 </span>            :   typedef nsTArray&lt;E&gt;                                   self_type;
<span class="lineNum">    2329 </span>            :   typedef typename base_type::size_type                 size_type;
<span class="lineNum">    2330 </span>            : 
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :   nsTArray() {}</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :   explicit nsTArray(size_type aCapacity) : base_type(aCapacity) {}</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :   explicit nsTArray(const nsTArray&amp; aOther) : base_type(aOther) {}</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :   MOZ_IMPLICIT nsTArray(nsTArray&amp;&amp; aOther) : base_type(std::move(aOther)) {}</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :   MOZ_IMPLICIT nsTArray(std::initializer_list&lt;E&gt; aIL) : base_type(aIL) {}</span>
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :   explicit nsTArray(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :     : base_type(aOther)</span>
<span class="lineNum">    2340 </span>            :   {
<span class="lineNum">    2341 </span>            :   }
<span class="lineNum">    2342 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2343 </span>            :   MOZ_IMPLICIT nsTArray(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)
<span class="lineNum">    2344 </span>            :     : base_type(std::move(aOther))
<span class="lineNum">    2345 </span>            :   {
<span class="lineNum">    2346 </span>            :   }
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span>            :   self_type&amp; operator=(const self_type&amp; aOther)
<span class="lineNum">    2349 </span>            :   {
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :     base_type::operator=(aOther);</span>
<span class="lineNum">    2351 </span>            :     return *this;
<span class="lineNum">    2352 </span>            :   }
<span class="lineNum">    2353 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2354 </span>            :   self_type&amp; operator=(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)
<span class="lineNum">    2355 </span>            :   {
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :     base_type::operator=(aOther);</span>
<span class="lineNum">    2357 </span>            :     return *this;
<span class="lineNum">    2358 </span>            :   }
<span class="lineNum">    2359 </span>            :   self_type&amp; operator=(self_type&amp;&amp; aOther)
<span class="lineNum">    2360 </span>            :   {
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :     base_type::operator=(std::move(aOther));</span>
<span class="lineNum">    2362 </span>            :     return *this;
<span class="lineNum">    2363 </span>            :   }
<span class="lineNum">    2364 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2365 </span>            :   self_type&amp; operator=(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)
<span class="lineNum">    2366 </span>            :   {
<span class="lineNum">    2367 </span>            :     base_type::operator=(std::move(aOther));
<span class="lineNum">    2368 </span>            :     return *this;
<span class="lineNum">    2369 </span>            :   }
<span class="lineNum">    2370 </span>            : 
<span class="lineNum">    2371 </span>            :   using base_type::AppendElement;
<span class="lineNum">    2372 </span>            :   using base_type::AppendElements;
<span class="lineNum">    2373 </span>            :   using base_type::EnsureLengthAtLeast;
<span class="lineNum">    2374 </span>            :   using base_type::InsertElementAt;
<span class="lineNum">    2375 </span>            :   using base_type::InsertElementsAt;
<span class="lineNum">    2376 </span>            :   using base_type::InsertElementSorted;
<span class="lineNum">    2377 </span>            :   using base_type::ReplaceElementsAt;
<span class="lineNum">    2378 </span>            :   using base_type::SetCapacity;
<span class="lineNum">    2379 </span>            :   using base_type::SetLength;
<span class="lineNum">    2380 </span>            : };
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span>            : //
<span class="lineNum">    2383 </span>            : // FallibleTArray is a fallible vector class.
<span class="lineNum">    2384 </span>            : //
<span class="lineNum">    2385 </span>            : template&lt;class E&gt;
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 : class FallibleTArray : public nsTArray_Impl&lt;E, nsTArrayFallibleAllocator&gt;</span>
<span class="lineNum">    2387 </span>            : {
<span class="lineNum">    2388 </span>            : public:
<span class="lineNum">    2389 </span>            :   typedef nsTArray_Impl&lt;E, nsTArrayFallibleAllocator&gt;   base_type;
<span class="lineNum">    2390 </span>            :   typedef FallibleTArray&lt;E&gt;                             self_type;
<span class="lineNum">    2391 </span>            :   typedef typename base_type::size_type                 size_type;
<span class="lineNum">    2392 </span>            : 
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :   FallibleTArray() {}</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :   explicit FallibleTArray(size_type aCapacity) : base_type(aCapacity) {}</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :   explicit FallibleTArray(const FallibleTArray&lt;E&gt;&amp; aOther) : base_type(aOther) {}</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :   FallibleTArray(FallibleTArray&lt;E&gt;&amp;&amp; aOther)</span>
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :     : base_type(std::move(aOther))</span>
<span class="lineNum">    2398 </span>            :   {
<span class="lineNum">    2399 </span>            :   }
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2402 </span>            :   explicit FallibleTArray(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)
<span class="lineNum">    2403 </span>            :     : base_type(aOther)
<span class="lineNum">    2404 </span>            :   {
<span class="lineNum">    2405 </span>            :   }
<span class="lineNum">    2406 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :   explicit FallibleTArray(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :     : base_type(std::move(aOther))</span>
<span class="lineNum">    2409 </span>            :   {
<span class="lineNum">    2410 </span>            :   }
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            :   self_type&amp; operator=(const self_type&amp; aOther)
<span class="lineNum">    2413 </span>            :   {
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :     base_type::operator=(aOther);</span>
<span class="lineNum">    2415 </span>            :     return *this;
<span class="lineNum">    2416 </span>            :   }
<span class="lineNum">    2417 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2418 </span>            :   self_type&amp; operator=(const nsTArray_Impl&lt;E, Allocator&gt;&amp; aOther)
<span class="lineNum">    2419 </span>            :   {
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :     base_type::operator=(aOther);</span>
<span class="lineNum">    2421 </span>            :     return *this;
<span class="lineNum">    2422 </span>            :   }
<span class="lineNum">    2423 </span>            :   self_type&amp; operator=(self_type&amp;&amp; aOther)
<span class="lineNum">    2424 </span>            :   {
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :     base_type::operator=(std::move(aOther));</span>
<span class="lineNum">    2426 </span>            :     return *this;
<span class="lineNum">    2427 </span>            :   }
<span class="lineNum">    2428 </span>            :   template&lt;class Allocator&gt;
<span class="lineNum">    2429 </span>            :   self_type&amp; operator=(nsTArray_Impl&lt;E, Allocator&gt;&amp;&amp; aOther)
<span class="lineNum">    2430 </span>            :   {
<span class="lineNum">    2431 </span>            :     base_type::operator=(std::move(aOther));
<span class="lineNum">    2432 </span>            :     return *this;
<span class="lineNum">    2433 </span>            :   }
<span class="lineNum">    2434 </span>            : };
<span class="lineNum">    2435 </span>            : 
<span class="lineNum">    2436 </span>            : //
<span class="lineNum">    2437 </span>            : // AutoTArray&lt;E, N&gt; is like nsTArray&lt;E&gt;, but with N elements of inline storage.
<span class="lineNum">    2438 </span>            : // Storing more than N elements is fine, but it will cause a heap allocation.
<span class="lineNum">    2439 </span>            : //
<span class="lineNum">    2440 </span>            : template&lt;class E, size_t N&gt;
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 : class MOZ_NON_MEMMOVABLE AutoTArray : public nsTArray&lt;E&gt;</span>
<span class="lineNum">    2442 </span>            : {
<span class="lineNum">    2443 </span>            :   static_assert(N != 0, &quot;AutoTArray&lt;E, 0&gt; should be specialized&quot;);
<span class="lineNum">    2444 </span>            : public:
<span class="lineNum">    2445 </span>            :   typedef AutoTArray&lt;E, N&gt; self_type;
<span class="lineNum">    2446 </span>            :   typedef nsTArray&lt;E&gt; base_type;
<span class="lineNum">    2447 </span>            :   typedef typename base_type::Header Header;
<span class="lineNum">    2448 </span>            :   typedef typename base_type::elem_type elem_type;
<span class="lineNum">    2449 </span>            : 
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :   AutoTArray()</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :   AutoTArray(const self_type&amp; aOther)</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :     : nsTArray&lt;E&gt;()</span>
<span class="lineNum">    2457 </span>            :   {
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :     this-&gt;AppendElements(aOther);</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :   explicit AutoTArray(const base_type&amp; aOther)</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :     this-&gt;AppendElements(aOther);</span>
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2467 </span>            : 
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :   explicit AutoTArray(base_type&amp;&amp; aOther)</span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 :     this-&gt;SwapElements(aOther);</span>
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">    2475 </span>            :   explicit AutoTArray(nsTArray_Impl&lt;elem_type, Allocator&gt;&amp;&amp; aOther)
<span class="lineNum">    2476 </span>            :   {
<span class="lineNum">    2477 </span>            :     Init();
<span class="lineNum">    2478 </span>            :     this-&gt;SwapElements(aOther);
<span class="lineNum">    2479 </span>            :   }
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :   MOZ_IMPLICIT AutoTArray(std::initializer_list&lt;E&gt; aIL)</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :     Init();</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :     this-&gt;AppendElements(aIL.begin(), aIL.size());</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span>            :   self_type&amp; operator=(const self_type&amp; aOther)
<span class="lineNum">    2488 </span>            :   {
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :     base_type::operator=(aOther);</span>
<span class="lineNum">    2490 </span>            :     return *this;
<span class="lineNum">    2491 </span>            :   }
<span class="lineNum">    2492 </span>            : 
<span class="lineNum">    2493 </span>            :   template&lt;typename Allocator&gt;
<span class="lineNum">    2494 </span>            :   self_type&amp; operator=(const nsTArray_Impl&lt;elem_type, Allocator&gt;&amp; aOther)
<span class="lineNum">    2495 </span>            :   {
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :     base_type::operator=(aOther);</span>
<span class="lineNum">    2497 </span>            :     return *this;
<span class="lineNum">    2498 </span>            :   }
<span class="lineNum">    2499 </span>            : 
<span class="lineNum">    2500 </span>            : private:
<span class="lineNum">    2501 </span>            :   // nsTArray_base casts itself as an nsAutoArrayBase in order to get a pointer
<span class="lineNum">    2502 </span>            :   // to mAutoBuf.
<span class="lineNum">    2503 </span>            :   template&lt;class Allocator, class Copier&gt;
<span class="lineNum">    2504 </span>            :   friend class nsTArray_base;
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :   void Init()</span>
<span class="lineNum">    2507 </span>            :   {
<span class="lineNum">    2508 </span>            :     static_assert(MOZ_ALIGNOF(elem_type) &lt;= 8,
<span class="lineNum">    2509 </span>            :                   &quot;can't handle alignments greater than 8, &quot;
<span class="lineNum">    2510 </span>            :                   &quot;see nsTArray_base::UsesAutoArrayBuffer()&quot;);
<span class="lineNum">    2511 </span>            :     // Temporary work around for VS2012 RC compiler crash
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :     Header** phdr = base_type::PtrToHdr();</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :     *phdr = reinterpret_cast&lt;Header*&gt;(&amp;mAutoBuf);</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :     (*phdr)-&gt;mLength = 0;</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :     (*phdr)-&gt;mCapacity = N;</span>
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :     (*phdr)-&gt;mIsAutoArray = 1;</span>
<span class="lineNum">    2517 </span>            : 
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(base_type::GetAutoArrayBuffer(MOZ_ALIGNOF(elem_type)) ==</span>
<span class="lineNum">    2519 </span>            :                reinterpret_cast&lt;Header*&gt;(&amp;mAutoBuf),
<span class="lineNum">    2520 </span>            :                &quot;GetAutoArrayBuffer needs to be fixed&quot;);
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2522 </span>            : 
<span class="lineNum">    2523 </span>            :   // Declare mAutoBuf aligned to the maximum of the header's alignment and
<span class="lineNum">    2524 </span>            :   // elem_type's alignment.  We need to use a union rather than
<span class="lineNum">    2525 </span>            :   // MOZ_ALIGNED_DECL because GCC is picky about what goes into
<span class="lineNum">    2526 </span>            :   // __attribute__((aligned(foo))).
<span class="lineNum">    2527 </span>            :   union
<span class="lineNum">    2528 </span>            :   {
<span class="lineNum">    2529 </span>            :     char mAutoBuf[sizeof(nsTArrayHeader) + N * sizeof(elem_type)];
<span class="lineNum">    2530 </span>            :     // Do the max operation inline to ensure that it is a compile-time constant.
<span class="lineNum">    2531 </span>            :     mozilla::AlignedElem&lt;(MOZ_ALIGNOF(Header) &gt; MOZ_ALIGNOF(elem_type)) ?
<span class="lineNum">    2532 </span>            :                          MOZ_ALIGNOF(Header) : MOZ_ALIGNOF(elem_type)&gt; mAlign;
<span class="lineNum">    2533 </span>            :   };
<span class="lineNum">    2534 </span>            : };
<span class="lineNum">    2535 </span>            : 
<span class="lineNum">    2536 </span>            : //
<span class="lineNum">    2537 </span>            : // Specialization of AutoTArray&lt;E, N&gt; for the case where N == 0.
<span class="lineNum">    2538 </span>            : // AutoTArray&lt;E, 0&gt; behaves exactly like nsTArray&lt;E&gt;, but without this
<span class="lineNum">    2539 </span>            : // specialization, it stores a useless inline header.
<span class="lineNum">    2540 </span>            : //
<span class="lineNum">    2541 </span>            : // We do have many AutoTArray&lt;E, 0&gt; objects in memory: about 2,000 per tab as
<span class="lineNum">    2542 </span>            : // of May 2014. These are typically not explicitly AutoTArray&lt;E, 0&gt; but rather
<span class="lineNum">    2543 </span>            : // AutoTArray&lt;E, N&gt; for some value N depending on template parameters, in
<span class="lineNum">    2544 </span>            : // generic code.
<span class="lineNum">    2545 </span>            : //
<span class="lineNum">    2546 </span>            : // For that reason, we optimize this case with the below partial specialization,
<span class="lineNum">    2547 </span>            : // which ensures that AutoTArray&lt;E, 0&gt; is just like nsTArray&lt;E&gt;, without any
<span class="lineNum">    2548 </span>            : // inline header overhead.
<span class="lineNum">    2549 </span>            : //
<span class="lineNum">    2550 </span>            : template&lt;class E&gt;
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 : class AutoTArray&lt;E, 0&gt; : public nsTArray&lt;E&gt;</span>
<span class="lineNum">    2552 </span>            : {
<span class="lineNum">    2553 </span>            : };
<span class="lineNum">    2554 </span>            : 
<span class="lineNum">    2555 </span>            : template&lt;class E, size_t N&gt;
<span class="lineNum">    2556 </span>            : struct nsTArray_CopyChooser&lt;AutoTArray&lt;E, N&gt;&gt;
<span class="lineNum">    2557 </span>            : {
<span class="lineNum">    2558 </span>            :   typedef nsTArray_CopyWithConstructors&lt;AutoTArray&lt;E, N&gt;&gt; Type;
<span class="lineNum">    2559 </span>            : };
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span>            : // Span integration
<span class="lineNum">    2562 </span>            : namespace mozilla {
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span>            : template&lt;class ElementType, class TArrayAlloc&gt;
<span class="lineNum">    2565 </span>            : Span&lt;ElementType&gt;
<span class="lineNum">    2566 </span>            : MakeSpan(nsTArray_Impl&lt;ElementType, TArrayAlloc&gt;&amp; aTArray)
<span class="lineNum">    2567 </span>            : {
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :   return aTArray;</span>
<span class="lineNum">    2569 </span>            : }
<span class="lineNum">    2570 </span>            : 
<span class="lineNum">    2571 </span>            : template&lt;class ElementType, class TArrayAlloc&gt;
<span class="lineNum">    2572 </span>            : Span&lt;const ElementType&gt;
<span class="lineNum">    2573 </span>            : MakeSpan(const nsTArray_Impl&lt;ElementType, TArrayAlloc&gt;&amp; aTArray)
<span class="lineNum">    2574 </span>            : {
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :   return aTArray;</span>
<span class="lineNum">    2576 </span>            : }
<span class="lineNum">    2577 </span>            : 
<span class="lineNum">    2578 </span>            : } // namespace mozilla
<span class="lineNum">    2579 </span>            : 
<span class="lineNum">    2580 </span>            : // Assert that AutoTArray doesn't have any extra padding inside.
<span class="lineNum">    2581 </span>            : //
<span class="lineNum">    2582 </span>            : // It's important that the data stored in this auto array takes up a multiple of
<span class="lineNum">    2583 </span>            : // 8 bytes; e.g. AutoTArray&lt;uint32_t, 1&gt; wouldn't work.  Since AutoTArray
<span class="lineNum">    2584 </span>            : // contains a pointer, its size must be a multiple of alignof(void*).  (This is
<span class="lineNum">    2585 </span>            : // because any type may be placed into an array, and there's no padding between
<span class="lineNum">    2586 </span>            : // elements of an array.)  The compiler pads the end of the structure to
<span class="lineNum">    2587 </span>            : // enforce this rule.
<span class="lineNum">    2588 </span>            : //
<span class="lineNum">    2589 </span>            : // If we used AutoTArray&lt;uint32_t, 1&gt; below, this assertion would fail on a
<span class="lineNum">    2590 </span>            : // 64-bit system, where the compiler inserts 4 bytes of padding at the end of
<span class="lineNum">    2591 </span>            : // the auto array to make its size a multiple of alignof(void*) == 8 bytes.
<span class="lineNum">    2592 </span>            : 
<span class="lineNum">    2593 </span>            : static_assert(sizeof(AutoTArray&lt;uint32_t, 2&gt;) ==
<span class="lineNum">    2594 </span>            :               sizeof(void*) + sizeof(nsTArrayHeader) + sizeof(uint32_t) * 2,
<span class="lineNum">    2595 </span>            :               &quot;AutoTArray shouldn't contain any extra padding, &quot;
<span class="lineNum">    2596 </span>            :               &quot;see the comment&quot;);
<span class="lineNum">    2597 </span>            : 
<span class="lineNum">    2598 </span>            : // Definitions of nsTArray_Impl methods
<span class="lineNum">    2599 </span>            : #include &quot;nsTArray-inl.h&quot;
<span class="lineNum">    2600 </span>            : 
<span class="lineNum">    2601 </span>            : #endif  // nsTArray_h__
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13-14-ga5dd952</a></td></tr>
  </table>
  <br>

</body>
</html>
