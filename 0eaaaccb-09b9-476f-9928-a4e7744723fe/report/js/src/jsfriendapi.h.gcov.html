<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - js/src/jsfriendapi.h</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">js/src</a> - jsfriendapi.h<span style="font-size: 80%;"> (source / <a href="jsfriendapi.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">62</td>
            <td class="headerCovTableEntry">166</td>
            <td class="headerCovTableEntryLo">37.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-08-07 16:35:00</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-</a>
<span class="lineNum">       2 </span>            :  * vim: set ts=8 sts=4 et sw=4 tw=99:
<span class="lineNum">       3 </span>            :  * This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #ifndef jsfriendapi_h
<span class="lineNum">       8 </span>            : #define jsfriendapi_h
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &quot;mozilla/Atomics.h&quot;
<span class="lineNum">      11 </span>            : #include &quot;mozilla/Casting.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;mozilla/Maybe.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;mozilla/UniquePtr.h&quot;
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : #include &quot;jsapi.h&quot; // For JSAutoByteString.  See bug 1033916.
<span class="lineNum">      17 </span>            : #include &quot;jspubtd.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;js/CallArgs.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;js/CallNonGenericMethod.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;js/Class.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;js/HeapAPI.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;js/TypeDecls.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;js/Utility.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #ifndef JS_STACK_GROWTH_DIRECTION
<span class="lineNum">      27 </span>            : # ifdef __hppa
<span class="lineNum">      28 </span>            : #  define JS_STACK_GROWTH_DIRECTION (1)
<span class="lineNum">      29 </span>            : # else
<span class="lineNum">      30 </span>            : #  define JS_STACK_GROWTH_DIRECTION (-1)
<span class="lineNum">      31 </span>            : # endif
<span class="lineNum">      32 </span>            : #endif
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #if JS_STACK_GROWTH_DIRECTION &gt; 0
<span class="lineNum">      35 </span>            : # define JS_CHECK_STACK_SIZE(limit, sp) (MOZ_LIKELY((uintptr_t)(sp) &lt; (limit)))
<span class="lineNum">      36 </span>            : #else
<span class="lineNum">      37 </span>            : # define JS_CHECK_STACK_SIZE(limit, sp) (MOZ_LIKELY((uintptr_t)(sp) &gt; (limit)))
<span class="lineNum">      38 </span>            : #endif
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : struct JSErrorFormatString;
<span class="lineNum">      41 </span>            : class JSLinearString;
<span class="lineNum">      42 </span>            : struct JSJitInfo;
<span class="lineNum">      43 </span>            : class JSErrorReport;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : namespace JS {
<span class="lineNum">      46 </span>            : template &lt;class T&gt;
<span class="lineNum">      47 </span>            : class Heap;
<span class="lineNum">      48 </span>            : } /* namespace JS */
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : namespace js {
<span class="lineNum">      51 </span>            : class JS_FRIEND_API(BaseProxyHandler);
<span class="lineNum">      52 </span>            : class InterpreterFrame;
<span class="lineNum">      53 </span>            : } /* namespace js */
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">      56 </span>            : JS_SetGrayGCRootsTracer(JSContext* cx, JSTraceDataOp traceOp, void* data);
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">      59 </span>            : JS_FindCompilationScope(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : extern JS_FRIEND_API(JSFunction*)
<span class="lineNum">      62 </span>            : JS_GetObjectFunction(JSObject* obj);
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">      65 </span>            : JS_SplicePrototype(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">      68 </span>            : JS_NewObjectWithUniqueType(JSContext* cx, const JSClass* clasp, JS::HandleObject proto);
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : /**
<span class="lineNum">      71 </span>            :  * Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but
<span class="lineNum">      72 </span>            :  * without invoking the metadata callback on it.  This allows creation of
<span class="lineNum">      73 </span>            :  * internal bookkeeping objects that are guaranteed to not have metadata
<span class="lineNum">      74 </span>            :  * attached to them.
<span class="lineNum">      75 </span>            :  */
<span class="lineNum">      76 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">      77 </span>            : JS_NewObjectWithoutMetadata(JSContext* cx, const JSClass* clasp, JS::Handle&lt;JSObject*&gt; proto);
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">      80 </span>            : JS_NondeterministicGetWeakMapKeys(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject ret);
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">      83 </span>            : JS_NondeterministicGetWeakSetKeys(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject ret);
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : // Raw JSScript* because this needs to be callable from a signal handler.
<span class="lineNum">      86 </span>            : extern JS_FRIEND_API(unsigned)
<span class="lineNum">      87 </span>            : JS_PCToLineNumber(JSScript* script, jsbytecode* pc, unsigned* columnp = nullptr);
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : /**
<span class="lineNum">      90 </span>            :  * Determine whether the given object is backed by a DeadObjectProxy.
<span class="lineNum">      91 </span>            :  *
<span class="lineNum">      92 </span>            :  * Such objects hold no other objects (they have no outgoing reference edges)
<span class="lineNum">      93 </span>            :  * and will throw if you touch them (e.g. by reading/writing a property).
<span class="lineNum">      94 </span>            :  */
<span class="lineNum">      95 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">      96 </span>            : JS_IsDeadWrapper(JSObject* obj);
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /**
<span class="lineNum">      99 </span>            :  * Creates a new dead wrapper object in the given scope. To be used when
<span class="lineNum">     100 </span>            :  * attempting to wrap objects from scopes which are already dead.
<span class="lineNum">     101 </span>            :  *
<span class="lineNum">     102 </span>            :  * If origObject is passed, it must be an proxy object, and will be
<span class="lineNum">     103 </span>            :  * used to determine the characteristics of the new dead wrapper.
<span class="lineNum">     104 </span>            :  */
<span class="lineNum">     105 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">     106 </span>            : JS_NewDeadWrapper(JSContext* cx, JSObject* origObject = nullptr);
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : /**
<span class="lineNum">     109 </span>            :  * Determine whether the given object is a ScriptSourceObject.
<span class="lineNum">     110 </span>            :  */
<span class="lineNum">     111 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     112 </span>            : JS_IsScriptSourceObject(JSObject* obj);
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : /*
<span class="lineNum">     115 </span>            :  * Used by the cycle collector to trace through a shape or object group and
<span class="lineNum">     116 </span>            :  * all cycle-participating data it reaches, using bounded stack space.
<span class="lineNum">     117 </span>            :  */
<span class="lineNum">     118 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     119 </span>            : JS_TraceShapeCycleCollectorChildren(JS::CallbackTracer* trc, JS::GCCellPtr shape);
<span class="lineNum">     120 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     121 </span>            : JS_TraceObjectGroupCycleCollectorChildren(JS::CallbackTracer* trc, JS::GCCellPtr group);
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /*
<span class="lineNum">     124 </span>            :  * Telemetry reasons passed to the accumulate telemetry callback.
<span class="lineNum">     125 </span>            :  *
<span class="lineNum">     126 </span>            :  * It's OK for these enum values to change as they will be mapped to a fixed
<span class="lineNum">     127 </span>            :  * member of the mozilla::Telemetry::HistogramID enum by the callback.
<span class="lineNum">     128 </span>            :  */
<span class="lineNum">     129 </span>            : enum {
<span class="lineNum">     130 </span>            :     JS_TELEMETRY_GC_REASON,
<span class="lineNum">     131 </span>            :     JS_TELEMETRY_GC_IS_ZONE_GC,
<span class="lineNum">     132 </span>            :     JS_TELEMETRY_GC_MS,
<span class="lineNum">     133 </span>            :     JS_TELEMETRY_GC_BUDGET_MS,
<span class="lineNum">     134 </span>            :     JS_TELEMETRY_GC_BUDGET_OVERRUN,
<span class="lineNum">     135 </span>            :     JS_TELEMETRY_GC_ANIMATION_MS,
<span class="lineNum">     136 </span>            :     JS_TELEMETRY_GC_MAX_PAUSE_MS_2,
<span class="lineNum">     137 </span>            :     JS_TELEMETRY_GC_MARK_MS,
<span class="lineNum">     138 </span>            :     JS_TELEMETRY_GC_SWEEP_MS,
<span class="lineNum">     139 </span>            :     JS_TELEMETRY_GC_COMPACT_MS,
<span class="lineNum">     140 </span>            :     JS_TELEMETRY_GC_MARK_ROOTS_MS,
<span class="lineNum">     141 </span>            :     JS_TELEMETRY_GC_MARK_GRAY_MS,
<span class="lineNum">     142 </span>            :     JS_TELEMETRY_GC_SLICE_MS,
<span class="lineNum">     143 </span>            :     JS_TELEMETRY_GC_SLOW_PHASE,
<span class="lineNum">     144 </span>            :     JS_TELEMETRY_GC_SLOW_TASK,
<span class="lineNum">     145 </span>            :     JS_TELEMETRY_GC_MMU_50,
<span class="lineNum">     146 </span>            :     JS_TELEMETRY_GC_RESET,
<span class="lineNum">     147 </span>            :     JS_TELEMETRY_GC_RESET_REASON,
<span class="lineNum">     148 </span>            :     JS_TELEMETRY_GC_INCREMENTAL_DISABLED,
<span class="lineNum">     149 </span>            :     JS_TELEMETRY_GC_NON_INCREMENTAL,
<span class="lineNum">     150 </span>            :     JS_TELEMETRY_GC_NON_INCREMENTAL_REASON,
<span class="lineNum">     151 </span>            :     JS_TELEMETRY_GC_SCC_SWEEP_TOTAL_MS,
<span class="lineNum">     152 </span>            :     JS_TELEMETRY_GC_SCC_SWEEP_MAX_PAUSE_MS,
<span class="lineNum">     153 </span>            :     JS_TELEMETRY_GC_MINOR_REASON,
<span class="lineNum">     154 </span>            :     JS_TELEMETRY_GC_MINOR_REASON_LONG,
<span class="lineNum">     155 </span>            :     JS_TELEMETRY_GC_MINOR_US,
<span class="lineNum">     156 </span>            :     JS_TELEMETRY_GC_NURSERY_BYTES,
<span class="lineNum">     157 </span>            :     JS_TELEMETRY_GC_PRETENURE_COUNT,
<span class="lineNum">     158 </span>            :     JS_TELEMETRY_PRIVILEGED_PARSER_COMPILE_LAZY_AFTER_MS,
<span class="lineNum">     159 </span>            :     JS_TELEMETRY_WEB_PARSER_COMPILE_LAZY_AFTER_MS,
<span class="lineNum">     160 </span>            :     JS_TELEMETRY_END
<span class="lineNum">     161 </span>            : };
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : typedef void
<span class="lineNum">     164 </span>            : (*JSAccumulateTelemetryDataCallback)(int id, uint32_t sample, const char* key);
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     167 </span>            : JS_SetAccumulateTelemetryCallback(JSContext* cx, JSAccumulateTelemetryDataCallback callback);
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : /*
<span class="lineNum">     170 </span>            :  * Use counter names passed to the accumulate use counter callback.
<span class="lineNum">     171 </span>            :  *
<span class="lineNum">     172 </span>            :  * It's OK to for these enum values to change as they will be mapped to a
<span class="lineNum">     173 </span>            :  * fixed member of the mozilla::UseCounter enum by the callback.
<span class="lineNum">     174 </span>            :  */
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : enum class JSUseCounter {
<span class="lineNum">     177 </span>            :     ASMJS,
<span class="lineNum">     178 </span>            :     WASM
<span class="lineNum">     179 </span>            : };
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : typedef void
<span class="lineNum">     182 </span>            : (*JSSetUseCounterCallback)(JSObject* obj, JSUseCounter counter);
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     185 </span>            : JS_SetSetUseCounterCallback(JSContext* cx, JSSetUseCounterCallback callback);
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : extern JS_FRIEND_API(JSPrincipals*)
<span class="lineNum">     188 </span>            : JS_GetCompartmentPrincipals(JS::Compartment* compartment);
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            : extern JS_FRIEND_API(JSPrincipals*)
<span class="lineNum">     191 </span>            : JS_GetScriptPrincipals(JSScript* script);
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : namespace js {
<span class="lineNum">     194 </span>            : extern JS_FRIEND_API(JS::Realm*)
<span class="lineNum">     195 </span>            : GetScriptRealm(JSScript* script);
<span class="lineNum">     196 </span>            : } /* namespace js */
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     199 </span>            : JS_ScriptHasMutedErrors(JSScript* script);
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">     202 </span>            : JS_CloneObject(JSContext* cx, JS::HandleObject obj, JS::HandleObject proto);
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : /**
<span class="lineNum">     205 </span>            :  * Copy the own properties of src to dst in a fast way.  src and dst must both
<span class="lineNum">     206 </span>            :  * be native and must be in the compartment of cx.  They must have the same
<span class="lineNum">     207 </span>            :  * class, the same parent, and the same prototype.  Class reserved slots will
<span class="lineNum">     208 </span>            :  * NOT be copied.
<span class="lineNum">     209 </span>            :  *
<span class="lineNum">     210 </span>            :  * dst must not have any properties on it before this function is called.
<span class="lineNum">     211 </span>            :  *
<span class="lineNum">     212 </span>            :  * src must have been allocated via JS_NewObjectWithoutMetadata so that we can
<span class="lineNum">     213 </span>            :  * be sure it has no metadata that needs copying to dst.  This also means that
<span class="lineNum">     214 </span>            :  * dst needs to have the compartment global as its parent.  This function will
<span class="lineNum">     215 </span>            :  * preserve the existing metadata on dst, if any.
<span class="lineNum">     216 </span>            :  */
<span class="lineNum">     217 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     218 </span>            : JS_InitializePropertiesFromCompatibleNativeObject(JSContext* cx,
<span class="lineNum">     219 </span>            :                                                   JS::HandleObject dst,
<span class="lineNum">     220 </span>            :                                                   JS::HandleObject src);
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            : namespace js {
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     225 </span>            : GetBuiltinClass(JSContext* cx, JS::HandleObject obj, ESClass* cls);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : JS_FRIEND_API(const char*)
<span class="lineNum">     228 </span>            : ObjectClassName(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     231 </span>            : ReportOverRecursed(JSContext* maybecx);
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     234 </span>            : AddRawValueRoot(JSContext* cx, JS::Value* vp, const char* name);
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     237 </span>            : RemoveRawValueRoot(JSContext* cx, JS::Value* vp);
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : JS_FRIEND_API(JSAtom*)
<span class="lineNum">     240 </span>            : GetPropertyNameFromPC(JSScript* script, jsbytecode* pc);
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : #ifdef JS_DEBUG
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : /*
<span class="lineNum">     245 </span>            :  * Routines to print out values during debugging. These are FRIEND_API to help
<span class="lineNum">     246 </span>            :  * the debugger find them and to support temporarily hacking js::Dump* calls
<span class="lineNum">     247 </span>            :  * into other code. Note that there are overloads that do not require the FILE*
<span class="lineNum">     248 </span>            :  * parameter, which will default to stderr.
<span class="lineNum">     249 </span>            :  */
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     252 </span>            : DumpString(JSString* str, FILE* fp);
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     255 </span>            : DumpAtom(JSAtom* atom, FILE* fp);
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     258 </span>            : DumpObject(JSObject* obj, FILE* fp);
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     261 </span>            : DumpChars(const char16_t* s, size_t n, FILE* fp);
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     264 </span>            : DumpValue(const JS::Value&amp; val, FILE* fp);
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     267 </span>            : DumpId(jsid id, FILE* fp);
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     270 </span>            : DumpInterpreterFrame(JSContext* cx, FILE* fp, InterpreterFrame* start = nullptr);
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     273 </span>            : DumpPC(JSContext* cx, FILE* fp);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     276 </span>            : DumpScript(JSContext* cx, JSScript* scriptArg, FILE* fp);
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            : // Versions for use directly in a debugger (default parameters are not handled
<span class="lineNum">     279 </span>            : // well in gdb; built-in handles like stderr are not handled well in lldb.)
<span class="lineNum">     280 </span>            : extern JS_FRIEND_API(void) DumpString(JSString* str);
<span class="lineNum">     281 </span>            : extern JS_FRIEND_API(void) DumpAtom(JSAtom* atom);
<span class="lineNum">     282 </span>            : extern JS_FRIEND_API(void) DumpObject(JSObject* obj);
<span class="lineNum">     283 </span>            : extern JS_FRIEND_API(void) DumpChars(const char16_t* s, size_t n);
<span class="lineNum">     284 </span>            : extern JS_FRIEND_API(void) DumpValue(const JS::Value&amp; val);
<span class="lineNum">     285 </span>            : extern JS_FRIEND_API(void) DumpId(jsid id);
<span class="lineNum">     286 </span>            : extern JS_FRIEND_API(void) DumpInterpreterFrame(JSContext* cx, InterpreterFrame* start = nullptr);
<span class="lineNum">     287 </span>            : extern JS_FRIEND_API(bool) DumpPC(JSContext* cx);
<span class="lineNum">     288 </span>            : extern JS_FRIEND_API(bool) DumpScript(JSContext* cx, JSScript* scriptArg);
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : #endif
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     293 </span>            : DumpBacktrace(JSContext* cx, FILE* fp);
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     296 </span>            : DumpBacktrace(JSContext* cx);
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : } // namespace js
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : namespace JS {
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : /** Exposed for DumpJSStack */
<span class="lineNum">     303 </span>            : extern JS_FRIEND_API(JS::UniqueChars)
<span class="lineNum">     304 </span>            : FormatStackDump(JSContext* cx, JS::UniqueChars&amp;&amp; buf, bool showArgs, bool showLocals,
<span class="lineNum">     305 </span>            :                 bool showThisProps);
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : /**
<span class="lineNum">     308 </span>            :  * Set all of the uninitialized lexicals on an object to undefined. Return
<span class="lineNum">     309 </span>            :  * true if any lexicals were initialized and false otherwise.
<span class="lineNum">     310 </span>            :  * */
<span class="lineNum">     311 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     312 </span>            : ForceLexicalInitialization(JSContext *cx, HandleObject obj);
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : /**
<span class="lineNum">     315 </span>            :  * Whether we are poisoning unused/released data for error detection. Governed
<span class="lineNum">     316 </span>            :  * by the JS_GC_POISONING #ifdef as well as the $JSGC_DISABLE_POISONING
<span class="lineNum">     317 </span>            :  * environment variable.
<span class="lineNum">     318 </span>            :  */
<span class="lineNum">     319 </span>            : extern JS_FRIEND_API(int)
<span class="lineNum">     320 </span>            : IsGCPoisoning();
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : extern JS_FRIEND_API(JSPrincipals*)
<span class="lineNum">     323 </span>            : GetRealmPrincipals(JS::Realm* realm);
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     326 </span>            : SetRealmPrincipals(JS::Realm* realm, JSPrincipals* principals);
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     329 </span>            : GetIsSecureContext(JS::Realm* realm);
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : } // namespace JS
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : /**
<span class="lineNum">     334 </span>            :  * Copies all own properties from |obj| to |target|. |obj| must be a &quot;native&quot;
<span class="lineNum">     335 </span>            :  * object (that is to say, normal-ish - not an Array or a Proxy).
<span class="lineNum">     336 </span>            :  *
<span class="lineNum">     337 </span>            :  * This function immediately enters a compartment, and does not impose any
<span class="lineNum">     338 </span>            :  * restrictions on the compartment of |cx|.
<span class="lineNum">     339 </span>            :  */
<span class="lineNum">     340 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     341 </span>            : JS_CopyPropertiesFrom(JSContext* cx, JS::HandleObject target, JS::HandleObject obj);
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : /*
<span class="lineNum">     344 </span>            :  * Single-property version of the above. This function asserts that an |own|
<span class="lineNum">     345 </span>            :  * property of the given name exists on |obj|.
<span class="lineNum">     346 </span>            :  *
<span class="lineNum">     347 </span>            :  * On entry, |cx| must be same-compartment with |obj|.
<span class="lineNum">     348 </span>            :  *
<span class="lineNum">     349 </span>            :  * The copyBehavior argument controls what happens with
<span class="lineNum">     350 </span>            :  * non-configurable properties.
<span class="lineNum">     351 </span>            :  */
<span class="lineNum">     352 </span>            : typedef enum  {
<span class="lineNum">     353 </span>            :     MakeNonConfigurableIntoConfigurable,
<span class="lineNum">     354 </span>            :     CopyNonConfigurableAsIs
<span class="lineNum">     355 </span>            : } PropertyCopyBehavior;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     358 </span>            : JS_CopyPropertyFrom(JSContext* cx, JS::HandleId id, JS::HandleObject target,
<span class="lineNum">     359 </span>            :                     JS::HandleObject obj,
<span class="lineNum">     360 </span>            :                     PropertyCopyBehavior copyBehavior = CopyNonConfigurableAsIs);
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     363 </span>            : JS_WrapPropertyDescriptor(JSContext* cx, JS::MutableHandle&lt;JS::PropertyDescriptor&gt; desc);
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : struct JSFunctionSpecWithHelp {
<span class="lineNum">     366 </span>            :     const char*     name;
<span class="lineNum">     367 </span>            :     JSNative        call;
<span class="lineNum">     368 </span>            :     uint16_t        nargs;
<span class="lineNum">     369 </span>            :     uint16_t        flags;
<span class="lineNum">     370 </span>            :     const JSJitInfo* jitInfo;
<span class="lineNum">     371 </span>            :     const char*     usage;
<span class="lineNum">     372 </span>            :     const char*     help;
<span class="lineNum">     373 </span>            : };
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : #define JS_FN_HELP(name,call,nargs,flags,usage,help)                          \
<span class="lineNum">     376 </span>            :     {name, call, nargs, (flags) | JSPROP_ENUMERATE, nullptr, usage, help}
<span class="lineNum">     377 </span>            : #define JS_INLINABLE_FN_HELP(name,call,nargs,flags,native,usage,help)         \
<span class="lineNum">     378 </span>            :     {name, call, nargs, (flags) | JSPROP_ENUMERATE, &amp;js::jit::JitInfo_##native,\
<span class="lineNum">     379 </span>            :      usage, help}
<span class="lineNum">     380 </span>            : #define JS_FS_HELP_END                                                        \
<span class="lineNum">     381 </span>            :     {nullptr, nullptr, 0, 0, nullptr, nullptr}
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     384 </span>            : JS_DefineFunctionsWithHelp(JSContext* cx, JS::HandleObject obj, const JSFunctionSpecWithHelp* fs);
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : namespace js {
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : /**
<span class="lineNum">     389 </span>            :  * A class of objects that return source code on demand.
<span class="lineNum">     390 </span>            :  *
<span class="lineNum">     391 </span>            :  * When code is compiled with setSourceIsLazy(true), SpiderMonkey doesn't
<span class="lineNum">     392 </span>            :  * retain the source code (and doesn't do lazy bytecode generation). If we ever
<span class="lineNum">     393 </span>            :  * need the source code, say, in response to a call to Function.prototype.
<span class="lineNum">     394 </span>            :  * toSource or Debugger.Source.prototype.text, then we call the 'load' member
<span class="lineNum">     395 </span>            :  * function of the instance of this class that has hopefully been registered
<span class="lineNum">     396 </span>            :  * with the runtime, passing the code's URL, and hope that it will be able to
<span class="lineNum">     397 </span>            :  * find the source.
<span class="lineNum">     398 </span>            :  */
<span class="lineNum">     399 </span>            : class SourceHook {
<span class="lineNum">     400 </span>            :   public:
<span class="lineNum">     401 </span>            :     virtual ~SourceHook() { }
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :     /**
<span class="lineNum">     404 </span>            :      * Set |*src| and |*length| to refer to the source code for |filename|.
<span class="lineNum">     405 </span>            :      * On success, the caller owns the buffer to which |*src| points, and
<span class="lineNum">     406 </span>            :      * should use JS_free to free it.
<span class="lineNum">     407 </span>            :      */
<span class="lineNum">     408 </span>            :     virtual bool load(JSContext* cx, const char* filename, char16_t** src, size_t* length) = 0;
<span class="lineNum">     409 </span>            : };
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : /**
<span class="lineNum">     412 </span>            :  * Have |cx| use |hook| to retrieve lazily-retrieved source code. See the
<span class="lineNum">     413 </span>            :  * comments for SourceHook. The context takes ownership of the hook, and
<span class="lineNum">     414 </span>            :  * will delete it when the context itself is deleted, or when a new hook is
<span class="lineNum">     415 </span>            :  * set.
<span class="lineNum">     416 </span>            :  */
<span class="lineNum">     417 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     418 </span>            : SetSourceHook(JSContext* cx, mozilla::UniquePtr&lt;SourceHook&gt; hook);
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : /** Remove |cx|'s source hook, and return it. The caller now owns the hook. */
<span class="lineNum">     421 </span>            : extern JS_FRIEND_API(mozilla::UniquePtr&lt;SourceHook&gt;)
<span class="lineNum">     422 </span>            : ForgetSourceHook(JSContext* cx);
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            : /**
<span class="lineNum">     425 </span>            :  * Use the runtime's internal handling of job queues for Promise jobs.
<span class="lineNum">     426 </span>            :  *
<span class="lineNum">     427 </span>            :  * Most embeddings, notably web browsers, will have their own task scheduling
<span class="lineNum">     428 </span>            :  * systems and need to integrate handling of Promise jobs into that, so they
<span class="lineNum">     429 </span>            :  * will want to manage job queues themselves. For basic embeddings such as the
<span class="lineNum">     430 </span>            :  * JS shell that don't have an event loop of their own, it's easier to have
<span class="lineNum">     431 </span>            :  * SpiderMonkey handle job queues internally.
<span class="lineNum">     432 </span>            :  *
<span class="lineNum">     433 </span>            :  * Note that the embedding still has to trigger processing of job queues at
<span class="lineNum">     434 </span>            :  * right time(s), such as after evaluation of a script has run to completion.
<span class="lineNum">     435 </span>            :  */
<span class="lineNum">     436 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     437 </span>            : UseInternalJobQueues(JSContext* cx);
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : /**
<span class="lineNum">     440 </span>            :  * Enqueue |job| on the internal job queue.
<span class="lineNum">     441 </span>            :  *
<span class="lineNum">     442 </span>            :  * This is useful in tests for creating situations where a call occurs with no
<span class="lineNum">     443 </span>            :  * other JavaScript on the stack.
<span class="lineNum">     444 </span>            :  */
<span class="lineNum">     445 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     446 </span>            : EnqueueJob(JSContext* cx, JS::HandleObject job);
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            : /**
<span class="lineNum">     449 </span>            :  * Instruct the runtime to stop draining the internal job queue.
<span class="lineNum">     450 </span>            :  *
<span class="lineNum">     451 </span>            :  * Useful if the embedding is in the process of quitting in reaction to a
<span class="lineNum">     452 </span>            :  * builtin being called, or if it wants to resume executing jobs later on.
<span class="lineNum">     453 </span>            :  */
<span class="lineNum">     454 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     455 </span>            : StopDrainingJobQueue(JSContext* cx);
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     458 </span>            : RunJobs(JSContext* cx);
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : extern JS_FRIEND_API(JS::Zone*)
<span class="lineNum">     461 </span>            : GetRealmZone(JS::Realm* realm);
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : typedef bool
<span class="lineNum">     464 </span>            : (* PreserveWrapperCallback)(JSContext* cx, JSObject* obj);
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : typedef enum  {
<span class="lineNum">     467 </span>            :     CollectNurseryBeforeDump,
<span class="lineNum">     468 </span>            :     IgnoreNurseryObjects
<span class="lineNum">     469 </span>            : } DumpHeapNurseryBehaviour;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :  /**
<span class="lineNum">     472 </span>            :   * Dump the complete object graph of heap-allocated things.
<span class="lineNum">     473 </span>            :   * fp is the file for the dump output.
<span class="lineNum">     474 </span>            :   */
<span class="lineNum">     475 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     476 </span>            : DumpHeap(JSContext* cx, FILE* fp, DumpHeapNurseryBehaviour nurseryBehaviour);
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : #ifdef JS_OLD_GETTER_SETTER_METHODS
<span class="lineNum">     479 </span>            : JS_FRIEND_API(bool) obj_defineGetter(JSContext* cx, unsigned argc, JS::Value* vp);
<span class="lineNum">     480 </span>            : JS_FRIEND_API(bool) obj_defineSetter(JSContext* cx, unsigned argc, JS::Value* vp);
<span class="lineNum">     481 </span>            : #endif
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     484 </span>            : IsSystemRealm(JS::Realm* realm);
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     487 </span>            : IsSystemCompartment(JS::Compartment* comp);
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     490 </span>            : IsSystemZone(JS::Zone* zone);
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     493 </span>            : IsAtomsZone(JS::Zone* zone);
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span>            : struct WeakMapTracer
<span class="lineNum">     496 </span>            : {
<span class="lineNum">     497 </span>            :     JSRuntime* runtime;
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     explicit WeakMapTracer(JSRuntime* rt) : runtime(rt) {}</span>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :     // Weak map tracer callback, called once for every binding of every
<span class="lineNum">     502 </span>            :     // weak map that was live at the time of the last garbage collection.
<span class="lineNum">     503 </span>            :     //
<span class="lineNum">     504 </span>            :     // m will be nullptr if the weak map is not contained in a JS Object.
<span class="lineNum">     505 </span>            :     //
<span class="lineNum">     506 </span>            :     // The callback should not GC (and will assert in a debug build if it does so.)
<span class="lineNum">     507 </span>            :     virtual void trace(JSObject* m, JS::GCCellPtr key, JS::GCCellPtr value) = 0;
<span class="lineNum">     508 </span>            : };
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     511 </span>            : TraceWeakMaps(WeakMapTracer* trc);
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     514 </span>            : AreGCGrayBitsValid(JSRuntime* rt);
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     517 </span>            : ZoneGlobalsAreAllGray(JS::Zone* zone);
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     520 </span>            : IsObjectZoneSweepingOrCompacting(JSObject* obj);
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : typedef void
<span class="lineNum">     523 </span>            : (*GCThingCallback)(void* closure, JS::GCCellPtr thing);
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     526 </span>            : VisitGrayWrapperTargets(JS::Zone* zone, GCThingCallback callback, void* closure);
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">     529 </span>            : GetWeakmapKeyDelegate(JSObject* key);
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : /**
<span class="lineNum">     532 </span>            :  * Invoke cellCallback on every gray JSObject in the given zone.
<span class="lineNum">     533 </span>            :  */
<span class="lineNum">     534 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     535 </span>            : IterateGrayObjects(JS::Zone* zone, GCThingCallback cellCallback, void* data);
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            : /**
<span class="lineNum">     538 </span>            :  * Invoke cellCallback on every gray JSObject in the given zone while cycle
<span class="lineNum">     539 </span>            :  * collection is in progress.
<span class="lineNum">     540 </span>            :  */
<span class="lineNum">     541 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">     542 </span>            : IterateGrayObjectsUnderCC(JS::Zone* zone, GCThingCallback cellCallback, void* data);
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            : #if defined(JS_GC_ZEAL) || defined(DEBUG)
<span class="lineNum">     545 </span>            : // Trace the heap and check there are no black to gray edges. These are
<span class="lineNum">     546 </span>            : // not allowed since the cycle collector could throw away the gray thing and
<span class="lineNum">     547 </span>            : // leave a dangling pointer.
<span class="lineNum">     548 </span>            : //
<span class="lineNum">     549 </span>            : // This doesn't trace weak maps as these are handled separately.
<span class="lineNum">     550 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">     551 </span>            : CheckGrayMarkingState(JSRuntime* rt);
<span class="lineNum">     552 </span>            : #endif
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            : #ifdef JS_HAS_CTYPES
<span class="lineNum">     555 </span>            : extern JS_FRIEND_API(size_t)
<span class="lineNum">     556 </span>            : SizeOfDataIfCDataObject(mozilla::MallocSizeOf mallocSizeOf, JSObject* obj);
<span class="lineNum">     557 </span>            : #endif
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            : // Note: this returns nullptr iff |zone| is the atoms zone.
<span class="lineNum">     560 </span>            : extern JS_FRIEND_API(JS::Realm*)
<span class="lineNum">     561 </span>            : GetAnyRealmInZone(JS::Zone* zone);
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span>            : /*
<span class="lineNum">     564 </span>            :  * Shadow declarations of JS internal structures, for access by inline access
<span class="lineNum">     565 </span>            :  * functions below. Do not use these structures in any other way. When adding
<span class="lineNum">     566 </span>            :  * new fields for access by inline methods, make sure to add static asserts to
<span class="lineNum">     567 </span>            :  * the original header file to ensure that offsets are consistent.
<span class="lineNum">     568 </span>            :  */
<span class="lineNum">     569 </span>            : namespace shadow {
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            : struct ObjectGroup {
<span class="lineNum">     572 </span>            :     const Class* clasp;
<span class="lineNum">     573 </span>            :     JSObject* proto;
<span class="lineNum">     574 </span>            :     JS::Realm* realm;
<span class="lineNum">     575 </span>            : };
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : struct BaseShape {
<span class="lineNum">     578 </span>            :     const js::Class* clasp_;
<span class="lineNum">     579 </span>            :     JSObject* parent;
<span class="lineNum">     580 </span>            : };
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            : class Shape {
<span class="lineNum">     583 </span>            : public:
<span class="lineNum">     584 </span>            :     shadow::BaseShape* base;
<span class="lineNum">     585 </span>            :     jsid              _1;
<span class="lineNum">     586 </span>            :     uint32_t          immutableFlags;
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :     static const uint32_t FIXED_SLOTS_SHIFT = 24;
<span class="lineNum">     589 </span>            :     static const uint32_t FIXED_SLOTS_MASK = 0x1f &lt;&lt; FIXED_SLOTS_SHIFT;
<span class="lineNum">     590 </span>            : };
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            : /**
<span class="lineNum">     593 </span>            :  * This layout is shared by all native objects. For non-native objects, the
<span class="lineNum">     594 </span>            :  * group may always be accessed safely, and other members may be as well,
<span class="lineNum">     595 </span>            :  * depending on the object's specific layout.
<span class="lineNum">     596 </span>            :  */
<span class="lineNum">     597 </span>            : struct Object {
<span class="lineNum">     598 </span>            :     shadow::ObjectGroup* group;
<span class="lineNum">     599 </span>            :     shadow::Shape*      shape;
<span class="lineNum">     600 </span>            :     JS::Value*          slots;
<span class="lineNum">     601 </span>            :     void*               _1;
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :     static const size_t MAX_FIXED_SLOTS = 16;
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :     size_t numFixedSlots() const {
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :         return (shape-&gt;immutableFlags &amp; Shape::FIXED_SLOTS_MASK) &gt;&gt; Shape::FIXED_SLOTS_SHIFT;</span>
<span class="lineNum">     607 </span>            :     }
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :     JS::Value* fixedSlots() const {
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :         return (JS::Value*)(uintptr_t(this) + sizeof(shadow::Object));</span>
<span class="lineNum">     611 </span>            :     }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            :     JS::Value&amp; slotRef(size_t slot) const {
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         size_t nfixed = numFixedSlots();</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :         if (slot &lt; nfixed)</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :             return fixedSlots()[slot];</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :         return slots[slot - nfixed];</span>
<span class="lineNum">     618 </span>            :     }
<span class="lineNum">     619 </span>            : };
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : struct Function {
<span class="lineNum">     622 </span>            :     Object base;
<span class="lineNum">     623 </span>            :     uint16_t nargs;
<span class="lineNum">     624 </span>            :     uint16_t flags;
<span class="lineNum">     625 </span>            :     /* Used only for natives */
<span class="lineNum">     626 </span>            :     JSNative native;
<span class="lineNum">     627 </span>            :     const JSJitInfo* jitinfo;
<span class="lineNum">     628 </span>            :     void* _1;
<span class="lineNum">     629 </span>            : };
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            : } /* namespace shadow */
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            : // This is equal to |&amp;JSObject::class_|.  Use it in places where you don't want
<span class="lineNum">     634 </span>            : // to #include vm/JSObject.h.
<span class="lineNum">     635 </span>            : extern JS_FRIEND_DATA(const js::Class* const) ObjectClassPtr;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : inline const js::Class*
<span class="lineNum">     638 </span>            : GetObjectClass(const JSObject* obj)
<span class="lineNum">     639 </span>            : {
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;const shadow::Object*&gt;(obj)-&gt;group-&gt;clasp;</span>
<span class="lineNum">     641 </span>            : }
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            : inline const JSClass*
<span class="lineNum">     644 </span>            : GetObjectJSClass(JSObject* obj)
<span class="lineNum">     645 </span>            : {
<span class="lineNum">     646 </span>            :     return js::Jsvalify(GetObjectClass(obj));
<span class="lineNum">     647 </span>            : }
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            : JS_FRIEND_API(const Class*)
<span class="lineNum">     650 </span>            : ProtoKeyToClass(JSProtoKey key);
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : // Returns the key for the class inherited by a given standard class (that
<span class="lineNum">     653 </span>            : // is to say, the prototype of this standard class's prototype).
<span class="lineNum">     654 </span>            : //
<span class="lineNum">     655 </span>            : // You must be sure that this corresponds to a standard class with a cached
<span class="lineNum">     656 </span>            : // JSProtoKey before calling this function. In general |key| will match the
<span class="lineNum">     657 </span>            : // cached proto key, except in cases where multiple JSProtoKeys share a
<span class="lineNum">     658 </span>            : // JSClass.
<span class="lineNum">     659 </span>            : inline JSProtoKey
<span class="lineNum">     660 </span><span class="lineCov">          2 : InheritanceProtoKeyForStandardClass(JSProtoKey key)</span>
<span class="lineNum">     661 </span>            : {
<span class="lineNum">     662 </span>            :     // [Object] has nothing to inherit from.
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :     if (key == JSProto_Object)</span>
<span class="lineNum">     664 </span>            :         return JSProto_Null;
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            :     // If we're ClassSpec defined return the proto key from that
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :     if (ProtoKeyToClass(key)-&gt;specDefined())</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         return ProtoKeyToClass(key)-&gt;specInheritanceProtoKey();</span>
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :     // Otherwise, we inherit [Object].
<span class="lineNum">     671 </span>            :     return JSProto_Object;
<span class="lineNum">     672 </span>            : }
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     675 </span>            : IsFunctionObject(JSObject* obj);
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     678 </span>            : IsCrossCompartmentWrapper(const JSObject* obj);
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : static MOZ_ALWAYS_INLINE JS::Compartment*
<span class="lineNum">     681 </span>            : GetObjectCompartment(JSObject* obj)
<span class="lineNum">     682 </span>            : {
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :     JS::Realm* realm = reinterpret_cast&lt;shadow::Object*&gt;(obj)-&gt;group-&gt;realm;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     return JS::GetCompartmentForRealm(realm);</span>
<span class="lineNum">     685 </span>            : }
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : // CrossCompartmentWrappers are shared by all realms within the compartment, so
<span class="lineNum">     688 </span>            : // getting a wrapper's realm usually doesn't make sense.
<span class="lineNum">     689 </span>            : static MOZ_ALWAYS_INLINE JS::Realm*
<span class="lineNum">     690 </span>            : GetNonCCWObjectRealm(JSObject* obj)
<span class="lineNum">     691 </span>            : {
<span class="lineNum">     692 </span>            :     MOZ_ASSERT(!js::IsCrossCompartmentWrapper(obj));
<span class="lineNum">     693 </span>            :     return reinterpret_cast&lt;shadow::Object*&gt;(obj)-&gt;group-&gt;realm;
<span class="lineNum">     694 </span>            : }
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : JS_FRIEND_API(JSObject*)
<span class="lineNum">     697 </span>            : GetGlobalForObjectCrossCompartment(JSObject* obj);
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : JS_FRIEND_API(JSObject*)
<span class="lineNum">     700 </span>            : GetPrototypeNoProxy(JSObject* obj);
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     703 </span>            : AssertSameCompartment(JSContext* cx, JSObject* obj);
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     706 </span>            : AssertSameCompartment(JSContext* cx, JS::HandleValue v);
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : #ifdef JS_DEBUG
<span class="lineNum">     709 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     710 </span>            : AssertSameCompartment(JSObject* objA, JSObject* objB);
<span class="lineNum">     711 </span>            : #else
<span class="lineNum">     712 </span>            : inline void AssertSameCompartment(JSObject* objA, JSObject* objB) {}
<span class="lineNum">     713 </span>            : #endif
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     716 </span>            : NotifyAnimationActivity(JSObject* obj);
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            : JS_FRIEND_API(JSFunction*)
<span class="lineNum">     719 </span>            : DefineFunctionWithReserved(JSContext* cx, JSObject* obj, const char* name, JSNative call,
<span class="lineNum">     720 </span>            :                            unsigned nargs, unsigned attrs);
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            : JS_FRIEND_API(JSFunction*)
<span class="lineNum">     723 </span>            : NewFunctionWithReserved(JSContext* cx, JSNative call, unsigned nargs, unsigned flags,
<span class="lineNum">     724 </span>            :                         const char* name);
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            : JS_FRIEND_API(JSFunction*)
<span class="lineNum">     727 </span>            : NewFunctionByIdWithReserved(JSContext* cx, JSNative native, unsigned nargs, unsigned flags,
<span class="lineNum">     728 </span>            :                             jsid id);
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            : JS_FRIEND_API(const JS::Value&amp;)
<span class="lineNum">     731 </span>            : GetFunctionNativeReserved(JSObject* fun, size_t which);
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     734 </span>            : SetFunctionNativeReserved(JSObject* fun, size_t which, const JS::Value&amp; val);
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     737 </span>            : FunctionHasNativeReserved(JSObject* fun);
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     740 </span>            : GetObjectProto(JSContext* cx, JS::HandleObject obj, JS::MutableHandleObject proto);
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">     743 </span>            : GetStaticPrototype(JSObject* obj);
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     746 </span>            : GetRealmOriginalEval(JSContext* cx, JS::MutableHandleObject eval);
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : inline void*
<span class="lineNum">     749 </span>            : GetObjectPrivate(JSObject* obj)
<span class="lineNum">     750 </span>            : {
<span class="lineNum">     751 </span>            :     MOZ_ASSERT(GetObjectClass(obj)-&gt;flags &amp; JSCLASS_HAS_PRIVATE);
<span class="lineNum">     752 </span>            :     const shadow::Object* nobj = reinterpret_cast&lt;const shadow::Object*&gt;(obj);
<span class="lineNum">     753 </span>            :     void** addr = reinterpret_cast&lt;void**&gt;(&amp;nobj-&gt;fixedSlots()[nobj-&gt;numFixedSlots()]);
<span class="lineNum">     754 </span>            :     return *addr;
<span class="lineNum">     755 </span>            : }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : /**
<span class="lineNum">     758 </span>            :  * Get the value stored in an object's reserved slot. This can be used with
<span class="lineNum">     759 </span>            :  * both native objects and proxies, but if |obj| is known to be a proxy
<span class="lineNum">     760 </span>            :  * GetProxyReservedSlot is a bit more efficient.
<span class="lineNum">     761 </span>            :  */
<span class="lineNum">     762 </span>            : inline const JS::Value&amp;
<span class="lineNum">     763 </span>            : GetReservedSlot(JSObject* obj, size_t slot)
<span class="lineNum">     764 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     765 </span>            :     MOZ_ASSERT(slot &lt; JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)));
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;const shadow::Object*&gt;(obj)-&gt;slotRef(slot);</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : JS_FRIEND_API(void)
<span class="lineNum">     770 </span>            : SetReservedSlotWithBarrier(JSObject* obj, size_t slot, const JS::Value&amp; value);
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            : /**
<span class="lineNum">     773 </span>            :  * Store a value in an object's reserved slot. This can be used with
<span class="lineNum">     774 </span>            :  * both native objects and proxies, but if |obj| is known to be a proxy
<span class="lineNum">     775 </span>            :  * SetProxyReservedSlot is a bit more efficient.
<span class="lineNum">     776 </span>            :  */
<span class="lineNum">     777 </span>            : inline void
<span class="lineNum">     778 </span>            : SetReservedSlot(JSObject* obj, size_t slot, const JS::Value&amp; value)
<span class="lineNum">     779 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     780 </span>            :     MOZ_ASSERT(slot &lt; JSCLASS_RESERVED_SLOTS(GetObjectClass(obj)));
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     shadow::Object* sobj = reinterpret_cast&lt;shadow::Object*&gt;(obj);</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     if (sobj-&gt;slotRef(slot).isGCThing() || value.isGCThing())</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :         SetReservedSlotWithBarrier(obj, slot, value);</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     else</span>
<span class="lineNum">     785 </span>            :         sobj-&gt;slotRef(slot) = value;
<span class="lineNum">     786 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     788 </span>            : JS_FRIEND_API(uint32_t)
<span class="lineNum">     789 </span>            : GetObjectSlotSpan(JSObject* obj);
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            : inline const JS::Value&amp;
<span class="lineNum">     792 </span>            : GetObjectSlot(JSObject* obj, size_t slot)
<span class="lineNum">     793 </span>            : {
<span class="lineNum">     794 </span>            :     MOZ_ASSERT(slot &lt; GetObjectSlotSpan(obj));
<span class="lineNum">     795 </span>            :     return reinterpret_cast&lt;const shadow::Object*&gt;(obj)-&gt;slotRef(slot);
<span class="lineNum">     796 </span>            : }
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : MOZ_ALWAYS_INLINE size_t
<span class="lineNum">     799 </span>            : GetAtomLength(JSAtom* atom)
<span class="lineNum">     800 </span>            : {
<span class="lineNum">     801 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(atom)-&gt;length;
<span class="lineNum">     802 </span>            : }
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            : static const uint32_t MaxStringLength = (1 &lt;&lt; 28) - 1;
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            : MOZ_ALWAYS_INLINE size_t
<span class="lineNum">     807 </span>            : GetStringLength(JSString* s)
<span class="lineNum">     808 </span>            : {
<span class="lineNum">     809 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(s)-&gt;length;
<span class="lineNum">     810 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span>            : MOZ_ALWAYS_INLINE size_t
<span class="lineNum">     813 </span>            : GetFlatStringLength(JSFlatString* s)
<span class="lineNum">     814 </span>            : {
<span class="lineNum">     815 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(s)-&gt;length;
<span class="lineNum">     816 </span>            : }
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            : MOZ_ALWAYS_INLINE size_t
<span class="lineNum">     819 </span>            : GetLinearStringLength(JSLinearString* s)
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(s)-&gt;length;
<span class="lineNum">     822 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">     825 </span>            : LinearStringHasLatin1Chars(JSLinearString* s)
<span class="lineNum">     826 </span>            : {
<span class="lineNum">     827 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(s)-&gt;flags &amp; JS::shadow::String::LATIN1_CHARS_BIT;
<span class="lineNum">     828 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">     831 </span>            : AtomHasLatin1Chars(JSAtom* atom)
<span class="lineNum">     832 </span>            : {
<span class="lineNum">     833 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(atom)-&gt;flags &amp; JS::shadow::String::LATIN1_CHARS_BIT;
<span class="lineNum">     834 </span>            : }
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">     837 </span>            : StringHasLatin1Chars(JSString* s)
<span class="lineNum">     838 </span>            : {
<span class="lineNum">     839 </span>            :     return reinterpret_cast&lt;JS::shadow::String*&gt;(s)-&gt;flags &amp; JS::shadow::String::LATIN1_CHARS_BIT;
<span class="lineNum">     840 </span>            : }
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            : MOZ_ALWAYS_INLINE const JS::Latin1Char*
<span class="lineNum">     843 </span>            : GetLatin1LinearStringChars(const JS::AutoRequireNoGC&amp; nogc, JSLinearString* linear)
<span class="lineNum">     844 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     845 </span>            :     MOZ_ASSERT(LinearStringHasLatin1Chars(linear));
<span class="lineNum">     846 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     847 </span>            :     using JS::shadow::String;
<span class="lineNum">     848 </span>            :     String* s = reinterpret_cast&lt;String*&gt;(linear);
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     if (s-&gt;flags &amp; String::INLINE_CHARS_BIT)</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :         return s-&gt;inlineStorageLatin1;</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     return s-&gt;nonInlineCharsLatin1;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : MOZ_ALWAYS_INLINE const char16_t*
<span class="lineNum">     855 </span>            : GetTwoByteLinearStringChars(const JS::AutoRequireNoGC&amp; nogc, JSLinearString* linear)
<span class="lineNum">     856 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     857 </span>            :     MOZ_ASSERT(!LinearStringHasLatin1Chars(linear));
<span class="lineNum">     858 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     859 </span>            :     using JS::shadow::String;
<span class="lineNum">     860 </span>            :     String* s = reinterpret_cast&lt;String*&gt;(linear);
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     if (s-&gt;flags &amp; String::INLINE_CHARS_BIT)</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :         return s-&gt;inlineStorageTwoByte;</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     return s-&gt;nonInlineCharsTwoByte;</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            : MOZ_ALWAYS_INLINE JSLinearString*
<span class="lineNum">     867 </span>            : AtomToLinearString(JSAtom* atom)
<span class="lineNum">     868 </span>            : {
<span class="lineNum">     869 </span>            :     return reinterpret_cast&lt;JSLinearString*&gt;(atom);
<span class="lineNum">     870 </span>            : }
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            : MOZ_ALWAYS_INLINE JSFlatString*
<span class="lineNum">     873 </span>            : AtomToFlatString(JSAtom* atom)
<span class="lineNum">     874 </span>            : {
<span class="lineNum">     875 </span>            :     return reinterpret_cast&lt;JSFlatString*&gt;(atom);
<span class="lineNum">     876 </span>            : }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            : MOZ_ALWAYS_INLINE JSLinearString*
<span class="lineNum">     879 </span>            : FlatStringToLinearString(JSFlatString* s)
<span class="lineNum">     880 </span>            : {
<span class="lineNum">     881 </span>            :     return reinterpret_cast&lt;JSLinearString*&gt;(s);
<span class="lineNum">     882 </span>            : }
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : MOZ_ALWAYS_INLINE const JS::Latin1Char*
<span class="lineNum">     885 </span>            : GetLatin1AtomChars(const JS::AutoRequireNoGC&amp; nogc, JSAtom* atom)
<span class="lineNum">     886 </span>            : {
<span class="lineNum">     887 </span>            :     return GetLatin1LinearStringChars(nogc, AtomToLinearString(atom));
<span class="lineNum">     888 </span>            : }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            : MOZ_ALWAYS_INLINE const char16_t*
<span class="lineNum">     891 </span>            : GetTwoByteAtomChars(const JS::AutoRequireNoGC&amp; nogc, JSAtom* atom)
<span class="lineNum">     892 </span>            : {
<span class="lineNum">     893 </span>            :     return GetTwoByteLinearStringChars(nogc, AtomToLinearString(atom));
<span class="lineNum">     894 </span>            : }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">     897 </span>            : IsExternalString(JSString* str, const JSStringFinalizer** fin, const char16_t** chars)
<span class="lineNum">     898 </span>            : {
<span class="lineNum">     899 </span>            :     using JS::shadow::String;
<span class="lineNum">     900 </span>            :     String* s = reinterpret_cast&lt;String*&gt;(str);
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span>            :     if ((s-&gt;flags &amp; String::TYPE_FLAGS_MASK) != String::EXTERNAL_FLAGS)
<span class="lineNum">     903 </span>            :         return false;
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            :     MOZ_ASSERT(JS_IsExternalString(str));
<span class="lineNum">     906 </span>            :     *fin = s-&gt;externalFinalizer;
<span class="lineNum">     907 </span>            :     *chars = s-&gt;nonInlineCharsTwoByte;
<span class="lineNum">     908 </span>            :     return true;
<span class="lineNum">     909 </span>            : }
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : JS_FRIEND_API(JSLinearString*)
<span class="lineNum">     912 </span>            : StringToLinearStringSlow(JSContext* cx, JSString* str);
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : MOZ_ALWAYS_INLINE JSLinearString*
<span class="lineNum">     915 </span>            : StringToLinearString(JSContext* cx, JSString* str)
<span class="lineNum">     916 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">     917 </span>            :     using JS::shadow::String;
<span class="lineNum">     918 </span>            :     String* s = reinterpret_cast&lt;String*&gt;(str);
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     if (MOZ_UNLIKELY(!(s-&gt;flags &amp; String::LINEAR_BIT)))</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :         return StringToLinearStringSlow(cx, str);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     return reinterpret_cast&lt;JSLinearString*&gt;(str);</span>
<span class="lineNum">     922 </span>            : }
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">     925 </span>            : MOZ_ALWAYS_INLINE void
<span class="lineNum">     926 </span>            : CopyLinearStringChars(CharType* dest, JSLinearString* s, size_t len, size_t start = 0);
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            : MOZ_ALWAYS_INLINE void
<span class="lineNum">     929 </span>            : CopyLinearStringChars(char16_t* dest, JSLinearString* s, size_t len, size_t start = 0)
<span class="lineNum">     930 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     931 </span>            :     MOZ_ASSERT(start + len &lt;= GetLinearStringLength(s));
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :     JS::AutoCheckCannotGC nogc;</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     if (LinearStringHasLatin1Chars(s)) {</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :         const JS::Latin1Char* src = GetLatin1LinearStringChars(nogc, s);</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; len; i++)</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :             dest[i] = src[start + i];</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     } else {</span>
<span class="lineNum">     938 </span>            :         const char16_t* src = GetTwoByteLinearStringChars(nogc, s);
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :         mozilla::PodCopy(dest, src + start, len);</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     941 </span>            : }
<span class="lineNum">     942 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     943 </span>            : MOZ_ALWAYS_INLINE void
<span class="lineNum">     944 </span>            : CopyLinearStringChars(char* dest, JSLinearString* s, size_t len, size_t start = 0)
<span class="lineNum">     945 </span>            : {
<span class="lineNum">     946 </span>            :     MOZ_ASSERT(start + len &lt;= GetLinearStringLength(s));
<span class="lineNum">     947 </span>            :     JS::AutoCheckCannotGC nogc;
<span class="lineNum">     948 </span>            :     if (LinearStringHasLatin1Chars(s)) {
<span class="lineNum">     949 </span>            :         const JS::Latin1Char* src = GetLatin1LinearStringChars(nogc, s);
<span class="lineNum">     950 </span>            :         for (size_t i = 0; i &lt; len; i++)
<span class="lineNum">     951 </span>            :            dest[i] = char(src[start + i]);
<span class="lineNum">     952 </span>            :     } else {
<span class="lineNum">     953 </span>            :       const char16_t* src = GetTwoByteLinearStringChars(nogc, s);
<span class="lineNum">     954 </span>            :       for (size_t i = 0; i &lt; len; i++)
<span class="lineNum">     955 </span>            :           dest[i] = char(src[start + i]);
<span class="lineNum">     956 </span>            :     }
<span class="lineNum">     957 </span>            : }
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            : template&lt;typename CharType&gt;
<span class="lineNum">     960 </span>            : inline bool
<span class="lineNum">     961 </span>            : CopyStringChars(JSContext* cx, CharType* dest, JSString* s, size_t len, size_t start = 0)
<span class="lineNum">     962 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">     963 </span>            :     JSLinearString* linear = StringToLinearString(cx, s);
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     if (!linear)</span>
<span class="lineNum">     965 </span><span class="lineCov">          2 :         return false;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     CopyLinearStringChars(dest, linear, len, start);
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            : inline void
<span class="lineNum">     972 </span>            : CopyFlatStringChars(char16_t* dest, JSFlatString* s, size_t len)
<span class="lineNum">     973 </span>            : {
<span class="lineNum">     974 </span>            :     CopyLinearStringChars(dest, FlatStringToLinearString(s), len);
<span class="lineNum">     975 </span>            : }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : /**
<span class="lineNum">     978 </span>            :  * Add some or all property keys of obj to the id vector *props.
<span class="lineNum">     979 </span>            :  *
<span class="lineNum">     980 </span>            :  * The flags parameter controls which property keys are added. Pass a
<span class="lineNum">     981 </span>            :  * combination of the following bits:
<span class="lineNum">     982 </span>            :  *
<span class="lineNum">     983 </span>            :  *     JSITER_OWNONLY - Don't also search the prototype chain; only consider
<span class="lineNum">     984 </span>            :  *       obj's own properties.
<span class="lineNum">     985 </span>            :  *
<span class="lineNum">     986 </span>            :  *     JSITER_HIDDEN - Include nonenumerable properties.
<span class="lineNum">     987 </span>            :  *
<span class="lineNum">     988 </span>            :  *     JSITER_SYMBOLS - Include property keys that are symbols. The default
<span class="lineNum">     989 </span>            :  *       behavior is to filter out symbols.
<span class="lineNum">     990 </span>            :  *
<span class="lineNum">     991 </span>            :  *     JSITER_SYMBOLSONLY - Exclude non-symbol property keys.
<span class="lineNum">     992 </span>            :  *
<span class="lineNum">     993 </span>            :  * This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or
<span class="lineNum">     994 </span>            :  * equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass
<span class="lineNum">     995 </span>            :  * `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get
<span class="lineNum">     996 </span>            :  * results that match the output of Reflect.ownKeys.
<span class="lineNum">     997 </span>            :  */
<span class="lineNum">     998 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">     999 </span>            : GetPropertyKeys(JSContext* cx, JS::HandleObject obj, unsigned flags, JS::AutoIdVector* props);
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    1002 </span>            : AppendUnique(JSContext* cx, JS::AutoIdVector&amp; base, JS::AutoIdVector&amp; others);
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    1005 </span>            : StringIsArrayIndex(JSLinearString* str, uint32_t* indexp);
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1008 </span>            : SetPreserveWrapperCallback(JSContext* cx, PreserveWrapperCallback callback);
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    1011 </span>            : IsObjectInContextCompartment(JSObject* obj, const JSContext* cx);
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : /*
<span class="lineNum">    1014 </span>            :  * NB: keep these in sync with the copy in builtin/SelfHostingDefines.h.
<span class="lineNum">    1015 </span>            :  */
<span class="lineNum">    1016 </span>            : /* 0x1 is no longer used */
<span class="lineNum">    1017 </span>            : /* 0x2 is no longer used */
<span class="lineNum">    1018 </span>            : /* 0x4 is no longer used */
<span class="lineNum">    1019 </span>            : #define JSITER_OWNONLY    0x8   /* iterate over obj's own properties only */
<span class="lineNum">    1020 </span>            : #define JSITER_HIDDEN     0x10  /* also enumerate non-enumerable properties */
<span class="lineNum">    1021 </span>            : #define JSITER_SYMBOLS    0x20  /* also include symbol property keys */
<span class="lineNum">    1022 </span>            : #define JSITER_SYMBOLSONLY 0x40 /* exclude string property keys */
<span class="lineNum">    1023 </span>            : #define JSITER_FORAWAITOF 0x80  /* for-await-of */
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    1026 </span>            : RunningWithTrustedPrincipals(JSContext* cx);
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            : MOZ_ALWAYS_INLINE uintptr_t
<span class="lineNum">    1029 </span>            : GetNativeStackLimit(JSContext* cx, JS::StackKind kind, int extraAllowance = 0)
<span class="lineNum">    1030 </span>            : {
<span class="lineNum">    1031 </span>            :     uintptr_t limit = JS::RootingContext::get(cx)-&gt;nativeStackLimit[kind];
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 : #if JS_STACK_GROWTH_DIRECTION &gt; 0</span>
<span class="lineNum">    1033 </span>            :     limit += extraAllowance;
<span class="lineNum">    1034 </span>            : #else
<span class="lineNum">    1035 </span>            :     limit -= extraAllowance;
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 : #endif</span>
<span class="lineNum">    1037 </span>            :     return limit;
<span class="lineNum">    1038 </span>            : }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            : MOZ_ALWAYS_INLINE uintptr_t
<span class="lineNum">    1041 </span>            : GetNativeStackLimit(JSContext* cx, int extraAllowance = 0)
<span class="lineNum">    1042 </span>            : {
<span class="lineNum">    1043 </span>            :     JS::StackKind kind = RunningWithTrustedPrincipals(cx) ? JS::StackForTrustedScript
<span class="lineNum">    1044 </span><span class="lineCov">          2 :                                                           : JS::StackForUntrustedScript;</span>
<span class="lineNum">    1045 </span><span class="lineCov">          2 :     return GetNativeStackLimit(cx, kind, extraAllowance);</span>
<span class="lineNum">    1046 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /*
<span class="lineNum">    1049 </span>            :  * These functions return |false| if we are close to using up the C++ stack.
<span class="lineNum">    1050 </span>            :  * They also report an overrecursion error, except for the DontReport variants.
<span class="lineNum">    1051 </span>            :  * The CheckSystemRecursionLimit variant gives us a little extra space so we
<span class="lineNum">    1052 </span>            :  * can ensure that crucial code is able to run. CheckRecursionLimitConservative
<span class="lineNum">    1053 </span>            :  * allows less space than any other check, including a safety buffer (as in, it
<span class="lineNum">    1054 </span>            :  * uses the untrusted limit and subtracts a little more from it).
<span class="lineNum">    1055 </span>            :  */
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1058 </span>            : CheckRecursionLimit(JSContext* cx, uintptr_t limit)
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1060 </span>            :     int stackDummy;
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span>            :     JS_STACK_OOM_POSSIBLY_FAIL_REPORT();
<span class="lineNum">    1063 </span><span class="lineCov">          2 : </span>
<span class="lineNum">    1064 </span>            :     if (!JS_CHECK_STACK_SIZE(limit, &amp;stackDummy)) {
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :         ReportOverRecursed(cx);</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1068 </span>            :     return true;
<span class="lineNum">    1069 </span>            : }
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1072 </span>            : CheckRecursionLimitDontReport(uintptr_t limit)
<span class="lineNum">    1073 </span>            : {
<span class="lineNum">    1074 </span>            :     int stackDummy;
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            :     JS_STACK_OOM_POSSIBLY_FAIL();
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1078 </span>            :     return JS_CHECK_STACK_SIZE(limit, &amp;stackDummy);
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1082 </span>            : CheckRecursionLimit(JSContext* cx)
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    1084 </span>            :     JS_STACK_OOM_POSSIBLY_FAIL_REPORT();
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    1086 </span>            :     // GetNativeStackLimit(cx) is pretty slow because it has to do an uninlined
<span class="lineNum">    1087 </span>            :     // call to RunningWithTrustedPrincipals to determine which stack limit to
<span class="lineNum">    1088 </span>            :     // use. To work around this, check the untrusted limit first to avoid the
<span class="lineNum">    1089 </span>            :     // overhead in most cases.
<span class="lineNum">    1090 </span>            :     uintptr_t untrustedLimit = GetNativeStackLimit(cx, JS::StackForUntrustedScript);
<span class="lineNum">    1091 </span><span class="lineCov">          2 :     if (MOZ_LIKELY(CheckRecursionLimitDontReport(untrustedLimit)))</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1093 </span>            :     return CheckRecursionLimit(cx, GetNativeStackLimit(cx));
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1097 </span>            : CheckRecursionLimitDontReport(JSContext* cx)
<span class="lineNum">    1098 </span><span class="lineCov">       3590 : {</span>
<span class="lineNum">    1099 </span>            :     return CheckRecursionLimitDontReport(GetNativeStackLimit(cx));
<span class="lineNum">    1100 </span><span class="lineCov">       7180 : }</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1103 </span>            : CheckRecursionLimitWithStackPointerDontReport(JSContext* cx, void* sp)
<span class="lineNum">    1104 </span><span class="lineCov">         58 : {</span>
<span class="lineNum">    1105 </span>            :     JS_STACK_OOM_POSSIBLY_FAIL();
<span class="lineNum">    1106 </span><span class="lineCov">         58 : </span>
<span class="lineNum">    1107 </span>            :     return JS_CHECK_STACK_SIZE(GetNativeStackLimit(cx), sp);
<span class="lineNum">    1108 </span><span class="lineCov">         58 : }</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1111 </span>            : CheckRecursionLimitWithStackPointer(JSContext* cx, void* sp)
<span class="lineNum">    1112 </span><span class="lineCov">        432 : {</span>
<span class="lineNum">    1113 </span>            :     JS_STACK_OOM_POSSIBLY_FAIL_REPORT();
<span class="lineNum">    1114 </span><span class="lineCov">        432 : </span>
<span class="lineNum">    1115 </span>            :     if (!JS_CHECK_STACK_SIZE(GetNativeStackLimit(cx), sp)) {
<span class="lineNum">    1116 </span><span class="lineCov">        432 :         ReportOverRecursed(cx);</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1119 </span>            :     return true;
<span class="lineNum">    1120 </span>            : }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1123 </span>            : CheckSystemRecursionLimit(JSContext* cx)
<span class="lineNum">    1124 </span>            : {
<span class="lineNum">    1125 </span>            :     return CheckRecursionLimit(cx, GetNativeStackLimit(cx, JS::StackForSystemCode));
<span class="lineNum">    1126 </span><span class="lineCov">      45114 : }</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1129 </span>            : CheckRecursionLimitConservative(JSContext* cx)
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span>            :     return CheckRecursionLimit(cx, GetNativeStackLimit(cx, JS::StackForUntrustedScript,
<span class="lineNum">    1132 </span>            :                                                        -1024 * int(sizeof(size_t))));
<span class="lineNum">    1133 </span>            : }
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            : MOZ_ALWAYS_INLINE bool
<span class="lineNum">    1136 </span>            : CheckRecursionLimitConservativeDontReport(JSContext* cx)
<span class="lineNum">    1137 </span>            : {
<span class="lineNum">    1138 </span>            :     return CheckRecursionLimitDontReport(GetNativeStackLimit(cx, JS::StackForUntrustedScript,
<span class="lineNum">    1139 </span>            :                                                              -1024 * int(sizeof(size_t))));
<span class="lineNum">    1140 </span>            : }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1143 </span>            : StartPCCountProfiling(JSContext* cx);
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1146 </span>            : StopPCCountProfiling(JSContext* cx);
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1149 </span>            : PurgePCCounts(JSContext* cx);
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            : JS_FRIEND_API(size_t)
<span class="lineNum">    1152 </span>            : GetPCCountScriptCount(JSContext* cx);
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            : JS_FRIEND_API(JSString*)
<span class="lineNum">    1155 </span>            : GetPCCountScriptSummary(JSContext* cx, size_t script);
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            : JS_FRIEND_API(JSString*)
<span class="lineNum">    1158 </span>            : GetPCCountScriptContents(JSContext* cx, size_t script);
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            : /**
<span class="lineNum">    1161 </span>            :  * Generate lcov trace file content for the current compartment, and allocate a
<span class="lineNum">    1162 </span>            :  * new buffer and return the content in it, the size of the newly allocated
<span class="lineNum">    1163 </span>            :  * content within the buffer would be set to the length out-param.
<span class="lineNum">    1164 </span>            :  *
<span class="lineNum">    1165 </span>            :  * In case of out-of-memory, this function returns nullptr and does not set any
<span class="lineNum">    1166 </span>            :  * value to the length out-param.
<span class="lineNum">    1167 </span>            :  */
<span class="lineNum">    1168 </span>            : JS_FRIEND_API(char*)
<span class="lineNum">    1169 </span>            : GetCodeCoverageSummary(JSContext* cx, size_t* length);
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            : typedef void
<span class="lineNum">    1172 </span>            : (* ActivityCallback)(void* arg, bool active);
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            : /**
<span class="lineNum">    1175 </span>            :  * Sets a callback that is run whenever the runtime goes idle - the
<span class="lineNum">    1176 </span>            :  * last active request ceases - and begins activity - when it was
<span class="lineNum">    1177 </span>            :  * idle and a request begins.
<span class="lineNum">    1178 </span>            :  */
<span class="lineNum">    1179 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1180 </span>            : SetActivityCallback(JSContext* cx, ActivityCallback cb, void* arg);
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            : typedef bool
<span class="lineNum">    1183 </span>            : (* DOMInstanceClassHasProtoAtDepth)(const Class* instanceClass,
<span class="lineNum">    1184 </span>            :                                     uint32_t protoID, uint32_t depth);
<span class="lineNum">    1185 </span>            : struct JSDOMCallbacks {
<span class="lineNum">    1186 </span>            :     DOMInstanceClassHasProtoAtDepth instanceClassMatchesProto;
<span class="lineNum">    1187 </span>            : };
<span class="lineNum">    1188 </span>            : typedef struct JSDOMCallbacks DOMCallbacks;
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    1191 </span>            : SetDOMCallbacks(JSContext* cx, const DOMCallbacks* callbacks);
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span>            : extern JS_FRIEND_API(const DOMCallbacks*)
<span class="lineNum">    1194 </span>            : GetDOMCallbacks(JSContext* cx);
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1197 </span>            : GetTestingFunctions(JSContext* cx);
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span>            : /**
<span class="lineNum">    1200 </span>            :  * Helper to convert FreeOp to JSFreeOp when the definition of FreeOp is not
<span class="lineNum">    1201 </span>            :  * available and the compiler does not know that FreeOp inherits from
<span class="lineNum">    1202 </span>            :  * JSFreeOp.
<span class="lineNum">    1203 </span>            :  */
<span class="lineNum">    1204 </span>            : inline JSFreeOp*
<span class="lineNum">    1205 </span>            : CastToJSFreeOp(FreeOp* fop)
<span class="lineNum">    1206 </span>            : {
<span class="lineNum">    1207 </span>            :     return reinterpret_cast&lt;JSFreeOp*&gt;(fop);
<span class="lineNum">    1208 </span>            : }
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span>            : /* Implemented in jsexn.cpp. */
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            : /**
<span class="lineNum">    1213 </span>            :  * Get an error type name from a JSExnType constant.
<span class="lineNum">    1214 </span>            :  * Returns nullptr for invalid arguments and JSEXN_INTERNALERR
<span class="lineNum">    1215 </span>            :  */
<span class="lineNum">    1216 </span>            : extern JS_FRIEND_API(JSFlatString*)
<span class="lineNum">    1217 </span>            : GetErrorTypeName(JSContext* cx, int16_t exnType);
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            : extern JS_FRIEND_API(RegExpShared*)
<span class="lineNum">    1220 </span>            : RegExpToSharedNonInline(JSContext* cx, JS::HandleObject regexp);
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : /* Implemented in CrossCompartmentWrapper.cpp. */
<span class="lineNum">    1223 </span>            : typedef enum NukeReferencesToWindow {
<span class="lineNum">    1224 </span>            :     NukeWindowReferences,
<span class="lineNum">    1225 </span>            :     DontNukeWindowReferences
<span class="lineNum">    1226 </span>            : } NukeReferencesToWindow;
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            : typedef enum NukeReferencesFromTarget {
<span class="lineNum">    1229 </span>            :     NukeAllReferences,
<span class="lineNum">    1230 </span>            :     NukeIncomingReferences,
<span class="lineNum">    1231 </span>            : } NukeReferencesFromTarget;
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            : /*
<span class="lineNum">    1234 </span>            :  * These filters are designed to be ephemeral stack classes, and thus don't
<span class="lineNum">    1235 </span>            :  * do any rooting or holding of their members.
<span class="lineNum">    1236 </span>            :  */
<span class="lineNum">    1237 </span>            : struct CompartmentFilter {
<span class="lineNum">    1238 </span>            :     virtual bool match(JS::Compartment* c) const = 0;
<span class="lineNum">    1239 </span>            : };
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : struct AllCompartments : public CompartmentFilter {
<span class="lineNum">    1242 </span>            :     virtual bool match(JS::Compartment* c) const override { return true; }
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : struct ContentCompartmentsOnly : public CompartmentFilter {
<span class="lineNum">    1246 </span>            :     virtual bool match(JS::Compartment* c) const override {
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :         return !IsSystemCompartment(c);</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1249 </span>            : };
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            : struct ChromeCompartmentsOnly : public CompartmentFilter {
<span class="lineNum">    1252 </span>            :     virtual bool match(JS::Compartment* c) const override {
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :         return IsSystemCompartment(c);</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1255 </span>            : };
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            : struct SingleCompartment : public CompartmentFilter {
<span class="lineNum">    1258 </span>            :     JS::Compartment* ours;
<span class="lineNum">    1259 </span>            :     explicit SingleCompartment(JS::Compartment* c) : ours(c) {}
<span class="lineNum">    1260 </span>            :     virtual bool match(JS::Compartment* c) const override { return c == ours; }
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 : };</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            : struct CompartmentsWithPrincipals : public CompartmentFilter {
<span class="lineNum">    1264 </span>            :     JSPrincipals* principals;
<span class="lineNum">    1265 </span>            :     explicit CompartmentsWithPrincipals(JSPrincipals* p) : principals(p) {}
<span class="lineNum">    1266 </span>            :     virtual bool match(JS::Compartment* c) const override {
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :         return JS_GetCompartmentPrincipals(c) == principals;</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1269 </span>            : };
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1272 </span>            : NukeCrossCompartmentWrappers(JSContext* cx,
<span class="lineNum">    1273 </span>            :                              const CompartmentFilter&amp; sourceFilter,
<span class="lineNum">    1274 </span>            :                              JS::Compartment* target,
<span class="lineNum">    1275 </span>            :                              NukeReferencesToWindow nukeReferencesToWindow,
<span class="lineNum">    1276 </span>            :                              NukeReferencesFromTarget nukeReferencesFromTarget);
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : /* Specify information about DOMProxy proxies in the DOM, for use by ICs. */
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            : /*
<span class="lineNum">    1281 </span>            :  * The DOMProxyShadowsCheck function will be called to check if the property for
<span class="lineNum">    1282 </span>            :  * id should be gotten from the prototype, or if there is an own property that
<span class="lineNum">    1283 </span>            :  * shadows it.
<span class="lineNum">    1284 </span>            :  * * If ShadowsViaDirectExpando is returned, then the slot at
<span class="lineNum">    1285 </span>            :  *   listBaseExpandoSlot contains an expando object which has the property in
<span class="lineNum">    1286 </span>            :  *   question.
<span class="lineNum">    1287 </span>            :  * * If ShadowsViaIndirectExpando is returned, then the slot at
<span class="lineNum">    1288 </span>            :  *   listBaseExpandoSlot contains a private pointer to an ExpandoAndGeneration
<span class="lineNum">    1289 </span>            :  *   and the expando object in the ExpandoAndGeneration has the property in
<span class="lineNum">    1290 </span>            :  *   question.
<span class="lineNum">    1291 </span>            :  * * If DoesntShadow is returned then the slot at listBaseExpandoSlot should
<span class="lineNum">    1292 </span>            :  *   either be undefined or point to an expando object that would contain the
<span class="lineNum">    1293 </span>            :  *   own property.
<span class="lineNum">    1294 </span>            :  * * If DoesntShadowUnique is returned then the slot at listBaseExpandoSlot
<span class="lineNum">    1295 </span>            :  *   should contain a private pointer to a ExpandoAndGeneration, which contains
<span class="lineNum">    1296 </span>            :  *   a JS::Value that should either be undefined or point to an expando object,
<span class="lineNum">    1297 </span>            :  *   and a uint64 value. If that value changes then the IC for getting a
<span class="lineNum">    1298 </span>            :  *   property will be invalidated.
<span class="lineNum">    1299 </span>            :  * * If Shadows is returned, that means the property is an own property of the
<span class="lineNum">    1300 </span>            :  *   proxy but doesn't live on the expando object.
<span class="lineNum">    1301 </span>            :  */
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            : struct ExpandoAndGeneration {
<span class="lineNum">    1304 </span>            :   ExpandoAndGeneration()
<span class="lineNum">    1305 </span>            :     : expando(JS::UndefinedValue()),
<span class="lineNum">    1306 </span>            :       generation(0)
<span class="lineNum">    1307 </span>            :   {}
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :   void OwnerUnlinked()
<span class="lineNum">    1310 </span>            :   {
<span class="lineNum">    1311 </span>            :       ++generation;
<span class="lineNum">    1312 </span>            :   }
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            :   static size_t offsetOfExpando()
<span class="lineNum">    1315 </span>            :   {
<span class="lineNum">    1316 </span>            :       return offsetof(ExpandoAndGeneration, expando);
<span class="lineNum">    1317 </span>            :   }
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :   static size_t offsetOfGeneration()
<span class="lineNum">    1320 </span>            :   {
<span class="lineNum">    1321 </span>            :       return offsetof(ExpandoAndGeneration, generation);
<span class="lineNum">    1322 </span>            :   }
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            :   JS::Heap&lt;JS::Value&gt; expando;
<span class="lineNum">    1325 </span>            :   uint64_t generation;
<span class="lineNum">    1326 </span>            : };
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            : typedef enum DOMProxyShadowsResult {
<span class="lineNum">    1329 </span>            :   ShadowCheckFailed,
<span class="lineNum">    1330 </span>            :   Shadows,
<span class="lineNum">    1331 </span>            :   DoesntShadow,
<span class="lineNum">    1332 </span>            :   DoesntShadowUnique,
<span class="lineNum">    1333 </span>            :   ShadowsViaDirectExpando,
<span class="lineNum">    1334 </span>            :   ShadowsViaIndirectExpando
<span class="lineNum">    1335 </span>            : } DOMProxyShadowsResult;
<span class="lineNum">    1336 </span>            : typedef DOMProxyShadowsResult
<span class="lineNum">    1337 </span>            : (* DOMProxyShadowsCheck)(JSContext* cx, JS::HandleObject object, JS::HandleId id);
<span class="lineNum">    1338 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1339 </span>            : SetDOMProxyInformation(const void* domProxyHandlerFamily,
<span class="lineNum">    1340 </span>            :                        DOMProxyShadowsCheck domProxyShadowsCheck);
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            : const void* GetDOMProxyHandlerFamily();
<span class="lineNum">    1343 </span>            : DOMProxyShadowsCheck GetDOMProxyShadowsCheck();
<span class="lineNum">    1344 </span>            : inline bool DOMProxyIsShadowing(DOMProxyShadowsResult result) {
<span class="lineNum">    1345 </span>            :     return result == Shadows ||
<span class="lineNum">    1346 </span><span class="lineCov">         48 :            result == ShadowsViaDirectExpando ||</span>
<span class="lineNum">    1347 </span><span class="lineCov">         48 :            result == ShadowsViaIndirectExpando;</span>
<span class="lineNum">    1348 </span>            : }
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            : // Callbacks and other information for use by the JITs when optimizing accesses
<span class="lineNum">    1351 </span>            : // on xray wrappers.
<span class="lineNum">    1352 </span>            : struct XrayJitInfo {
<span class="lineNum">    1353 </span>            :     // Test whether a proxy handler is a cross compartment xray with no
<span class="lineNum">    1354 </span>            :     // security checks.
<span class="lineNum">    1355 </span>            :     bool (*isCrossCompartmentXray)(const BaseProxyHandler* handler);
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :     // Test whether xrays with a global object's compartment have expandos of
<span class="lineNum">    1358 </span>            :     // their own, instead of sharing them with Xrays from other compartments.
<span class="lineNum">    1359 </span>            :     bool (*globalHasExclusiveExpandos)(JSObject* obj);
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :     // Proxy reserved slot used by xrays in sandboxes to store their holder
<span class="lineNum">    1362 </span>            :     // object.
<span class="lineNum">    1363 </span>            :     size_t xrayHolderSlot;
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span>            :     // Reserved slot used by xray holders to store the xray's expando object.
<span class="lineNum">    1366 </span>            :     size_t holderExpandoSlot;
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :     // Reserved slot used by xray expandos to store a custom prototype.
<span class="lineNum">    1369 </span>            :     size_t expandoProtoSlot;
<span class="lineNum">    1370 </span>            : };
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    1373 </span>            : SetXrayJitInfo(XrayJitInfo* info);
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span>            : XrayJitInfo*
<span class="lineNum">    1376 </span>            : GetXrayJitInfo();
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            : /* Implemented in jsdate.cpp. */
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : /** Detect whether the internal date value is NaN. */
<span class="lineNum">    1381 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1382 </span>            : DateIsValid(JSContext* cx, JS::HandleObject obj, bool* isValid);
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1385 </span>            : DateGetMsecSinceEpoch(JSContext* cx, JS::HandleObject obj, double* msecSinceEpoch);
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span>            : } /* namespace js */
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            : typedef enum JSErrNum {
<span class="lineNum">    1390 </span>            : #define MSG_DEF(name, count, exception, format) \
<span class="lineNum">    1391 </span>            :     name,
<span class="lineNum">    1392 </span>            : #include &quot;js.msg&quot;
<span class="lineNum">    1393 </span>            : #undef MSG_DEF
<span class="lineNum">    1394 </span>            :     JSErr_Limit
<span class="lineNum">    1395 </span>            : } JSErrNum;
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            : namespace js {
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span>            : /* Implemented in vm/JSContext.cpp. */
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span>            : extern JS_FRIEND_API(const JSErrorFormatString*)
<span class="lineNum">    1402 </span>            : GetErrorMessage(void* userRef, const unsigned errorNumber);
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            : // AutoStableStringChars is here so we can use it in ErrorReport.  It
<span class="lineNum">    1405 </span>            : // should get moved out of here if we can manage it.  See bug 1040316.
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span>            : /**
<span class="lineNum">    1408 </span>            :  * This class provides safe access to a string's chars across a GC. Once
<span class="lineNum">    1409 </span>            :  * we allocate strings and chars in the nursery (bug 903519), this class
<span class="lineNum">    1410 </span>            :  * will have to make a copy of the string's chars if they are allocated
<span class="lineNum">    1411 </span>            :  * in the nursery, so it's best to avoid using this class unless you really
<span class="lineNum">    1412 </span>            :  * need it. It's usually more efficient to use the latin1Chars/twoByteChars
<span class="lineNum">    1413 </span>            :  * JSString methods and often the code can be rewritten so that only indexes
<span class="lineNum">    1414 </span>            :  * instead of char pointers are used in parts of the code that can GC.
<span class="lineNum">    1415 </span>            :  */
<span class="lineNum">    1416 </span>            : class MOZ_STACK_CLASS JS_FRIEND_API(AutoStableStringChars)
<span class="lineNum">    1417 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">    1418 </span>            :     /*
<span class="lineNum">    1419 </span>            :      * When copying string char, use this many bytes of inline storage.  This is
<span class="lineNum">    1420 </span>            :      * chosen to allow the inline string types to be copied without allocating.
<span class="lineNum">    1421 </span>            :      * This is asserted in AutoStableStringChars::allocOwnChars.
<span class="lineNum">    1422 </span>            :      */
<span class="lineNum">    1423 </span>            :     static const size_t InlineCapacity = 24;
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span>            :     /* Ensure the string is kept alive while we're using its chars. */
<span class="lineNum">    1426 </span>            :     JS::RootedString s_;
<span class="lineNum">    1427 </span>            :     union {
<span class="lineNum">    1428 </span>            :         const char16_t* twoByteChars_;
<span class="lineNum">    1429 </span>            :         const JS::Latin1Char* latin1Chars_;
<span class="lineNum">    1430 </span>            :     };
<span class="lineNum">    1431 </span>            :     mozilla::Maybe&lt;Vector&lt;uint8_t, InlineCapacity&gt;&gt; ownChars_;
<span class="lineNum">    1432 </span>            :     enum State { Uninitialized, Latin1, TwoByte };
<span class="lineNum">    1433 </span>            :     State state_;
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span>            :   public:
<span class="lineNum">    1436 </span>            :     explicit AutoStableStringChars(JSContext* cx)
<span class="lineNum">    1437 </span>            :       : s_(cx), state_(Uninitialized)
<span class="lineNum">    1438 </span><span class="lineCov">          2 :     {}</span>
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span>            :     MOZ_MUST_USE
<span class="lineNum">    1441 </span>            :     bool init(JSContext* cx, JSString* s);
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            :     /* Like init(), but Latin1 chars are inflated to TwoByte. */
<span class="lineNum">    1444 </span>            :     MOZ_MUST_USE
<span class="lineNum">    1445 </span>            :     bool initTwoByte(JSContext* cx, JSString* s);
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            :     bool isLatin1() const { return state_ == Latin1; }
<span class="lineNum">    1448 </span>            :     bool isTwoByte() const { return state_ == TwoByte; }
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            :     const JS::Latin1Char* latin1Chars() const {
<span class="lineNum">    1451 </span>            :         MOZ_ASSERT(state_ == Latin1);
<span class="lineNum">    1452 </span>            :         return latin1Chars_;
<span class="lineNum">    1453 </span>            :     }
<span class="lineNum">    1454 </span>            :     const char16_t* twoByteChars() const {
<span class="lineNum">    1455 </span>            :         MOZ_ASSERT(state_ == TwoByte);
<span class="lineNum">    1456 </span><span class="lineCov">          2 :         return twoByteChars_;</span>
<span class="lineNum">    1457 </span>            :     }
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span>            :     mozilla::Range&lt;const JS::Latin1Char&gt; latin1Range() const {
<span class="lineNum">    1460 </span><span class="lineCov">        142 :         MOZ_ASSERT(state_ == Latin1);</span>
<span class="lineNum">    1461 </span><span class="lineCov">        142 :         return mozilla::Range&lt;const JS::Latin1Char&gt;(latin1Chars_,</span>
<span class="lineNum">    1462 </span><span class="lineCov">        142 :                                                     GetStringLength(s_));</span>
<span class="lineNum">    1463 </span><span class="lineCov">        568 :     }</span>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            :     mozilla::Range&lt;const char16_t&gt; twoByteRange() const {
<span class="lineNum">    1466 </span><span class="lineCov">         86 :         MOZ_ASSERT(state_ == TwoByte);</span>
<span class="lineNum">    1467 </span><span class="lineCov">         86 :         return mozilla::Range&lt;const char16_t&gt;(twoByteChars_,</span>
<span class="lineNum">    1468 </span><span class="lineCov">         86 :                                               GetStringLength(s_));</span>
<span class="lineNum">    1469 </span><span class="lineCov">        344 :     }</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :     /* If we own the chars, transfer ownership to the caller. */
<span class="lineNum">    1472 </span>            :     bool maybeGiveOwnershipToCaller() {
<span class="lineNum">    1473 </span><span class="lineCov">         78 :         MOZ_ASSERT(state_ != Uninitialized);</span>
<span class="lineNum">    1474 </span><span class="lineCov">         78 :         if (!ownChars_.isSome() || !ownChars_-&gt;extractRawBuffer())</span>
<span class="lineNum">    1475 </span><span class="lineCov">         78 :             return false;</span>
<span class="lineNum">    1476 </span>            :         state_ = Uninitialized;
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :         ownChars_.reset();</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            :   private:
<span class="lineNum">    1482 </span>            :     AutoStableStringChars(const AutoStableStringChars&amp; other) = delete;
<span class="lineNum">    1483 </span>            :     void operator=(const AutoStableStringChars&amp; other) = delete;
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            :     bool baseIsInline(JS::Handle&lt;JSLinearString*&gt; linearString);
<span class="lineNum">    1486 </span>            :     template &lt;typename T&gt; T* allocOwnChars(JSContext* cx, size_t count);
<span class="lineNum">    1487 </span>            :     bool copyLatin1Chars(JSContext* cx, JS::Handle&lt;JSLinearString*&gt; linearString);
<span class="lineNum">    1488 </span>            :     bool copyTwoByteChars(JSContext* cx, JS::Handle&lt;JSLinearString*&gt; linearString);
<span class="lineNum">    1489 </span>            :     bool copyAndInflateLatin1Chars(JSContext*, JS::Handle&lt;JSLinearString*&gt; linearString);
<span class="lineNum">    1490 </span>            : };
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span>            : struct MOZ_STACK_CLASS JS_FRIEND_API(ErrorReport)
<span class="lineNum">    1493 </span>            : {
<span class="lineNum">    1494 </span>            :     explicit ErrorReport(JSContext* cx);
<span class="lineNum">    1495 </span>            :     ~ErrorReport();
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            :     enum SniffingBehavior {
<span class="lineNum">    1498 </span>            :         WithSideEffects,
<span class="lineNum">    1499 </span>            :         NoSideEffects
<span class="lineNum">    1500 </span>            :     };
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            :     /**
<span class="lineNum">    1503 </span>            :      * Generate a JSErrorReport from the provided thrown value.
<span class="lineNum">    1504 </span>            :      *
<span class="lineNum">    1505 </span>            :      * If the value is a (possibly wrapped) Error object, the JSErrorReport will
<span class="lineNum">    1506 </span>            :      * be exactly initialized from the Error object's information, without
<span class="lineNum">    1507 </span>            :      * observable side effects. (The Error object's JSErrorReport is reused, if
<span class="lineNum">    1508 </span>            :      * it has one.)
<span class="lineNum">    1509 </span>            :      *
<span class="lineNum">    1510 </span>            :      * Otherwise various attempts are made to derive JSErrorReport information
<span class="lineNum">    1511 </span>            :      * from |exn| and from the current execution state.  This process is
<span class="lineNum">    1512 </span>            :      * *definitely* inconsistent with any standard, and particulars of the
<span class="lineNum">    1513 </span>            :      * behavior implemented here generally shouldn't be relied upon.
<span class="lineNum">    1514 </span>            :      *
<span class="lineNum">    1515 </span>            :      * If the value of |sniffingBehavior| is |WithSideEffects|, some of these
<span class="lineNum">    1516 </span>            :      * attempts *may* invoke user-configurable behavior when |exn| is an object:
<span class="lineNum">    1517 </span>            :      * converting |exn| to a string, detecting and getting properties on |exn|,
<span class="lineNum">    1518 </span>            :      * accessing |exn|'s prototype chain, and others are possible.  Users *must*
<span class="lineNum">    1519 </span>            :      * tolerate |ErrorReport::init| potentially having arbitrary effects.  Any
<span class="lineNum">    1520 </span>            :      * exceptions thrown by these operations will be caught and silently
<span class="lineNum">    1521 </span>            :      * ignored, and &quot;default&quot; values will be substituted into the JSErrorReport.
<span class="lineNum">    1522 </span>            :      *
<span class="lineNum">    1523 </span>            :      * But if the value of |sniffingBehavior| is |NoSideEffects|, these attempts
<span class="lineNum">    1524 </span>            :      * *will not* invoke any observable side effects.  The JSErrorReport will
<span class="lineNum">    1525 </span>            :      * simply contain fewer, less precise details.
<span class="lineNum">    1526 </span>            :      *
<span class="lineNum">    1527 </span>            :      * Unlike some functions involved in error handling, this function adheres
<span class="lineNum">    1528 </span>            :      * to the usual JSAPI return value error behavior.
<span class="lineNum">    1529 </span>            :      */
<span class="lineNum">    1530 </span>            :     bool init(JSContext* cx, JS::HandleValue exn,
<span class="lineNum">    1531 </span>            :               SniffingBehavior sniffingBehavior);
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            :     JSErrorReport* report()
<span class="lineNum">    1534 </span>            :     {
<span class="lineNum">    1535 </span>            :         return reportp;
<span class="lineNum">    1536 </span>            :     }
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :     const JS::ConstUTF8CharsZ toStringResult()
<span class="lineNum">    1539 </span>            :     {
<span class="lineNum">    1540 </span>            :         return toStringResult_;
<span class="lineNum">    1541 </span>            :     }
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            :   private:
<span class="lineNum">    1544 </span>            :     // More or less an equivalent of JS_ReportErrorNumber/js::ReportErrorNumberVA
<span class="lineNum">    1545 </span>            :     // but fills in an ErrorReport instead of reporting it.  Uses varargs to
<span class="lineNum">    1546 </span>            :     // make it simpler to call js::ExpandErrorArgumentsVA.
<span class="lineNum">    1547 </span>            :     //
<span class="lineNum">    1548 </span>            :     // Returns false if we fail to actually populate the ErrorReport
<span class="lineNum">    1549 </span>            :     // for some reason (probably out of memory).
<span class="lineNum">    1550 </span>            :     bool populateUncaughtExceptionReportUTF8(JSContext* cx, ...);
<span class="lineNum">    1551 </span>            :     bool populateUncaughtExceptionReportUTF8VA(JSContext* cx, va_list ap);
<span class="lineNum">    1552 </span>            : 
<span class="lineNum">    1553 </span>            :     // Reports exceptions from add-on scopes to telemetry.
<span class="lineNum">    1554 </span>            :     void ReportAddonExceptionToTelemetry(JSContext* cx);
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            :     // We may have a provided JSErrorReport, so need a way to represent that.
<span class="lineNum">    1557 </span>            :     JSErrorReport* reportp;
<span class="lineNum">    1558 </span>            : 
<span class="lineNum">    1559 </span>            :     // Or we may need to synthesize a JSErrorReport one of our own.
<span class="lineNum">    1560 </span>            :     JSErrorReport ownedReport;
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span>            :     // And we have a string to maybe keep alive that has pointers into
<span class="lineNum">    1563 </span>            :     // it from ownedReport.
<span class="lineNum">    1564 </span>            :     JS::RootedString str;
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :     // And keep its chars alive too.
<span class="lineNum">    1567 </span>            :     AutoStableStringChars strChars;
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            :     // And we need to root our exception value.
<span class="lineNum">    1570 </span>            :     JS::RootedObject exnObject;
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            :     // And for our filename.
<span class="lineNum">    1573 </span>            :     JSAutoByteString filename;
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            :     // We may have a result of error.toString().
<span class="lineNum">    1576 </span>            :     // FIXME: We should not call error.toString(), since it could have side
<span class="lineNum">    1577 </span>            :     //        effect (see bug 633623).
<span class="lineNum">    1578 </span>            :     JS::ConstUTF8CharsZ toStringResult_;
<span class="lineNum">    1579 </span>            :     JSAutoByteString toStringResultBytesStorage;
<span class="lineNum">    1580 </span>            : };
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span>            : /* Implemented in vm/StructuredClone.cpp. */
<span class="lineNum">    1583 </span>            : extern JS_FRIEND_API(uint64_t)
<span class="lineNum">    1584 </span>            : GetSCOffset(JSStructuredCloneWriter* writer);
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span>            : namespace Scalar {
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span>            : /**
<span class="lineNum">    1589 </span>            :  * Scalar types that can appear in typed arrays and typed objects.  The enum
<span class="lineNum">    1590 </span>            :  * values must to be kept in sync with the JS_SCALARTYPEREPR_ constants, as
<span class="lineNum">    1591 </span>            :  * well as the TypedArrayObject::classes and TypedArrayObject::protoClasses
<span class="lineNum">    1592 </span>            :  * definitions.
<span class="lineNum">    1593 </span>            :  */
<span class="lineNum">    1594 </span>            : enum Type {
<span class="lineNum">    1595 </span>            :     Int8 = 0,
<span class="lineNum">    1596 </span>            :     Uint8,
<span class="lineNum">    1597 </span>            :     Int16,
<span class="lineNum">    1598 </span>            :     Uint16,
<span class="lineNum">    1599 </span>            :     Int32,
<span class="lineNum">    1600 </span>            :     Uint32,
<span class="lineNum">    1601 </span>            :     Float32,
<span class="lineNum">    1602 </span>            :     Float64,
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span>            :     /**
<span class="lineNum">    1605 </span>            :      * Special type that is a uint8_t, but assignments are clamped to [0, 256).
<span class="lineNum">    1606 </span>            :      * Treat the raw data type as a uint8_t.
<span class="lineNum">    1607 </span>            :      */
<span class="lineNum">    1608 </span>            :     Uint8Clamped,
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            :     /**
<span class="lineNum">    1611 </span>            :      * Types that don't have their own TypedArray equivalent, for now.
<span class="lineNum">    1612 </span>            :      */
<span class="lineNum">    1613 </span>            :     MaxTypedArrayViewType,
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            :     Int64,
<span class="lineNum">    1616 </span>            :     Float32x4,
<span class="lineNum">    1617 </span>            :     Int8x16,
<span class="lineNum">    1618 </span>            :     Int16x8,
<span class="lineNum">    1619 </span>            :     Int32x4
<span class="lineNum">    1620 </span>            : };
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            : static inline size_t
<span class="lineNum">    1623 </span>            : byteSize(Type atype)
<span class="lineNum">    1624 </span><span class="lineCov">          2 : {</span>
<span class="lineNum">    1625 </span>            :     switch (atype) {
<span class="lineNum">    1626 </span><span class="lineCov">          2 :       case Int8:</span>
<span class="lineNum">    1627 </span>            :       case Uint8:
<span class="lineNum">    1628 </span>            :       case Uint8Clamped:
<span class="lineNum">    1629 </span>            :         return 1;
<span class="lineNum">    1630 </span>            :       case Int16:
<span class="lineNum">    1631 </span>            :       case Uint16:
<span class="lineNum">    1632 </span>            :         return 2;
<span class="lineNum">    1633 </span><span class="lineCov">          2 :       case Int32:</span>
<span class="lineNum">    1634 </span>            :       case Uint32:
<span class="lineNum">    1635 </span>            :       case Float32:
<span class="lineNum">    1636 </span>            :         return 4;
<span class="lineNum">    1637 </span><span class="lineCov">          2 :       case Int64:</span>
<span class="lineNum">    1638 </span>            :       case Float64:
<span class="lineNum">    1639 </span>            :         return 8;
<span class="lineNum">    1640 </span><span class="lineCov">          2 :       case Int8x16:</span>
<span class="lineNum">    1641 </span>            :       case Int16x8:
<span class="lineNum">    1642 </span>            :       case Int32x4:
<span class="lineNum">    1643 </span>            :       case Float32x4:
<span class="lineNum">    1644 </span>            :         return 16;
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">    1646 </span>            :         MOZ_CRASH(&quot;invalid scalar type&quot;);
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1648 </span>            : }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span>            : static inline bool
<span class="lineNum">    1651 </span>            : isSignedIntType(Type atype) {
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :     switch (atype) {</span>
<span class="lineNum">    1653 </span>            :       case Int8:
<span class="lineNum">    1654 </span>            :       case Int16:
<span class="lineNum">    1655 </span>            :       case Int32:
<span class="lineNum">    1656 </span>            :       case Int64:
<span class="lineNum">    1657 </span>            :       case Int8x16:
<span class="lineNum">    1658 </span>            :       case Int16x8:
<span class="lineNum">    1659 </span>            :       case Int32x4:
<span class="lineNum">    1660 </span>            :         return true;
<span class="lineNum">    1661 </span>            :       case Uint8:
<span class="lineNum">    1662 </span>            :       case Uint8Clamped:
<span class="lineNum">    1663 </span>            :       case Uint16:
<span class="lineNum">    1664 </span>            :       case Uint32:
<span class="lineNum">    1665 </span>            :       case Float32:
<span class="lineNum">    1666 </span>            :       case Float64:
<span class="lineNum">    1667 </span>            :       case Float32x4:
<span class="lineNum">    1668 </span>            :         return false;
<span class="lineNum">    1669 </span>            :       default:
<span class="lineNum">    1670 </span>            :         MOZ_CRASH(&quot;invalid scalar type&quot;);
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1672 </span>            : }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            : static inline bool
<span class="lineNum">    1675 </span>            : isSimdType(Type atype) {
<span class="lineNum">    1676 </span><span class="lineNoCov">          0 :     switch (atype) {</span>
<span class="lineNum">    1677 </span>            :       case Int8:
<span class="lineNum">    1678 </span>            :       case Uint8:
<span class="lineNum">    1679 </span>            :       case Uint8Clamped:
<span class="lineNum">    1680 </span>            :       case Int16:
<span class="lineNum">    1681 </span>            :       case Uint16:
<span class="lineNum">    1682 </span>            :       case Int32:
<span class="lineNum">    1683 </span>            :       case Uint32:
<span class="lineNum">    1684 </span>            :       case Int64:
<span class="lineNum">    1685 </span>            :       case Float32:
<span class="lineNum">    1686 </span>            :       case Float64:
<span class="lineNum">    1687 </span>            :         return false;
<span class="lineNum">    1688 </span>            :       case Int8x16:
<span class="lineNum">    1689 </span>            :       case Int16x8:
<span class="lineNum">    1690 </span>            :       case Int32x4:
<span class="lineNum">    1691 </span>            :       case Float32x4:
<span class="lineNum">    1692 </span>            :         return true;
<span class="lineNum">    1693 </span>            :       case MaxTypedArrayViewType:
<span class="lineNum">    1694 </span>            :         break;
<span class="lineNum">    1695 </span>            :     }
<span class="lineNum">    1696 </span>            :     MOZ_CRASH(&quot;invalid scalar type&quot;);
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : static inline size_t
<span class="lineNum">    1700 </span>            : scalarByteSize(Type atype) {
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :     switch (atype) {</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :       case Int8x16:</span>
<span class="lineNum">    1703 </span>            :         return 1;
<span class="lineNum">    1704 </span>            :       case Int16x8:
<span class="lineNum">    1705 </span>            :         return 2;
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :       case Int32x4:</span>
<span class="lineNum">    1707 </span>            :       case Float32x4:
<span class="lineNum">    1708 </span>            :         return 4;
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :       case Int8:</span>
<span class="lineNum">    1710 </span>            :       case Uint8:
<span class="lineNum">    1711 </span>            :       case Uint8Clamped:
<span class="lineNum">    1712 </span>            :       case Int16:
<span class="lineNum">    1713 </span>            :       case Uint16:
<span class="lineNum">    1714 </span>            :       case Int32:
<span class="lineNum">    1715 </span>            :       case Uint32:
<span class="lineNum">    1716 </span>            :       case Int64:
<span class="lineNum">    1717 </span>            :       case Float32:
<span class="lineNum">    1718 </span>            :       case Float64:
<span class="lineNum">    1719 </span>            :       case MaxTypedArrayViewType:
<span class="lineNum">    1720 </span>            :         break;
<span class="lineNum">    1721 </span>            :     }
<span class="lineNum">    1722 </span>            :     MOZ_CRASH(&quot;invalid simd type&quot;);
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            : } /* namespace Scalar */
<span class="lineNum">    1726 </span>            : } /* namespace js */
<span class="lineNum">    1727 </span>            : 
<span class="lineNum">    1728 </span>            : /*
<span class="lineNum">    1729 </span>            :  * Create a new typed array with nelements elements.
<span class="lineNum">    1730 </span>            :  *
<span class="lineNum">    1731 </span>            :  * These functions (except the WithBuffer variants) fill in the array with zeros.
<span class="lineNum">    1732 </span>            :  */
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1735 </span>            : JS_NewInt8Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1736 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1737 </span>            : JS_NewUint8Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1738 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1739 </span>            : JS_NewUint8ClampedArray(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1740 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1741 </span>            : JS_NewInt16Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1742 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1743 </span>            : JS_NewUint16Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1744 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1745 </span>            : JS_NewInt32Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1746 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1747 </span>            : JS_NewUint32Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1748 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1749 </span>            : JS_NewFloat32Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1750 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1751 </span>            : JS_NewFloat64Array(JSContext* cx, uint32_t nelements);
<span class="lineNum">    1752 </span>            : 
<span class="lineNum">    1753 </span>            : /*
<span class="lineNum">    1754 </span>            :  * Create a new typed array and copy in values from the given object. The
<span class="lineNum">    1755 </span>            :  * object is used as if it were an array; that is, the new array (if
<span class="lineNum">    1756 </span>            :  * successfully created) will have length given by array.length, and its
<span class="lineNum">    1757 </span>            :  * elements will be those specified by array[0], array[1], and so on, after
<span class="lineNum">    1758 </span>            :  * conversion to the typed array element type.
<span class="lineNum">    1759 </span>            :  */
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1762 </span>            : JS_NewInt8ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1763 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1764 </span>            : JS_NewUint8ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1765 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1766 </span>            : JS_NewUint8ClampedArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1767 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1768 </span>            : JS_NewInt16ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1769 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1770 </span>            : JS_NewUint16ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1771 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1772 </span>            : JS_NewInt32ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1773 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1774 </span>            : JS_NewUint32ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1775 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1776 </span>            : JS_NewFloat32ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1777 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1778 </span>            : JS_NewFloat64ArrayFromArray(JSContext* cx, JS::HandleObject array);
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            : /*
<span class="lineNum">    1781 </span>            :  * Create a new typed array using the given ArrayBuffer or
<span class="lineNum">    1782 </span>            :  * SharedArrayBuffer for storage.  The length value is optional; if -1
<span class="lineNum">    1783 </span>            :  * is passed, enough elements to use up the remainder of the byte
<span class="lineNum">    1784 </span>            :  * array is used as the default value.
<span class="lineNum">    1785 </span>            :  */
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1788 </span>            : JS_NewInt8ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1789 </span>            :                           uint32_t byteOffset, int32_t length);
<span class="lineNum">    1790 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1791 </span>            : JS_NewUint8ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1792 </span>            :                            uint32_t byteOffset, int32_t length);
<span class="lineNum">    1793 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1794 </span>            : JS_NewUint8ClampedArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1795 </span>            :                                   uint32_t byteOffset, int32_t length);
<span class="lineNum">    1796 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1797 </span>            : JS_NewInt16ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1798 </span>            :                            uint32_t byteOffset, int32_t length);
<span class="lineNum">    1799 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1800 </span>            : JS_NewUint16ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1801 </span>            :                             uint32_t byteOffset, int32_t length);
<span class="lineNum">    1802 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1803 </span>            : JS_NewInt32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1804 </span>            :                            uint32_t byteOffset, int32_t length);
<span class="lineNum">    1805 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1806 </span>            : JS_NewUint32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1807 </span>            :                             uint32_t byteOffset, int32_t length);
<span class="lineNum">    1808 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1809 </span>            : JS_NewFloat32ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1810 </span>            :                              uint32_t byteOffset, int32_t length);
<span class="lineNum">    1811 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1812 </span>            : JS_NewFloat64ArrayWithBuffer(JSContext* cx, JS::HandleObject arrayBuffer,
<span class="lineNum">    1813 </span>            :                              uint32_t byteOffset, int32_t length);
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            : /**
<span class="lineNum">    1816 </span>            :  * Create a new SharedArrayBuffer with the given byte length.  This
<span class="lineNum">    1817 </span>            :  * may only be called if
<span class="lineNum">    1818 </span>            :  * JS::RealmCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is
<span class="lineNum">    1819 </span>            :  * true.
<span class="lineNum">    1820 </span>            :  */
<span class="lineNum">    1821 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1822 </span>            : JS_NewSharedArrayBuffer(JSContext* cx, uint32_t nbytes);
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            : /**
<span class="lineNum">    1825 </span>            :  * Create a new ArrayBuffer with the given byte length.
<span class="lineNum">    1826 </span>            :  */
<span class="lineNum">    1827 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1828 </span>            : JS_NewArrayBuffer(JSContext* cx, uint32_t nbytes);
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            : /**
<span class="lineNum">    1831 </span>            :  * Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
<span class="lineNum">    1832 </span>            :  * false if a security wrapper is encountered that denies the unwrapping. If
<span class="lineNum">    1833 </span>            :  * this test or one of the JS_Is*Array tests succeeds, then it is safe to call
<span class="lineNum">    1834 </span>            :  * the various accessor JSAPI calls defined below.
<span class="lineNum">    1835 </span>            :  */
<span class="lineNum">    1836 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1837 </span>            : JS_IsTypedArrayObject(JSObject* obj);
<span class="lineNum">    1838 </span>            : 
<span class="lineNum">    1839 </span>            : /**
<span class="lineNum">    1840 </span>            :  * Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
<span class="lineNum">    1841 </span>            :  * return false if a security wrapper is encountered that denies the
<span class="lineNum">    1842 </span>            :  * unwrapping. If this test or one of the more specific tests succeeds, then it
<span class="lineNum">    1843 </span>            :  * is safe to call the various ArrayBufferView accessor JSAPI calls defined
<span class="lineNum">    1844 </span>            :  * below.
<span class="lineNum">    1845 </span>            :  */
<span class="lineNum">    1846 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1847 </span>            : JS_IsArrayBufferViewObject(JSObject* obj);
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            : /*
<span class="lineNum">    1850 </span>            :  * Test for specific typed array types (ArrayBufferView subtypes)
<span class="lineNum">    1851 </span>            :  */
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1854 </span>            : JS_IsInt8Array(JSObject* obj);
<span class="lineNum">    1855 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1856 </span>            : JS_IsUint8Array(JSObject* obj);
<span class="lineNum">    1857 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1858 </span>            : JS_IsUint8ClampedArray(JSObject* obj);
<span class="lineNum">    1859 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1860 </span>            : JS_IsInt16Array(JSObject* obj);
<span class="lineNum">    1861 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1862 </span>            : JS_IsUint16Array(JSObject* obj);
<span class="lineNum">    1863 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1864 </span>            : JS_IsInt32Array(JSObject* obj);
<span class="lineNum">    1865 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1866 </span>            : JS_IsUint32Array(JSObject* obj);
<span class="lineNum">    1867 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1868 </span>            : JS_IsFloat32Array(JSObject* obj);
<span class="lineNum">    1869 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1870 </span>            : JS_IsFloat64Array(JSObject* obj);
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span>            : /**
<span class="lineNum">    1873 </span>            :  * Return the isShared flag of a typed array, which denotes whether
<span class="lineNum">    1874 </span>            :  * the underlying buffer is a SharedArrayBuffer.
<span class="lineNum">    1875 </span>            :  *
<span class="lineNum">    1876 </span>            :  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
<span class="lineNum">    1877 </span>            :  * be known that it would pass such a test: it is a typed array or a wrapper of
<span class="lineNum">    1878 </span>            :  * a typed array, and the unwrapping will succeed.
<span class="lineNum">    1879 </span>            :  */
<span class="lineNum">    1880 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    1881 </span>            : JS_GetTypedArraySharedness(JSObject* obj);
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            : /*
<span class="lineNum">    1884 </span>            :  * Test for specific typed array types (ArrayBufferView subtypes) and return
<span class="lineNum">    1885 </span>            :  * the unwrapped object if so, else nullptr.  Never throws.
<span class="lineNum">    1886 </span>            :  */
<span class="lineNum">    1887 </span>            : 
<span class="lineNum">    1888 </span>            : namespace js {
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1891 </span>            : UnwrapInt8Array(JSObject* obj);
<span class="lineNum">    1892 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1893 </span>            : UnwrapUint8Array(JSObject* obj);
<span class="lineNum">    1894 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1895 </span>            : UnwrapUint8ClampedArray(JSObject* obj);
<span class="lineNum">    1896 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1897 </span>            : UnwrapInt16Array(JSObject* obj);
<span class="lineNum">    1898 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1899 </span>            : UnwrapUint16Array(JSObject* obj);
<span class="lineNum">    1900 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1901 </span>            : UnwrapInt32Array(JSObject* obj);
<span class="lineNum">    1902 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1903 </span>            : UnwrapUint32Array(JSObject* obj);
<span class="lineNum">    1904 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1905 </span>            : UnwrapFloat32Array(JSObject* obj);
<span class="lineNum">    1906 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1907 </span>            : UnwrapFloat64Array(JSObject* obj);
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1910 </span>            : UnwrapArrayBuffer(JSObject* obj);
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1913 </span>            : UnwrapArrayBufferView(JSObject* obj);
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1916 </span>            : UnwrapSharedArrayBuffer(JSObject* obj);
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1919 </span>            : UnwrapReadableStream(JSObject* obj);
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span>            : namespace detail {
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span>            : extern JS_FRIEND_DATA(const Class* const) Int8ArrayClassPtr;
<span class="lineNum">    1925 </span>            : extern JS_FRIEND_DATA(const Class* const) Uint8ArrayClassPtr;
<span class="lineNum">    1926 </span>            : extern JS_FRIEND_DATA(const Class* const) Uint8ClampedArrayClassPtr;
<span class="lineNum">    1927 </span>            : extern JS_FRIEND_DATA(const Class* const) Int16ArrayClassPtr;
<span class="lineNum">    1928 </span>            : extern JS_FRIEND_DATA(const Class* const) Uint16ArrayClassPtr;
<span class="lineNum">    1929 </span>            : extern JS_FRIEND_DATA(const Class* const) Int32ArrayClassPtr;
<span class="lineNum">    1930 </span>            : extern JS_FRIEND_DATA(const Class* const) Uint32ArrayClassPtr;
<span class="lineNum">    1931 </span>            : extern JS_FRIEND_DATA(const Class* const) Float32ArrayClassPtr;
<span class="lineNum">    1932 </span>            : extern JS_FRIEND_DATA(const Class* const) Float64ArrayClassPtr;
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span>            : const size_t TypedArrayLengthSlot = 1;
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            : } // namespace detail
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span>            : #define JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Type, type) \
<span class="lineNum">    1939 </span>            : inline void \
<span class="lineNum">    1940 </span>            : Get ## Type ## ArrayLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, type** data) \
<span class="lineNum">    1941 </span>            : { \
<span class="lineNum">    1942 </span>            :     MOZ_ASSERT(GetObjectClass(obj) == detail::Type ## ArrayClassPtr); \
<span class="lineNum">    1943 </span>            :     const JS::Value&amp; lenSlot = GetReservedSlot(obj, detail::TypedArrayLengthSlot); \
<span class="lineNum">    1944 </span>            :     *length = mozilla::AssertedCast&lt;uint32_t&gt;(lenSlot.toInt32()); \
<span class="lineNum">    1945 </span>            :     *isSharedMemory = JS_GetTypedArraySharedness(obj); \
<span class="lineNum">    1946 </span>            :     *data = static_cast&lt;type*&gt;(GetObjectPrivate(obj)); \
<span class="lineNum">    1947 </span>            : }
<span class="lineNum">    1948 </span>            : 
<span class="lineNum">    1949 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Int8, int8_t)
<span class="lineNum">    1950 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Uint8, uint8_t)
<span class="lineNum">    1951 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Uint8Clamped, uint8_t)
<span class="lineNum">    1952 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Int16, int16_t)
<span class="lineNum">    1953 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Uint16, uint16_t)
<span class="lineNum">    1954 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Int32, int32_t)
<span class="lineNum">    1955 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Uint32, uint32_t)
<span class="lineNum">    1956 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Float32, float)
<span class="lineNum">    1957 </span>            : JS_DEFINE_DATA_AND_LENGTH_ACCESSOR(Float64, double)
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span>            : #undef JS_DEFINE_DATA_AND_LENGTH_ACCESSOR
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            : // This one isn't inlined because it's rather tricky (by dint of having to deal
<span class="lineNum">    1962 </span>            : // with a dozen-plus classes and varying slot layouts.
<span class="lineNum">    1963 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    1964 </span>            : GetArrayBufferViewLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            : // This one isn't inlined because there are a bunch of different ArrayBuffer
<span class="lineNum">    1967 </span>            : // classes that would have to be individually handled here.
<span class="lineNum">    1968 </span>            : //
<span class="lineNum">    1969 </span>            : // There is an isShared out argument for API consistency (eases use from DOM).
<span class="lineNum">    1970 </span>            : // It will always be set to false.
<span class="lineNum">    1971 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    1972 </span>            : GetArrayBufferLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span>            : // Ditto for SharedArrayBuffer.
<span class="lineNum">    1975 </span>            : //
<span class="lineNum">    1976 </span>            : // There is an isShared out argument for API consistency (eases use from DOM).
<span class="lineNum">    1977 </span>            : // It will always be set to true.
<span class="lineNum">    1978 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    1979 </span>            : GetSharedArrayBufferLengthAndData(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span>            : } // namespace js
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span>            : JS_FRIEND_API(uint8_t*)
<span class="lineNum">    1984 </span>            : JS_GetSharedArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    1985 </span>            : 
<span class="lineNum">    1986 </span>            : /*
<span class="lineNum">    1987 </span>            :  * Unwrap Typed arrays all at once. Return nullptr without throwing if the
<span class="lineNum">    1988 </span>            :  * object cannot be viewed as the correct typed array, or the typed array
<span class="lineNum">    1989 </span>            :  * object on success, filling both outparameters.
<span class="lineNum">    1990 </span>            :  */
<span class="lineNum">    1991 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1992 </span>            : JS_GetObjectAsInt8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int8_t** data);
<span class="lineNum">    1993 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1994 </span>            : JS_GetObjectAsUint8Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
<span class="lineNum">    1995 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1996 </span>            : JS_GetObjectAsUint8ClampedArray(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
<span class="lineNum">    1997 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    1998 </span>            : JS_GetObjectAsInt16Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int16_t** data);
<span class="lineNum">    1999 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2000 </span>            : JS_GetObjectAsUint16Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint16_t** data);
<span class="lineNum">    2001 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2002 </span>            : JS_GetObjectAsInt32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, int32_t** data);
<span class="lineNum">    2003 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2004 </span>            : JS_GetObjectAsUint32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint32_t** data);
<span class="lineNum">    2005 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2006 </span>            : JS_GetObjectAsFloat32Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, float** data);
<span class="lineNum">    2007 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2008 </span>            : JS_GetObjectAsFloat64Array(JSObject* obj, uint32_t* length, bool* isSharedMemory, double** data);
<span class="lineNum">    2009 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2010 </span>            : JS_GetObjectAsArrayBufferView(JSObject* obj, uint32_t* length, bool* isSharedMemory, uint8_t** data);
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span>            : /*
<span class="lineNum">    2013 </span>            :  * Unwrap an ArrayBuffer, return nullptr if it's a different type.
<span class="lineNum">    2014 </span>            :  */
<span class="lineNum">    2015 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2016 </span>            : JS_GetObjectAsArrayBuffer(JSObject* obj, uint32_t* length, uint8_t** data);
<span class="lineNum">    2017 </span>            : 
<span class="lineNum">    2018 </span>            : /*
<span class="lineNum">    2019 </span>            :  * Get the type of elements in a typed array, or MaxTypedArrayViewType if a DataView.
<span class="lineNum">    2020 </span>            :  *
<span class="lineNum">    2021 </span>            :  * |obj| must have passed a JS_IsArrayBufferView/JS_Is*Array test, or somehow
<span class="lineNum">    2022 </span>            :  * be known that it would pass such a test: it is an ArrayBufferView or a
<span class="lineNum">    2023 </span>            :  * wrapper of an ArrayBufferView, and the unwrapping will succeed.
<span class="lineNum">    2024 </span>            :  */
<span class="lineNum">    2025 </span>            : extern JS_FRIEND_API(js::Scalar::Type)
<span class="lineNum">    2026 </span>            : JS_GetArrayBufferViewType(JSObject* obj);
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span>            : extern JS_FRIEND_API(js::Scalar::Type)
<span class="lineNum">    2029 </span>            : JS_GetSharedArrayBufferViewType(JSObject* obj);
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span>            : /*
<span class="lineNum">    2032 </span>            :  * Check whether obj supports the JS_GetArrayBuffer* APIs. Note that this may
<span class="lineNum">    2033 </span>            :  * return false if a security wrapper is encountered that denies the
<span class="lineNum">    2034 </span>            :  * unwrapping. If this test succeeds, then it is safe to call the various
<span class="lineNum">    2035 </span>            :  * accessor JSAPI calls defined below.
<span class="lineNum">    2036 </span>            :  */
<span class="lineNum">    2037 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2038 </span>            : JS_IsArrayBufferObject(JSObject* obj);
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2041 </span>            : JS_IsSharedArrayBufferObject(JSObject* obj);
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            : /**
<span class="lineNum">    2044 </span>            :  * Return the available byte length of an array buffer.
<span class="lineNum">    2045 </span>            :  *
<span class="lineNum">    2046 </span>            :  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
<span class="lineNum">    2047 </span>            :  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
<span class="lineNum">    2048 </span>            :  * ArrayBuffer, and the unwrapping will succeed.
<span class="lineNum">    2049 </span>            :  */
<span class="lineNum">    2050 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2051 </span>            : JS_GetArrayBufferByteLength(JSObject* obj);
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2054 </span>            : JS_GetSharedArrayBufferByteLength(JSObject* obj);
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            : /**
<span class="lineNum">    2057 </span>            :  * Return true if the arrayBuffer contains any data. This will return false for
<span class="lineNum">    2058 </span>            :  * ArrayBuffer.prototype and detached ArrayBuffers.
<span class="lineNum">    2059 </span>            :  *
<span class="lineNum">    2060 </span>            :  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
<span class="lineNum">    2061 </span>            :  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
<span class="lineNum">    2062 </span>            :  * ArrayBuffer, and the unwrapping will succeed.
<span class="lineNum">    2063 </span>            :  */
<span class="lineNum">    2064 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2065 </span>            : JS_ArrayBufferHasData(JSObject* obj);
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span>            : /**
<span class="lineNum">    2068 </span>            :  * Return a pointer to the start of the data referenced by a typed array. The
<span class="lineNum">    2069 </span>            :  * data is still owned by the typed array, and should not be modified on
<span class="lineNum">    2070 </span>            :  * another thread. Furthermore, the pointer can become invalid on GC (if the
<span class="lineNum">    2071 </span>            :  * data is small and fits inside the array's GC header), so callers must take
<span class="lineNum">    2072 </span>            :  * care not to hold on across anything that could GC.
<span class="lineNum">    2073 </span>            :  *
<span class="lineNum">    2074 </span>            :  * |obj| must have passed a JS_IsArrayBufferObject test, or somehow be known
<span class="lineNum">    2075 </span>            :  * that it would pass such a test: it is an ArrayBuffer or a wrapper of an
<span class="lineNum">    2076 </span>            :  * ArrayBuffer, and the unwrapping will succeed.
<span class="lineNum">    2077 </span>            :  *
<span class="lineNum">    2078 </span>            :  * |*isSharedMemory| will be set to false, the argument is present to simplify
<span class="lineNum">    2079 </span>            :  * its use from code that also interacts with SharedArrayBuffer.
<span class="lineNum">    2080 </span>            :  */
<span class="lineNum">    2081 </span>            : extern JS_FRIEND_API(uint8_t*)
<span class="lineNum">    2082 </span>            : JS_GetArrayBufferData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            : /**
<span class="lineNum">    2085 </span>            :  * Check whether the obj is ArrayBufferObject and memory mapped. Note that this
<span class="lineNum">    2086 </span>            :  * may return false if a security wrapper is encountered that denies the
<span class="lineNum">    2087 </span>            :  * unwrapping.
<span class="lineNum">    2088 </span>            :  */
<span class="lineNum">    2089 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2090 </span>            : JS_IsMappedArrayBufferObject(JSObject* obj);
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : /**
<span class="lineNum">    2093 </span>            :  * Return the number of elements in a typed array.
<span class="lineNum">    2094 </span>            :  *
<span class="lineNum">    2095 </span>            :  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
<span class="lineNum">    2096 </span>            :  * be known that it would pass such a test: it is a typed array or a wrapper of
<span class="lineNum">    2097 </span>            :  * a typed array, and the unwrapping will succeed.
<span class="lineNum">    2098 </span>            :  */
<span class="lineNum">    2099 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2100 </span>            : JS_GetTypedArrayLength(JSObject* obj);
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            : /**
<span class="lineNum">    2103 </span>            :  * Return the byte offset from the start of an array buffer to the start of a
<span class="lineNum">    2104 </span>            :  * typed array view.
<span class="lineNum">    2105 </span>            :  *
<span class="lineNum">    2106 </span>            :  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
<span class="lineNum">    2107 </span>            :  * be known that it would pass such a test: it is a typed array or a wrapper of
<span class="lineNum">    2108 </span>            :  * a typed array, and the unwrapping will succeed.
<span class="lineNum">    2109 </span>            :  */
<span class="lineNum">    2110 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2111 </span>            : JS_GetTypedArrayByteOffset(JSObject* obj);
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span>            : /**
<span class="lineNum">    2114 </span>            :  * Return the byte length of a typed array.
<span class="lineNum">    2115 </span>            :  *
<span class="lineNum">    2116 </span>            :  * |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
<span class="lineNum">    2117 </span>            :  * be known that it would pass such a test: it is a typed array or a wrapper of
<span class="lineNum">    2118 </span>            :  * a typed array, and the unwrapping will succeed.
<span class="lineNum">    2119 </span>            :  */
<span class="lineNum">    2120 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2121 </span>            : JS_GetTypedArrayByteLength(JSObject* obj);
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span>            : /**
<span class="lineNum">    2124 </span>            :  * Check whether obj supports JS_ArrayBufferView* APIs. Note that this may
<span class="lineNum">    2125 </span>            :  * return false if a security wrapper is encountered that denies the
<span class="lineNum">    2126 </span>            :  * unwrapping.
<span class="lineNum">    2127 </span>            :  */
<span class="lineNum">    2128 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2129 </span>            : JS_IsArrayBufferViewObject(JSObject* obj);
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span>            : /**
<span class="lineNum">    2132 </span>            :  * More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
<span class="lineNum">    2133 </span>            :  */
<span class="lineNum">    2134 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2135 </span>            : JS_GetArrayBufferViewByteLength(JSObject* obj);
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span>            : /**
<span class="lineNum">    2138 </span>            :  * More generic name for JS_GetTypedArrayByteOffset to cover DataViews as well
<span class="lineNum">    2139 </span>            :  */
<span class="lineNum">    2140 </span>            : extern JS_FRIEND_API(uint32_t)
<span class="lineNum">    2141 </span>            : JS_GetArrayBufferViewByteOffset(JSObject* obj);
<span class="lineNum">    2142 </span>            : 
<span class="lineNum">    2143 </span>            : /*
<span class="lineNum">    2144 </span>            :  * Return a pointer to the start of the data referenced by a typed array. The
<span class="lineNum">    2145 </span>            :  * data is still owned by the typed array, and should not be modified on
<span class="lineNum">    2146 </span>            :  * another thread. Furthermore, the pointer can become invalid on GC (if the
<span class="lineNum">    2147 </span>            :  * data is small and fits inside the array's GC header), so callers must take
<span class="lineNum">    2148 </span>            :  * care not to hold on across anything that could GC.
<span class="lineNum">    2149 </span>            :  *
<span class="lineNum">    2150 </span>            :  * |obj| must have passed a JS_Is*Array test, or somehow be known that it would
<span class="lineNum">    2151 </span>            :  * pass such a test: it is a typed array or a wrapper of a typed array, and the
<span class="lineNum">    2152 </span>            :  * unwrapping will succeed.
<span class="lineNum">    2153 </span>            :  *
<span class="lineNum">    2154 </span>            :  * |*isSharedMemory| will be set to true if the typed array maps a
<span class="lineNum">    2155 </span>            :  * SharedArrayBuffer, otherwise to false.
<span class="lineNum">    2156 </span>            :  */
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span>            : extern JS_FRIEND_API(int8_t*)
<span class="lineNum">    2159 </span>            : JS_GetInt8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2160 </span>            : extern JS_FRIEND_API(uint8_t*)
<span class="lineNum">    2161 </span>            : JS_GetUint8ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2162 </span>            : extern JS_FRIEND_API(uint8_t*)
<span class="lineNum">    2163 </span>            : JS_GetUint8ClampedArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2164 </span>            : extern JS_FRIEND_API(int16_t*)
<span class="lineNum">    2165 </span>            : JS_GetInt16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2166 </span>            : extern JS_FRIEND_API(uint16_t*)
<span class="lineNum">    2167 </span>            : JS_GetUint16ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2168 </span>            : extern JS_FRIEND_API(int32_t*)
<span class="lineNum">    2169 </span>            : JS_GetInt32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2170 </span>            : extern JS_FRIEND_API(uint32_t*)
<span class="lineNum">    2171 </span>            : JS_GetUint32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2172 </span>            : extern JS_FRIEND_API(float*)
<span class="lineNum">    2173 </span>            : JS_GetFloat32ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2174 </span>            : extern JS_FRIEND_API(double*)
<span class="lineNum">    2175 </span>            : JS_GetFloat64ArrayData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            : /**
<span class="lineNum">    2178 </span>            :  * Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
<span class="lineNum">    2179 </span>            :  * versions when possible.
<span class="lineNum">    2180 </span>            :  */
<span class="lineNum">    2181 </span>            : extern JS_FRIEND_API(void*)
<span class="lineNum">    2182 </span>            : JS_GetArrayBufferViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span>            : /**
<span class="lineNum">    2185 </span>            :  * Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.
<span class="lineNum">    2186 </span>            :  * This may return a detached buffer.  |obj| must be an object that would
<span class="lineNum">    2187 </span>            :  * return true for JS_IsArrayBufferViewObject().
<span class="lineNum">    2188 </span>            :  */
<span class="lineNum">    2189 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2190 </span>            : JS_GetArrayBufferViewBuffer(JSContext* cx, JS::HandleObject obj, bool* isSharedMemory);
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span>            : /**
<span class="lineNum">    2193 </span>            :  * Detach an ArrayBuffer, causing all associated views to no longer refer to
<span class="lineNum">    2194 </span>            :  * the ArrayBuffer's original attached memory.
<span class="lineNum">    2195 </span>            :  *
<span class="lineNum">    2196 </span>            :  * The |changeData| argument is obsolete and ignored.
<span class="lineNum">    2197 </span>            :  */
<span class="lineNum">    2198 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2199 </span>            : JS_DetachArrayBuffer(JSContext* cx, JS::HandleObject obj);
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span>            : /**
<span class="lineNum">    2202 </span>            :  * Check whether the obj is a detached ArrayBufferObject. Note that this may
<span class="lineNum">    2203 </span>            :  * return false if a security wrapper is encountered that denies the
<span class="lineNum">    2204 </span>            :  * unwrapping.
<span class="lineNum">    2205 </span>            :  */
<span class="lineNum">    2206 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2207 </span>            : JS_IsDetachedArrayBufferObject(JSObject* obj);
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span>            : /**
<span class="lineNum">    2210 </span>            :  * Check whether obj supports JS_GetDataView* APIs.
<span class="lineNum">    2211 </span>            :  */
<span class="lineNum">    2212 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    2213 </span>            : JS_IsDataViewObject(JSObject* obj);
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            : /**
<span class="lineNum">    2216 </span>            :  * Create a new DataView using the given buffer for storage. The given buffer
<span class="lineNum">    2217 </span>            :  * must be an ArrayBuffer or SharedArrayBuffer (or a cross-compartment wrapper
<span class="lineNum">    2218 </span>            :  * of either type), and the offset and length must fit within the bounds of the
<span class="lineNum">    2219 </span>            :  * buffer. Currently, nullptr will be returned and an exception will be thrown
<span class="lineNum">    2220 </span>            :  * if these conditions do not hold, but do not depend on that behavior.
<span class="lineNum">    2221 </span>            :  */
<span class="lineNum">    2222 </span>            : JS_FRIEND_API(JSObject*)
<span class="lineNum">    2223 </span>            : JS_NewDataView(JSContext* cx, JS::HandleObject buffer, uint32_t byteOffset, int32_t byteLength);
<span class="lineNum">    2224 </span>            : 
<span class="lineNum">    2225 </span>            : /**
<span class="lineNum">    2226 </span>            :  * Return the byte offset of a data view into its array buffer. |obj| must be a
<span class="lineNum">    2227 </span>            :  * DataView.
<span class="lineNum">    2228 </span>            :  *
<span class="lineNum">    2229 </span>            :  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
<span class="lineNum">    2230 </span>            :  * it would pass such a test: it is a data view or a wrapper of a data view,
<span class="lineNum">    2231 </span>            :  * and the unwrapping will succeed.
<span class="lineNum">    2232 </span>            :  */
<span class="lineNum">    2233 </span>            : JS_FRIEND_API(uint32_t)
<span class="lineNum">    2234 </span>            : JS_GetDataViewByteOffset(JSObject* obj);
<span class="lineNum">    2235 </span>            : 
<span class="lineNum">    2236 </span>            : /**
<span class="lineNum">    2237 </span>            :  * Return the byte length of a data view.
<span class="lineNum">    2238 </span>            :  *
<span class="lineNum">    2239 </span>            :  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
<span class="lineNum">    2240 </span>            :  * it would pass such a test: it is a data view or a wrapper of a data view,
<span class="lineNum">    2241 </span>            :  * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
<span class="lineNum">    2242 </span>            :  * unable to assert when unwrapping should be disallowed.
<span class="lineNum">    2243 </span>            :  */
<span class="lineNum">    2244 </span>            : JS_FRIEND_API(uint32_t)
<span class="lineNum">    2245 </span>            : JS_GetDataViewByteLength(JSObject* obj);
<span class="lineNum">    2246 </span>            : 
<span class="lineNum">    2247 </span>            : /**
<span class="lineNum">    2248 </span>            :  * Return a pointer to the beginning of the data referenced by a DataView.
<span class="lineNum">    2249 </span>            :  *
<span class="lineNum">    2250 </span>            :  * |obj| must have passed a JS_IsDataViewObject test, or somehow be known that
<span class="lineNum">    2251 </span>            :  * it would pass such a test: it is a data view or a wrapper of a data view,
<span class="lineNum">    2252 </span>            :  * and the unwrapping will succeed. If cx is nullptr, then DEBUG builds may be
<span class="lineNum">    2253 </span>            :  * unable to assert when unwrapping should be disallowed.
<span class="lineNum">    2254 </span>            :  *
<span class="lineNum">    2255 </span>            :  * |*isSharedMemory| will be set to true if the DataView maps a SharedArrayBuffer,
<span class="lineNum">    2256 </span>            :  * otherwise to false.
<span class="lineNum">    2257 </span>            :  */
<span class="lineNum">    2258 </span>            : JS_FRIEND_API(void*)
<span class="lineNum">    2259 </span>            : JS_GetDataViewData(JSObject* obj, bool* isSharedMemory, const JS::AutoRequireNoGC&amp;);
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span>            : namespace js {
<span class="lineNum">    2262 </span>            : namespace jit {
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span>            : enum class InlinableNative : uint16_t;
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span>            : } // namespace jit
<span class="lineNum">    2267 </span>            : } // namespace js
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span>            : /**
<span class="lineNum">    2270 </span>            :  * A class, expected to be passed by value, which represents the CallArgs for a
<span class="lineNum">    2271 </span>            :  * JSJitGetterOp.
<span class="lineNum">    2272 </span>            :  */
<span class="lineNum">    2273 </span>            : class JSJitGetterCallArgs : protected JS::MutableHandleValue
<span class="lineNum">    2274 </span>            : {
<span class="lineNum">    2275 </span>            :   public:
<span class="lineNum">    2276 </span>            :     explicit JSJitGetterCallArgs(const JS::CallArgs&amp; args)
<span class="lineNum">    2277 </span>            :       : JS::MutableHandleValue(args.rval())
<span class="lineNum">    2278 </span>            :     {}
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span>            :     explicit JSJitGetterCallArgs(JS::RootedValue* rooted)
<span class="lineNum">    2281 </span>            :       : JS::MutableHandleValue(rooted)
<span class="lineNum">    2282 </span>            :     {}
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            :     JS::MutableHandleValue rval() {
<span class="lineNum">    2285 </span>            :         return *this;
<span class="lineNum">    2286 </span>            :     }
<span class="lineNum">    2287 </span>            : };
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span>            : /**
<span class="lineNum">    2290 </span>            :  * A class, expected to be passed by value, which represents the CallArgs for a
<span class="lineNum">    2291 </span>            :  * JSJitSetterOp.
<span class="lineNum">    2292 </span>            :  */
<span class="lineNum">    2293 </span>            : class JSJitSetterCallArgs : protected JS::MutableHandleValue
<span class="lineNum">    2294 </span>            : {
<span class="lineNum">    2295 </span>            :   public:
<span class="lineNum">    2296 </span>            :     explicit JSJitSetterCallArgs(const JS::CallArgs&amp; args)
<span class="lineNum">    2297 </span>            :       : JS::MutableHandleValue(args[0])
<span class="lineNum">    2298 </span>            :     {}
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span>            :     JS::MutableHandleValue operator[](unsigned i) {
<span class="lineNum">    2301 </span>            :         MOZ_ASSERT(i == 0);
<span class="lineNum">    2302 </span>            :         return *this;
<span class="lineNum">    2303 </span>            :     }
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span>            :     unsigned length() const { return 1; }
<span class="lineNum">    2306 </span>            : 
<span class="lineNum">    2307 </span>            :     // Add get() or maybe hasDefined() as needed
<span class="lineNum">    2308 </span>            : };
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span>            : struct JSJitMethodCallArgsTraits;
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            : /**
<span class="lineNum">    2313 </span>            :  * A class, expected to be passed by reference, which represents the CallArgs
<span class="lineNum">    2314 </span>            :  * for a JSJitMethodOp.
<span class="lineNum">    2315 </span>            :  */
<span class="lineNum">    2316 </span>            : class JSJitMethodCallArgs : protected JS::detail::CallArgsBase&lt;JS::detail::NoUsedRval&gt;
<span class="lineNum">    2317 </span>            : {
<span class="lineNum">    2318 </span>            :   private:
<span class="lineNum">    2319 </span>            :     typedef JS::detail::CallArgsBase&lt;JS::detail::NoUsedRval&gt; Base;
<span class="lineNum">    2320 </span>            :     friend struct JSJitMethodCallArgsTraits;
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span>            :   public:
<span class="lineNum">    2323 </span>            :     explicit JSJitMethodCallArgs(const JS::CallArgs&amp; args) {
<span class="lineNum">    2324 </span>            :         argv_ = args.array();
<span class="lineNum">    2325 </span>            :         argc_ = args.length();
<span class="lineNum">    2326 </span>            :     }
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            :     JS::MutableHandleValue rval() const {
<span class="lineNum">    2329 </span>            :         return Base::rval();
<span class="lineNum">    2330 </span>            :     }
<span class="lineNum">    2331 </span>            : 
<span class="lineNum">    2332 </span>            :     unsigned length() const { return Base::length(); }
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span>            :     JS::MutableHandleValue operator[](unsigned i) const {
<span class="lineNum">    2335 </span>            :         return Base::operator[](i);
<span class="lineNum">    2336 </span>            :     }
<span class="lineNum">    2337 </span>            : 
<span class="lineNum">    2338 </span>            :     bool hasDefined(unsigned i) const {
<span class="lineNum">    2339 </span>            :         return Base::hasDefined(i);
<span class="lineNum">    2340 </span>            :     }
<span class="lineNum">    2341 </span>            : 
<span class="lineNum">    2342 </span>            :     JSObject&amp; callee() const {
<span class="lineNum">    2343 </span>            :         // We can't use Base::callee() because that will try to poke at
<span class="lineNum">    2344 </span>            :         // this-&gt;usedRval_, which we don't have.
<span class="lineNum">    2345 </span>            :         return argv_[-2].toObject();
<span class="lineNum">    2346 </span>            :     }
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span>            :     JS::HandleValue get(unsigned i) const {
<span class="lineNum">    2349 </span>            :         return Base::get(i);
<span class="lineNum">    2350 </span>            :     }
<span class="lineNum">    2351 </span>            : };
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            : struct JSJitMethodCallArgsTraits
<span class="lineNum">    2354 </span>            : {
<span class="lineNum">    2355 </span>            :     static const size_t offsetOfArgv = offsetof(JSJitMethodCallArgs, argv_);
<span class="lineNum">    2356 </span>            :     static const size_t offsetOfArgc = offsetof(JSJitMethodCallArgs, argc_);
<span class="lineNum">    2357 </span>            : };
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            : typedef bool
<span class="lineNum">    2360 </span>            : (* JSJitGetterOp)(JSContext* cx, JS::HandleObject thisObj,
<span class="lineNum">    2361 </span>            :                   void* specializedThis, JSJitGetterCallArgs args);
<span class="lineNum">    2362 </span>            : typedef bool
<span class="lineNum">    2363 </span>            : (* JSJitSetterOp)(JSContext* cx, JS::HandleObject thisObj,
<span class="lineNum">    2364 </span>            :                   void* specializedThis, JSJitSetterCallArgs args);
<span class="lineNum">    2365 </span>            : typedef bool
<span class="lineNum">    2366 </span>            : (* JSJitMethodOp)(JSContext* cx, JS::HandleObject thisObj,
<span class="lineNum">    2367 </span>            :                   void* specializedThis, const JSJitMethodCallArgs&amp; args);
<span class="lineNum">    2368 </span>            : 
<span class="lineNum">    2369 </span>            : /**
<span class="lineNum">    2370 </span>            :  * This struct contains metadata passed from the DOM to the JS Engine for JIT
<span class="lineNum">    2371 </span>            :  * optimizations on DOM property accessors. Eventually, this should be made
<span class="lineNum">    2372 </span>            :  * available to general JSAPI users, but we are not currently ready to do so.
<span class="lineNum">    2373 </span>            :  */
<span class="lineNum">    2374 </span>            : struct JSJitInfo {
<span class="lineNum">    2375 </span>            :     enum OpType {
<span class="lineNum">    2376 </span>            :         Getter,
<span class="lineNum">    2377 </span>            :         Setter,
<span class="lineNum">    2378 </span>            :         Method,
<span class="lineNum">    2379 </span>            :         StaticMethod,
<span class="lineNum">    2380 </span>            :         InlinableNative,
<span class="lineNum">    2381 </span>            :         IgnoresReturnValueNative,
<span class="lineNum">    2382 </span>            :         // Must be last
<span class="lineNum">    2383 </span>            :         OpTypeCount
<span class="lineNum">    2384 </span>            :     };
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span>            :     enum ArgType {
<span class="lineNum">    2387 </span>            :         // Basic types
<span class="lineNum">    2388 </span>            :         String = (1 &lt;&lt; 0),
<span class="lineNum">    2389 </span>            :         Integer = (1 &lt;&lt; 1), // Only 32-bit or less
<span class="lineNum">    2390 </span>            :         Double = (1 &lt;&lt; 2), // Maybe we want to add Float sometime too
<span class="lineNum">    2391 </span>            :         Boolean = (1 &lt;&lt; 3),
<span class="lineNum">    2392 </span>            :         Object = (1 &lt;&lt; 4),
<span class="lineNum">    2393 </span>            :         Null = (1 &lt;&lt; 5),
<span class="lineNum">    2394 </span>            : 
<span class="lineNum">    2395 </span>            :         // And derived types
<span class="lineNum">    2396 </span>            :         Numeric = Integer | Double,
<span class="lineNum">    2397 </span>            :         // Should &quot;Primitive&quot; use the WebIDL definition, which
<span class="lineNum">    2398 </span>            :         // excludes string and null, or the typical JS one that includes them?
<span class="lineNum">    2399 </span>            :         Primitive = Numeric | Boolean | Null | String,
<span class="lineNum">    2400 </span>            :         ObjectOrNull = Object | Null,
<span class="lineNum">    2401 </span>            :         Any = ObjectOrNull | Primitive,
<span class="lineNum">    2402 </span>            : 
<span class="lineNum">    2403 </span>            :         // Our sentinel value.
<span class="lineNum">    2404 </span>            :         ArgTypeListEnd = (1 &lt;&lt; 31)
<span class="lineNum">    2405 </span>            :     };
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span>            :     static_assert(Any &amp; String, &quot;Any must include String.&quot;);
<span class="lineNum">    2408 </span>            :     static_assert(Any &amp; Integer, &quot;Any must include Integer.&quot;);
<span class="lineNum">    2409 </span>            :     static_assert(Any &amp; Double, &quot;Any must include Double.&quot;);
<span class="lineNum">    2410 </span>            :     static_assert(Any &amp; Boolean, &quot;Any must include Boolean.&quot;);
<span class="lineNum">    2411 </span>            :     static_assert(Any &amp; Object, &quot;Any must include Object.&quot;);
<span class="lineNum">    2412 </span>            :     static_assert(Any &amp; Null, &quot;Any must include Null.&quot;);
<span class="lineNum">    2413 </span>            : 
<span class="lineNum">    2414 </span>            :     /**
<span class="lineNum">    2415 </span>            :      * An enum that describes what this getter/setter/method aliases.  This
<span class="lineNum">    2416 </span>            :      * determines what things can be hoisted past this call, and if this
<span class="lineNum">    2417 </span>            :      * call is movable what it can be hoisted past.
<span class="lineNum">    2418 </span>            :      */
<span class="lineNum">    2419 </span>            :     enum AliasSet {
<span class="lineNum">    2420 </span>            :         /**
<span class="lineNum">    2421 </span>            :          * Alias nothing: a constant value, getting it can't affect any other
<span class="lineNum">    2422 </span>            :          * values, nothing can affect it.
<span class="lineNum">    2423 </span>            :          */
<span class="lineNum">    2424 </span>            :         AliasNone,
<span class="lineNum">    2425 </span>            : 
<span class="lineNum">    2426 </span>            :         /**
<span class="lineNum">    2427 </span>            :          * Alias things that can modify the DOM but nothing else.  Doing the
<span class="lineNum">    2428 </span>            :          * call can't affect the behavior of any other function.
<span class="lineNum">    2429 </span>            :          */
<span class="lineNum">    2430 </span>            :         AliasDOMSets,
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span>            :         /**
<span class="lineNum">    2433 </span>            :          * Alias the world.  Calling this can change arbitrary values anywhere
<span class="lineNum">    2434 </span>            :          * in the system.  Most things fall in this bucket.
<span class="lineNum">    2435 </span>            :          */
<span class="lineNum">    2436 </span>            :         AliasEverything,
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span>            :         /** Must be last. */
<span class="lineNum">    2439 </span>            :         AliasSetCount
<span class="lineNum">    2440 </span>            :     };
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span>            :     bool needsOuterizedThisObject() const
<span class="lineNum">    2443 </span>            :     {
<span class="lineNum">    2444 </span>            :         return type() != Getter &amp;&amp; type() != Setter;
<span class="lineNum">    2445 </span><span class="lineCov">      77988 :     }</span>
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span>            :     bool isTypedMethodJitInfo() const
<span class="lineNum">    2448 </span>            :     {
<span class="lineNum">    2449 </span>            :         return isTypedMethod;
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span>            :     OpType type() const
<span class="lineNum">    2453 </span>            :     {
<span class="lineNum">    2454 </span>            :         return OpType(type_);
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span>            :     AliasSet aliasSet() const
<span class="lineNum">    2458 </span>            :     {
<span class="lineNum">    2459 </span>            :         return AliasSet(aliasSet_);
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span>            :     JSValueType returnType() const
<span class="lineNum">    2463 </span>            :     {
<span class="lineNum">    2464 </span>            :         return JSValueType(returnType_);
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span>            :     union {
<span class="lineNum">    2468 </span>            :         JSJitGetterOp getter;
<span class="lineNum">    2469 </span>            :         JSJitSetterOp setter;
<span class="lineNum">    2470 </span>            :         JSJitMethodOp method;
<span class="lineNum">    2471 </span>            :         /** A DOM static method, used for Promise wrappers */
<span class="lineNum">    2472 </span>            :         JSNative staticMethod;
<span class="lineNum">    2473 </span>            :         JSNative ignoresReturnValueMethod;
<span class="lineNum">    2474 </span>            :     };
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span>            :     static unsigned offsetOfIgnoresReturnValueNative() {
<span class="lineNum">    2477 </span>            :         return offsetof(JSJitInfo, ignoresReturnValueMethod);
<span class="lineNum">    2478 </span>            :     }
<span class="lineNum">    2479 </span>            : 
<span class="lineNum">    2480 </span>            :     union {
<span class="lineNum">    2481 </span>            :         uint16_t protoID;
<span class="lineNum">    2482 </span>            :         js::jit::InlinableNative inlinableNative;
<span class="lineNum">    2483 </span>            :     };
<span class="lineNum">    2484 </span>            : 
<span class="lineNum">    2485 </span>            :     union {
<span class="lineNum">    2486 </span>            :         uint16_t depth;
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span>            :         // Additional opcode for some InlinableNative functions.
<span class="lineNum">    2489 </span>            :         uint16_t nativeOp;
<span class="lineNum">    2490 </span>            :     };
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            :     // These fields are carefully packed to take up 4 bytes.  If you need more
<span class="lineNum">    2493 </span>            :     // bits for whatever reason, please see if you can steal bits from existing
<span class="lineNum">    2494 </span>            :     // fields before adding more members to this structure.
<span class="lineNum">    2495 </span>            : 
<span class="lineNum">    2496 </span>            : #define JITINFO_OP_TYPE_BITS 4
<span class="lineNum">    2497 </span>            : #define JITINFO_ALIAS_SET_BITS 4
<span class="lineNum">    2498 </span>            : #define JITINFO_RETURN_TYPE_BITS 8
<span class="lineNum">    2499 </span>            : #define JITINFO_SLOT_INDEX_BITS 10
<span class="lineNum">    2500 </span>            : 
<span class="lineNum">    2501 </span>            :     /** The OpType that says what sort of function we are. */
<span class="lineNum">    2502 </span>            :     uint32_t type_ : JITINFO_OP_TYPE_BITS;
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span>            :     /**
<span class="lineNum">    2505 </span>            :      * The alias set for this op.  This is a _minimal_ alias set; in
<span class="lineNum">    2506 </span>            :      * particular for a method it does not include whatever argument
<span class="lineNum">    2507 </span>            :      * conversions might do.  That's covered by argTypes and runtime
<span class="lineNum">    2508 </span>            :      * analysis of the actual argument types being passed in.
<span class="lineNum">    2509 </span>            :      */
<span class="lineNum">    2510 </span>            :     uint32_t aliasSet_ : JITINFO_ALIAS_SET_BITS;
<span class="lineNum">    2511 </span>            : 
<span class="lineNum">    2512 </span>            :     /** The return type tag.  Might be JSVAL_TYPE_UNKNOWN. */
<span class="lineNum">    2513 </span>            :     uint32_t returnType_ : JITINFO_RETURN_TYPE_BITS;
<span class="lineNum">    2514 </span>            : 
<span class="lineNum">    2515 </span>            :     static_assert(OpTypeCount &lt;= (1 &lt;&lt; JITINFO_OP_TYPE_BITS),
<span class="lineNum">    2516 </span>            :                   &quot;Not enough space for OpType&quot;);
<span class="lineNum">    2517 </span>            :     static_assert(AliasSetCount &lt;= (1 &lt;&lt; JITINFO_ALIAS_SET_BITS),
<span class="lineNum">    2518 </span>            :                   &quot;Not enough space for AliasSet&quot;);
<span class="lineNum">    2519 </span>            :     static_assert((sizeof(JSValueType) * 8) &lt;= JITINFO_RETURN_TYPE_BITS,
<span class="lineNum">    2520 </span>            :                   &quot;Not enough space for JSValueType&quot;);
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span>            : #undef JITINFO_RETURN_TYPE_BITS
<span class="lineNum">    2523 </span>            : #undef JITINFO_ALIAS_SET_BITS
<span class="lineNum">    2524 </span>            : #undef JITINFO_OP_TYPE_BITS
<span class="lineNum">    2525 </span>            : 
<span class="lineNum">    2526 </span>            :     /** Is op fallible? False in setters. */
<span class="lineNum">    2527 </span>            :     uint32_t isInfallible : 1;
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span>            :     /**
<span class="lineNum">    2530 </span>            :      * Is op movable?  To be movable the op must
<span class="lineNum">    2531 </span>            :      * not AliasEverything, but even that might
<span class="lineNum">    2532 </span>            :      * not be enough (e.g. in cases when it can
<span class="lineNum">    2533 </span>            :      * throw or is explicitly not movable).
<span class="lineNum">    2534 </span>            :      */
<span class="lineNum">    2535 </span>            :     uint32_t isMovable : 1;
<span class="lineNum">    2536 </span>            : 
<span class="lineNum">    2537 </span>            :     /**
<span class="lineNum">    2538 </span>            :      * Can op be dead-code eliminated? Again, this
<span class="lineNum">    2539 </span>            :      * depends on whether the op can throw, in
<span class="lineNum">    2540 </span>            :      * addition to the alias set.
<span class="lineNum">    2541 </span>            :      */
<span class="lineNum">    2542 </span>            :     uint32_t isEliminatable : 1;
<span class="lineNum">    2543 </span>            : 
<span class="lineNum">    2544 </span>            :     // XXXbz should we have a JSValueType for the type of the member?
<span class="lineNum">    2545 </span>            :     /**
<span class="lineNum">    2546 </span>            :      * True if this is a getter that can always
<span class="lineNum">    2547 </span>            :      * get the value from a slot of the &quot;this&quot; object.
<span class="lineNum">    2548 </span>            :      */
<span class="lineNum">    2549 </span>            :     uint32_t isAlwaysInSlot : 1;
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span>            :     /**
<span class="lineNum">    2552 </span>            :      * True if this is a getter that can sometimes (if the slot doesn't contain
<span class="lineNum">    2553 </span>            :      * UndefinedValue()) get the value from a slot of the &quot;this&quot; object.
<span class="lineNum">    2554 </span>            :      */
<span class="lineNum">    2555 </span>            :     uint32_t isLazilyCachedInSlot : 1;
<span class="lineNum">    2556 </span>            : 
<span class="lineNum">    2557 </span>            :     /** True if this is an instance of JSTypedMethodJitInfo. */
<span class="lineNum">    2558 </span>            :     uint32_t isTypedMethod : 1;
<span class="lineNum">    2559 </span>            : 
<span class="lineNum">    2560 </span>            :     /**
<span class="lineNum">    2561 </span>            :      * If isAlwaysInSlot or isSometimesInSlot is true,
<span class="lineNum">    2562 </span>            :      * the index of the slot to get the value from.
<span class="lineNum">    2563 </span>            :      * Otherwise 0.
<span class="lineNum">    2564 </span>            :      */
<span class="lineNum">    2565 </span>            :     uint32_t slotIndex : JITINFO_SLOT_INDEX_BITS;
<span class="lineNum">    2566 </span>            : 
<span class="lineNum">    2567 </span>            :     static const size_t maxSlotIndex = (1 &lt;&lt; JITINFO_SLOT_INDEX_BITS) - 1;
<span class="lineNum">    2568 </span>            : 
<span class="lineNum">    2569 </span>            : #undef JITINFO_SLOT_INDEX_BITS
<span class="lineNum">    2570 </span>            : };
<span class="lineNum">    2571 </span>            : 
<span class="lineNum">    2572 </span>            : static_assert(sizeof(JSJitInfo) == (sizeof(void*) + 2 * sizeof(uint32_t)),
<span class="lineNum">    2573 </span>            :               &quot;There are several thousand instances of JSJitInfo stored in &quot;
<span class="lineNum">    2574 </span>            :               &quot;a binary. Please don't increase its space requirements without &quot;
<span class="lineNum">    2575 </span>            :               &quot;verifying that there is no other way forward (better packing, &quot;
<span class="lineNum">    2576 </span>            :               &quot;smaller datatypes for fields, subclassing, etc.).&quot;);
<span class="lineNum">    2577 </span>            : 
<span class="lineNum">    2578 </span>            : struct JSTypedMethodJitInfo
<span class="lineNum">    2579 </span>            : {
<span class="lineNum">    2580 </span>            :     // We use C-style inheritance here, rather than C++ style inheritance
<span class="lineNum">    2581 </span>            :     // because not all compilers support brace-initialization for non-aggregate
<span class="lineNum">    2582 </span>            :     // classes. Using C++ style inheritance and constructors instead of
<span class="lineNum">    2583 </span>            :     // brace-initialization would also force the creation of static
<span class="lineNum">    2584 </span>            :     // constructors (on some compilers) when JSJitInfo and JSTypedMethodJitInfo
<span class="lineNum">    2585 </span>            :     // structures are declared. Since there can be several thousand of these
<span class="lineNum">    2586 </span>            :     // structures present and we want to have roughly equivalent performance
<span class="lineNum">    2587 </span>            :     // across a range of compilers, we do things manually.
<span class="lineNum">    2588 </span>            :     JSJitInfo base;
<span class="lineNum">    2589 </span>            : 
<span class="lineNum">    2590 </span>            :     const JSJitInfo::ArgType* const argTypes; /* For a method, a list of sets of
<span class="lineNum">    2591 </span>            :                                                  types that the function
<span class="lineNum">    2592 </span>            :                                                  expects.  This can be used,
<span class="lineNum">    2593 </span>            :                                                  for example, to figure out
<span class="lineNum">    2594 </span>            :                                                  when argument coercions can
<span class="lineNum">    2595 </span>            :                                                  have side-effects. */
<span class="lineNum">    2596 </span>            : };
<span class="lineNum">    2597 </span>            : 
<span class="lineNum">    2598 </span>            : namespace js {
<span class="lineNum">    2599 </span>            : 
<span class="lineNum">    2600 </span>            : static MOZ_ALWAYS_INLINE shadow::Function*
<span class="lineNum">    2601 </span>            : FunctionObjectToShadowFunction(JSObject* fun)
<span class="lineNum">    2602 </span>            : {
<span class="lineNum">    2603 </span>            :     MOZ_ASSERT(GetObjectClass(fun) == FunctionClassPtr);
<span class="lineNum">    2604 </span>            :     return reinterpret_cast&lt;shadow::Function*&gt;(fun);
<span class="lineNum">    2605 </span>            : }
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span>            : /* Statically asserted in JSFunction.h. */
<span class="lineNum">    2608 </span>            : static const unsigned JS_FUNCTION_INTERPRETED_BITS = 0x0201;
<span class="lineNum">    2609 </span>            : 
<span class="lineNum">    2610 </span>            : // Return whether the given function object is native.
<span class="lineNum">    2611 </span>            : static MOZ_ALWAYS_INLINE bool
<span class="lineNum">    2612 </span>            : FunctionObjectIsNative(JSObject* fun)
<span class="lineNum">    2613 </span>            : {
<span class="lineNum">    2614 </span>            :     return !(FunctionObjectToShadowFunction(fun)-&gt;flags &amp; JS_FUNCTION_INTERPRETED_BITS);
<span class="lineNum">    2615 </span>            : }
<span class="lineNum">    2616 </span>            : 
<span class="lineNum">    2617 </span>            : static MOZ_ALWAYS_INLINE JSNative
<span class="lineNum">    2618 </span>            : GetFunctionObjectNative(JSObject* fun)
<span class="lineNum">    2619 </span>            : {
<span class="lineNum">    2620 </span>            :     MOZ_ASSERT(FunctionObjectIsNative(fun));
<span class="lineNum">    2621 </span>            :     return FunctionObjectToShadowFunction(fun)-&gt;native;
<span class="lineNum">    2622 </span>            : }
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span>            : } // namespace js
<span class="lineNum">    2625 </span>            : 
<span class="lineNum">    2626 </span>            : static MOZ_ALWAYS_INLINE const JSJitInfo*
<span class="lineNum">    2627 </span>            : FUNCTION_VALUE_TO_JITINFO(const JS::Value&amp; v)
<span class="lineNum">    2628 </span>            : {
<span class="lineNum">    2629 </span>            :     MOZ_ASSERT(js::FunctionObjectIsNative(&amp;v.toObject()));
<span class="lineNum">    2630 </span>            :     return js::FunctionObjectToShadowFunction(&amp;v.toObject())-&gt;jitinfo;
<span class="lineNum">    2631 </span>            : }
<span class="lineNum">    2632 </span>            : 
<span class="lineNum">    2633 </span>            : static MOZ_ALWAYS_INLINE void
<span class="lineNum">    2634 </span>            : SET_JITINFO(JSFunction * func, const JSJitInfo* info)
<span class="lineNum">    2635 </span>            : {
<span class="lineNum">    2636 </span>            :     js::shadow::Function* fun = reinterpret_cast&lt;js::shadow::Function*&gt;(func);
<span class="lineNum">    2637 </span>            :     MOZ_ASSERT(!(fun-&gt;flags &amp; js::JS_FUNCTION_INTERPRETED_BITS));
<span class="lineNum">    2638 </span>            :     fun-&gt;jitinfo = info;
<span class="lineNum">    2639 </span>            : }
<span class="lineNum">    2640 </span>            : 
<span class="lineNum">    2641 </span>            : /*
<span class="lineNum">    2642 </span>            :  * Engine-internal extensions of jsid.  This code is here only until we
<span class="lineNum">    2643 </span>            :  * eliminate Gecko's dependencies on it!
<span class="lineNum">    2644 </span>            :  */
<span class="lineNum">    2645 </span>            : 
<span class="lineNum">    2646 </span>            : static MOZ_ALWAYS_INLINE jsid
<span class="lineNum">    2647 </span>            : JSID_FROM_BITS(size_t bits)
<span class="lineNum">    2648 </span>            : {
<span class="lineNum">    2649 </span>            :     jsid id;
<span class="lineNum">    2650 </span><span class="lineCov">          2 :     JSID_BITS(id) = bits;</span>
<span class="lineNum">    2651 </span><span class="lineCov">          2 :     return id;</span>
<span class="lineNum">    2652 </span>            : }
<span class="lineNum">    2653 </span>            : 
<span class="lineNum">    2654 </span>            : namespace js {
<span class="lineNum">    2655 </span>            : namespace detail {
<span class="lineNum">    2656 </span>            : bool IdMatchesAtom(jsid id, JSAtom* atom);
<span class="lineNum">    2657 </span>            : bool IdMatchesAtom(jsid id, JSString* atom);
<span class="lineNum">    2658 </span>            : } // namespace detail
<span class="lineNum">    2659 </span>            : } // namespace js
<span class="lineNum">    2660 </span>            : 
<span class="lineNum">    2661 </span>            : /**
<span class="lineNum">    2662 </span>            :  * Must not be used on atoms that are representable as integer jsids.
<span class="lineNum">    2663 </span>            :  * Prefer NameToId or AtomToId over this function:
<span class="lineNum">    2664 </span>            :  *
<span class="lineNum">    2665 </span>            :  * A PropertyName is an atom that does not contain an integer in the range
<span class="lineNum">    2666 </span>            :  * [0, UINT32_MAX]. However, jsid can only hold an integer in the range
<span class="lineNum">    2667 </span>            :  * [0, JSID_INT_MAX] (where JSID_INT_MAX == 2^31-1).  Thus, for the range of
<span class="lineNum">    2668 </span>            :  * integers (JSID_INT_MAX, UINT32_MAX], to represent as a jsid 'id', it must be
<span class="lineNum">    2669 </span>            :  * the case JSID_IS_ATOM(id) and !JSID_TO_ATOM(id)-&gt;isPropertyName().  In most
<span class="lineNum">    2670 </span>            :  * cases when creating a jsid, code does not have to care about this corner
<span class="lineNum">    2671 </span>            :  * case because:
<span class="lineNum">    2672 </span>            :  *
<span class="lineNum">    2673 </span>            :  * - When given an arbitrary JSAtom*, AtomToId must be used, which checks for
<span class="lineNum">    2674 </span>            :  *   integer atoms representable as integer jsids, and does this conversion.
<span class="lineNum">    2675 </span>            :  *
<span class="lineNum">    2676 </span>            :  * - When given a PropertyName*, NameToId can be used which which does not need
<span class="lineNum">    2677 </span>            :  *   to do any dynamic checks.
<span class="lineNum">    2678 </span>            :  *
<span class="lineNum">    2679 </span>            :  * Thus, it is only the rare third case which needs this function, which
<span class="lineNum">    2680 </span>            :  * handles any JSAtom* that is known not to be representable with an int jsid.
<span class="lineNum">    2681 </span>            :  */
<span class="lineNum">    2682 </span>            : static MOZ_ALWAYS_INLINE jsid
<span class="lineNum">    2683 </span>            : NON_INTEGER_ATOM_TO_JSID(JSAtom* atom)
<span class="lineNum">    2684 </span><span class="lineCov">    1092032 : {</span>
<span class="lineNum">    2685 </span>            :     MOZ_ASSERT(((size_t)atom &amp; JSID_TYPE_MASK) == 0);
<span class="lineNum">    2686 </span><span class="lineCov">    1092032 :     jsid id = JSID_FROM_BITS((size_t)atom | JSID_TYPE_STRING);</span>
<span class="lineNum">    2687 </span><span class="lineCov">    2184064 :     MOZ_ASSERT(js::detail::IdMatchesAtom(id, atom));</span>
<span class="lineNum">    2688 </span><span class="lineCov">    1092032 :     return id;</span>
<span class="lineNum">    2689 </span><span class="lineCov">    1092040 : }</span>
<span class="lineNum">    2690 </span>            : 
<span class="lineNum">    2691 </span>            : static MOZ_ALWAYS_INLINE jsid
<span class="lineNum">    2692 </span>            : NON_INTEGER_ATOM_TO_JSID(JSString* atom)
<span class="lineNum">    2693 </span>            : {
<span class="lineNum">    2694 </span>            :     MOZ_ASSERT(((size_t)atom &amp; JSID_TYPE_MASK) == 0);
<span class="lineNum">    2695 </span>            :     jsid id = JSID_FROM_BITS((size_t)atom | JSID_TYPE_STRING);
<span class="lineNum">    2696 </span>            :     MOZ_ASSERT(js::detail::IdMatchesAtom(id, atom));
<span class="lineNum">    2697 </span>            :     return id;
<span class="lineNum">    2698 </span>            : }
<span class="lineNum">    2699 </span>            : 
<span class="lineNum">    2700 </span>            : /* All strings stored in jsids are atomized, but are not necessarily property names. */
<span class="lineNum">    2701 </span>            : static MOZ_ALWAYS_INLINE bool
<span class="lineNum">    2702 </span>            : JSID_IS_ATOM(jsid id)
<span class="lineNum">    2703 </span>            : {
<span class="lineNum">    2704 </span>            :     return JSID_IS_STRING(id);
<span class="lineNum">    2705 </span>            : }
<span class="lineNum">    2706 </span>            : 
<span class="lineNum">    2707 </span>            : static MOZ_ALWAYS_INLINE bool
<span class="lineNum">    2708 </span>            : JSID_IS_ATOM(jsid id, JSAtom* atom)
<span class="lineNum">    2709 </span>            : {
<span class="lineNum">    2710 </span>            :     return id == NON_INTEGER_ATOM_TO_JSID(atom);
<span class="lineNum">    2711 </span><span class="lineCov">     100788 : }</span>
<span class="lineNum">    2712 </span>            : 
<span class="lineNum">    2713 </span>            : static MOZ_ALWAYS_INLINE JSAtom*
<span class="lineNum">    2714 </span>            : JSID_TO_ATOM(jsid id)
<span class="lineNum">    2715 </span>            : {
<span class="lineNum">    2716 </span>            :     return (JSAtom*)JSID_TO_STRING(id);
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span>            : JS_STATIC_ASSERT(sizeof(jsid) == sizeof(void*));
<span class="lineNum">    2720 </span>            : 
<span class="lineNum">    2721 </span>            : namespace js {
<span class="lineNum">    2722 </span>            : 
<span class="lineNum">    2723 </span>            : static MOZ_ALWAYS_INLINE JS::Value
<span class="lineNum">    2724 </span>            : IdToValue(jsid id)
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    2726 </span>            :     if (JSID_IS_STRING(id))
<span class="lineNum">    2727 </span><span class="lineCov">          2 :         return JS::StringValue(JSID_TO_STRING(id));</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :     if (JSID_IS_INT(id))</span>
<span class="lineNum">    2729 </span><span class="lineCov">          2 :         return JS::Int32Value(JSID_TO_INT(id));</span>
<span class="lineNum">    2730 </span><span class="lineCov">          2 :     if (JSID_IS_SYMBOL(id))</span>
<span class="lineNum">    2731 </span><span class="lineCov">          2 :         return JS::SymbolValue(JSID_TO_SYMBOL(id));</span>
<span class="lineNum">    2732 </span><span class="lineCov">          2 :     MOZ_ASSERT(JSID_IS_VOID(id));</span>
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :     return JS::UndefinedValue();</span>
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2735 </span>            : 
<span class="lineNum">    2736 </span>            : /**
<span class="lineNum">    2737 </span>            :  * If the embedder has registered a ScriptEnvironmentPreparer,
<span class="lineNum">    2738 </span>            :  * PrepareScriptEnvironmentAndInvoke will call the preparer's 'invoke' method
<span class="lineNum">    2739 </span>            :  * with the given |closure|, with the assumption that the preparer will set up
<span class="lineNum">    2740 </span>            :  * any state necessary to run script in |scope|, invoke |closure| with a valid
<span class="lineNum">    2741 </span>            :  * JSContext*, report any exceptions thrown from the closure, and return.
<span class="lineNum">    2742 </span>            :  *
<span class="lineNum">    2743 </span>            :  * If no preparer is registered, PrepareScriptEnvironmentAndInvoke will assert
<span class="lineNum">    2744 </span>            :  * that |rt| has exactly one JSContext associated with it, enter the compartment
<span class="lineNum">    2745 </span>            :  * of |scope| on that context, and invoke |closure|.
<span class="lineNum">    2746 </span>            :  *
<span class="lineNum">    2747 </span>            :  * In both cases, PrepareScriptEnvironmentAndInvoke will report any exceptions
<span class="lineNum">    2748 </span>            :  * that are thrown by the closure.  Consumers who want to propagate back
<span class="lineNum">    2749 </span>            :  * whether the closure succeeded should do so via members of the closure
<span class="lineNum">    2750 </span>            :  * itself.
<span class="lineNum">    2751 </span>            :  */
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span>            : struct ScriptEnvironmentPreparer {
<span class="lineNum">    2754 </span>            :     struct Closure {
<span class="lineNum">    2755 </span>            :         virtual bool operator()(JSContext* cx) = 0;
<span class="lineNum">    2756 </span>            :     };
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span>            :     virtual void invoke(JS::HandleObject scope, Closure&amp; closure) = 0;
<span class="lineNum">    2759 </span>            : };
<span class="lineNum">    2760 </span>            : 
<span class="lineNum">    2761 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    2762 </span>            : PrepareScriptEnvironmentAndInvoke(JSContext* cx, JS::HandleObject scope,
<span class="lineNum">    2763 </span>            :                                   ScriptEnvironmentPreparer::Closure&amp; closure);
<span class="lineNum">    2764 </span>            : 
<span class="lineNum">    2765 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    2766 </span>            : SetScriptEnvironmentPreparer(JSContext* cx, ScriptEnvironmentPreparer* preparer);
<span class="lineNum">    2767 </span>            : 
<span class="lineNum">    2768 </span>            : enum CTypesActivityType {
<span class="lineNum">    2769 </span>            :     CTYPES_CALL_BEGIN,
<span class="lineNum">    2770 </span>            :     CTYPES_CALL_END,
<span class="lineNum">    2771 </span>            :     CTYPES_CALLBACK_BEGIN,
<span class="lineNum">    2772 </span>            :     CTYPES_CALLBACK_END
<span class="lineNum">    2773 </span>            : };
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span>            : typedef void
<span class="lineNum">    2776 </span>            : (* CTypesActivityCallback)(JSContext* cx, CTypesActivityType type);
<span class="lineNum">    2777 </span>            : 
<span class="lineNum">    2778 </span>            : /**
<span class="lineNum">    2779 </span>            :  * Sets a callback that is run whenever js-ctypes is about to be used when
<span class="lineNum">    2780 </span>            :  * calling into C.
<span class="lineNum">    2781 </span>            :  */
<span class="lineNum">    2782 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    2783 </span>            : SetCTypesActivityCallback(JSContext* cx, CTypesActivityCallback cb);
<span class="lineNum">    2784 </span>            : 
<span class="lineNum">    2785 </span>            : class MOZ_RAII JS_FRIEND_API(AutoCTypesActivityCallback) {
<span class="lineNum">    2786 </span>            :   private:
<span class="lineNum">    2787 </span>            :     JSContext* cx;
<span class="lineNum">    2788 </span>            :     CTypesActivityCallback callback;
<span class="lineNum">    2789 </span>            :     CTypesActivityType endType;
<span class="lineNum">    2790 </span>            :     MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
<span class="lineNum">    2791 </span>            : 
<span class="lineNum">    2792 </span>            :   public:
<span class="lineNum">    2793 </span>            :     AutoCTypesActivityCallback(JSContext* cx, CTypesActivityType beginType,
<span class="lineNum">    2794 </span>            :                                CTypesActivityType endType
<span class="lineNum">    2795 </span>            :                                MOZ_GUARD_OBJECT_NOTIFIER_PARAM);
<span class="lineNum">    2796 </span>            :     ~AutoCTypesActivityCallback() {
<span class="lineNum">    2797 </span><span class="lineCov">        236 :         DoEndCallback();</span>
<span class="lineNum">    2798 </span><span class="lineCov">        118 :     }</span>
<span class="lineNum">    2799 </span><span class="lineCov">        118 :     void DoEndCallback() {</span>
<span class="lineNum">    2800 </span>            :         if (callback) {
<span class="lineNum">    2801 </span><span class="lineCov">        236 :             callback(cx, endType);</span>
<span class="lineNum">    2802 </span><span class="lineCov">        116 :             callback = nullptr;</span>
<span class="lineNum">    2803 </span><span class="lineCov">        116 :         }</span>
<span class="lineNum">    2804 </span>            :     }
<span class="lineNum">    2805 </span>            : };
<span class="lineNum">    2806 </span>            : 
<span class="lineNum">    2807 </span>            : // Abstract base class for objects that build allocation metadata for JavaScript
<span class="lineNum">    2808 </span>            : // values.
<span class="lineNum">    2809 </span>            : struct AllocationMetadataBuilder {
<span class="lineNum">    2810 </span>            :     AllocationMetadataBuilder() { }
<span class="lineNum">    2811 </span><span class="lineCov">          4 : </span>
<span class="lineNum">    2812 </span>            :     // Return a metadata object for the newly constructed object |obj|, or
<span class="lineNum">    2813 </span>            :     // nullptr if there's no metadata to attach.
<span class="lineNum">    2814 </span>            :     //
<span class="lineNum">    2815 </span>            :     // Implementations should treat all errors as fatal; there is no way to
<span class="lineNum">    2816 </span>            :     // report errors from this callback. In particular, the caller provides an
<span class="lineNum">    2817 </span>            :     // oomUnsafe for overriding implementations to use.
<span class="lineNum">    2818 </span>            :     virtual JSObject* build(JSContext* cx, JS::HandleObject obj,
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 :                             AutoEnterOOMUnsafeRegion&amp; oomUnsafe) const</span>
<span class="lineNum">    2820 </span>            :     {
<span class="lineNum">    2821 </span>            :         return nullptr;
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2823 </span>            : };
<span class="lineNum">    2824 </span>            : 
<span class="lineNum">    2825 </span>            : /**
<span class="lineNum">    2826 </span>            :  * Specify a callback to invoke when creating each JS object in the current
<span class="lineNum">    2827 </span>            :  * compartment, which may return a metadata object to associate with the
<span class="lineNum">    2828 </span>            :  * object.
<span class="lineNum">    2829 </span>            :  */
<span class="lineNum">    2830 </span>            : JS_FRIEND_API(void)
<span class="lineNum">    2831 </span>            : SetAllocationMetadataBuilder(JSContext* cx, const AllocationMetadataBuilder *callback);
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span>            : /** Get the metadata associated with an object. */
<span class="lineNum">    2834 </span>            : JS_FRIEND_API(JSObject*)
<span class="lineNum">    2835 </span>            : GetAllocationMetadata(JSObject* obj);
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    2838 </span>            : GetElementsWithAdder(JSContext* cx, JS::HandleObject obj, JS::HandleObject receiver,
<span class="lineNum">    2839 </span>            :                      uint32_t begin, uint32_t end, js::ElementAdder* adder);
<span class="lineNum">    2840 </span>            : 
<span class="lineNum">    2841 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    2842 </span>            : ForwardToNative(JSContext* cx, JSNative native, const JS::CallArgs&amp; args);
<span class="lineNum">    2843 </span>            : 
<span class="lineNum">    2844 </span>            : /**
<span class="lineNum">    2845 </span>            :  * Helper function for HTMLDocument and HTMLFormElement.
<span class="lineNum">    2846 </span>            :  *
<span class="lineNum">    2847 </span>            :  * These are the only two interfaces that have [OverrideBuiltins], a named
<span class="lineNum">    2848 </span>            :  * getter, and no named setter. They're implemented as proxies with a custom
<span class="lineNum">    2849 </span>            :  * getOwnPropertyDescriptor() method. Unfortunately, overriding
<span class="lineNum">    2850 </span>            :  * getOwnPropertyDescriptor() automatically affects the behavior of set(),
<span class="lineNum">    2851 </span>            :  * which normally is just common sense but is *not* desired for these two
<span class="lineNum">    2852 </span>            :  * interfaces.
<span class="lineNum">    2853 </span>            :  *
<span class="lineNum">    2854 </span>            :  * The fix is for these two interfaces to override set() to ignore the
<span class="lineNum">    2855 </span>            :  * getOwnPropertyDescriptor() override.
<span class="lineNum">    2856 </span>            :  *
<span class="lineNum">    2857 </span>            :  * SetPropertyIgnoringNamedGetter is exposed to make it easier to override
<span class="lineNum">    2858 </span>            :  * set() in this way.  It carries out all the steps of BaseProxyHandler::set()
<span class="lineNum">    2859 </span>            :  * except the initial getOwnPropertyDescriptor() call.  The caller must supply
<span class="lineNum">    2860 </span>            :  * that descriptor as the 'ownDesc' parameter.
<span class="lineNum">    2861 </span>            :  *
<span class="lineNum">    2862 </span>            :  * Implemented in proxy/BaseProxyHandler.cpp.
<span class="lineNum">    2863 </span>            :  */
<span class="lineNum">    2864 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    2865 </span>            : SetPropertyIgnoringNamedGetter(JSContext* cx, JS::HandleObject obj, JS::HandleId id,
<span class="lineNum">    2866 </span>            :                                JS::HandleValue v, JS::HandleValue receiver,
<span class="lineNum">    2867 </span>            :                                JS::Handle&lt;JS::PropertyDescriptor&gt; ownDesc,
<span class="lineNum">    2868 </span>            :                                JS::ObjectOpResult&amp; result);
<span class="lineNum">    2869 </span>            : 
<span class="lineNum">    2870 </span>            : // This function is for one specific use case, please don't use this for anything else!
<span class="lineNum">    2871 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2872 </span>            : ExecuteInGlobalAndReturnScope(JSContext* cx, JS::HandleObject obj, JS::HandleScript script,
<span class="lineNum">    2873 </span>            :                               JS::MutableHandleObject scope);
<span class="lineNum">    2874 </span>            : 
<span class="lineNum">    2875 </span>            : // These functions are provided for the JSM component loader in Gecko.
<span class="lineNum">    2876 </span>            : //
<span class="lineNum">    2877 </span>            : // A 'JSMEnvironment' refers to an environment chain constructed for JSM loading
<span class="lineNum">    2878 </span>            : // in a shared global. Internally it is a NonSyntacticVariablesObject with a
<span class="lineNum">    2879 </span>            : // corresponding extensible LexicalEnvironmentObject that is accessible by
<span class="lineNum">    2880 </span>            : // JS_ExtensibleLexicalEnvironment. The |this| value of that lexical environment
<span class="lineNum">    2881 </span>            : // is the NSVO itself.
<span class="lineNum">    2882 </span>            : //
<span class="lineNum">    2883 </span>            : // Normal global environment (ES6):     JSM &quot;global&quot; environment:
<span class="lineNum">    2884 </span>            : //
<span class="lineNum">    2885 </span>            : //                                      * - extensible lexical environment
<span class="lineNum">    2886 </span>            : //                                      |   (code runs in this environment;
<span class="lineNum">    2887 </span>            : //                                      |    `let/const` bindings go here)
<span class="lineNum">    2888 </span>            : //                                      |
<span class="lineNum">    2889 </span>            : //                                      * - JSMEnvironment (=== `this`)
<span class="lineNum">    2890 </span>            : //                                      |   (`var` bindings go here)
<span class="lineNum">    2891 </span>            : //                                      |
<span class="lineNum">    2892 </span>            : // * - extensible lexical environment   * - extensible lexical environment
<span class="lineNum">    2893 </span>            : // |   (code runs in this environment;  |   (empty)
<span class="lineNum">    2894 </span>            : // |    `let/const` bindings go here)   |
<span class="lineNum">    2895 </span>            : // |                                    |
<span class="lineNum">    2896 </span>            : // * - actual global (=== `this`)       * - shared JSM global
<span class="lineNum">    2897 </span>            : //     (var bindings go here; and           (Object, Math, etc. live here)
<span class="lineNum">    2898 </span>            : //      Object, Math, etc. live here)
<span class="lineNum">    2899 </span>            : 
<span class="lineNum">    2900 </span>            : // Allocate a new environment in current compartment that is compatible with JSM
<span class="lineNum">    2901 </span>            : // shared loading.
<span class="lineNum">    2902 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2903 </span>            : NewJSMEnvironment(JSContext* cx);
<span class="lineNum">    2904 </span>            : 
<span class="lineNum">    2905 </span>            : // Execute the given script (copied into compartment if necessary) in the given
<span class="lineNum">    2906 </span>            : // JSMEnvironment. The script must have been compiled for hasNonSyntacticScope.
<span class="lineNum">    2907 </span>            : // The |jsmEnv| must have been previously allocated by NewJSMEnvironment.
<span class="lineNum">    2908 </span>            : //
<span class="lineNum">    2909 </span>            : // NOTE: The associated extensible lexical environment is reused.
<span class="lineNum">    2910 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2911 </span>            : ExecuteInJSMEnvironment(JSContext* cx, JS::HandleScript script, JS::HandleObject jsmEnv);
<span class="lineNum">    2912 </span>            : 
<span class="lineNum">    2913 </span>            : // Additionally, target objects may be specified as required by the Gecko
<span class="lineNum">    2914 </span>            : // subscript loader. These are wrapped in non-syntactic WithEnvironments and
<span class="lineNum">    2915 </span>            : // temporarily placed on environment chain.
<span class="lineNum">    2916 </span>            : //
<span class="lineNum">    2917 </span>            : // See also: JS::CloneAndExecuteScript(...)
<span class="lineNum">    2918 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2919 </span>            : ExecuteInJSMEnvironment(JSContext* cx, JS::HandleScript script, JS::HandleObject jsmEnv,
<span class="lineNum">    2920 </span>            :                         JS::AutoObjectVector&amp; targetObj);
<span class="lineNum">    2921 </span>            : 
<span class="lineNum">    2922 </span>            : // Used by native methods to determine the JSMEnvironment of caller if possible
<span class="lineNum">    2923 </span>            : // by looking at stack frames. Returns nullptr if top frame isn't a scripted
<span class="lineNum">    2924 </span>            : // caller in a JSM.
<span class="lineNum">    2925 </span>            : //
<span class="lineNum">    2926 </span>            : // NOTE: This may find NonSyntacticVariablesObject generated by other embedding
<span class="lineNum">    2927 </span>            : // such as a Gecko FrameScript. Caller can check the compartment if needed.
<span class="lineNum">    2928 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2929 </span>            : GetJSMEnvironmentOfScriptedCaller(JSContext* cx);
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span>            : // Determine if obj is a JSMEnvironment
<span class="lineNum">    2932 </span>            : //
<span class="lineNum">    2933 </span>            : // NOTE: This may return true for an NonSyntacticVariablesObject generated by
<span class="lineNum">    2934 </span>            : // other embedding such as a Gecko FrameScript. Caller can check compartment.
<span class="lineNum">    2935 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2936 </span>            : IsJSMEnvironment(JSObject* obj);
<span class="lineNum">    2937 </span>            : 
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span>            : #if defined(XP_WIN) &amp;&amp; defined(_WIN64)
<span class="lineNum">    2940 </span>            : // Parameters use void* types to avoid #including windows.h. The return value of
<span class="lineNum">    2941 </span>            : // this function is returned from the exception handler.
<span class="lineNum">    2942 </span>            : typedef long
<span class="lineNum">    2943 </span>            : (*JitExceptionHandler)(void* exceptionRecord,  // PEXECTION_RECORD
<span class="lineNum">    2944 </span>            :                        void* context);         // PCONTEXT
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span>            : /**
<span class="lineNum">    2947 </span>            :  * Windows uses &quot;structured exception handling&quot; to handle faults. When a fault
<span class="lineNum">    2948 </span>            :  * occurs, the stack is searched for a handler (similar to C++ exception
<span class="lineNum">    2949 </span>            :  * handling). If the search does not find a handler, the &quot;unhandled exception
<span class="lineNum">    2950 </span>            :  * filter&quot; is called. Breakpad uses the unhandled exception filter to do crash
<span class="lineNum">    2951 </span>            :  * reporting. Unfortunately, on Win64, JIT code on the stack completely throws
<span class="lineNum">    2952 </span>            :  * off this unwinding process and prevents the unhandled exception filter from
<span class="lineNum">    2953 </span>            :  * being called. The reason is that Win64 requires unwind information be
<span class="lineNum">    2954 </span>            :  * registered for all code regions and JIT code has none. While it is possible
<span class="lineNum">    2955 </span>            :  * to register full unwind information for JIT code, this is a lot of work (one
<span class="lineNum">    2956 </span>            :  * has to be able to recover the frame pointer at any PC) so instead we register
<span class="lineNum">    2957 </span>            :  * a handler for all JIT code that simply calls breakpad's unhandled exception
<span class="lineNum">    2958 </span>            :  * filter (which will perform crash reporting and then terminate the process).
<span class="lineNum">    2959 </span>            :  * This would be wrong if there was an outer __try block that expected to handle
<span class="lineNum">    2960 </span>            :  * the fault, but this is not generally allowed.
<span class="lineNum">    2961 </span>            :  *
<span class="lineNum">    2962 </span>            :  * Gecko must call SetJitExceptionFilter before any JIT code is compiled and
<span class="lineNum">    2963 </span>            :  * only once per process.
<span class="lineNum">    2964 </span>            :  */
<span class="lineNum">    2965 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    2966 </span>            : SetJitExceptionHandler(JitExceptionHandler handler);
<span class="lineNum">    2967 </span>            : #endif
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span>            : /**
<span class="lineNum">    2970 </span>            :  * Get the first SavedFrame object in this SavedFrame stack whose principals are
<span class="lineNum">    2971 </span>            :  * subsumed by the cx's principals. If there is no such frame, return nullptr.
<span class="lineNum">    2972 </span>            :  *
<span class="lineNum">    2973 </span>            :  * Do NOT pass a non-SavedFrame object here.
<span class="lineNum">    2974 </span>            :  *
<span class="lineNum">    2975 </span>            :  * The savedFrame and cx do not need to be in the same compartment.
<span class="lineNum">    2976 </span>            :  */
<span class="lineNum">    2977 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2978 </span>            : GetFirstSubsumedSavedFrame(JSContext* cx, JS::HandleObject savedFrame, JS::SavedFrameSelfHosted selfHosted);
<span class="lineNum">    2979 </span>            : 
<span class="lineNum">    2980 </span>            : /**
<span class="lineNum">    2981 </span>            :  * Get the first SavedFrame object in this SavedFrame stack whose principals are
<span class="lineNum">    2982 </span>            :  * subsumed by the given |principals|. If there is no such frame, return nullptr.
<span class="lineNum">    2983 </span>            :  *
<span class="lineNum">    2984 </span>            :  * Do NOT pass a non-SavedFrame object here.
<span class="lineNum">    2985 </span>            :  */
<span class="lineNum">    2986 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2987 </span>            : GetFirstSubsumedSavedFrame(JSContext* cx, JSPrincipals* principals, JS::HandleObject savedFrame, JS::SavedFrameSelfHosted selfHosted);
<span class="lineNum">    2988 </span>            : 
<span class="lineNum">    2989 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    2990 </span>            : ReportIsNotFunction(JSContext* cx, JS::HandleValue v);
<span class="lineNum">    2991 </span>            : 
<span class="lineNum">    2992 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    2993 </span>            : ConvertArgsToArray(JSContext* cx, const JS::CallArgs&amp; args);
<span class="lineNum">    2994 </span>            : 
<span class="lineNum">    2995 </span>            : /**
<span class="lineNum">    2996 </span>            :  * Window and WindowProxy
<span class="lineNum">    2997 </span>            :  *
<span class="lineNum">    2998 </span>            :  * The functions below have to do with Windows and WindowProxies. There's an
<span class="lineNum">    2999 </span>            :  * invariant that actual Window objects (the global objects of web pages) are
<span class="lineNum">    3000 </span>            :  * never directly exposed to script. Instead we often substitute a WindowProxy.
<span class="lineNum">    3001 </span>            :  *
<span class="lineNum">    3002 </span>            :  * The environment chain, on the other hand, contains the Window and never its
<span class="lineNum">    3003 </span>            :  * WindowProxy.
<span class="lineNum">    3004 </span>            :  *
<span class="lineNum">    3005 </span>            :  * As a result, we have calls to these &quot;substitute-this-object-for-that-object&quot;
<span class="lineNum">    3006 </span>            :  * functions sprinkled at apparently arbitrary (but actually *very* carefully
<span class="lineNum">    3007 </span>            :  * and nervously selected) places throughout the engine and indeed the
<span class="lineNum">    3008 </span>            :  * universe.
<span class="lineNum">    3009 </span>            :  */
<span class="lineNum">    3010 </span>            : 
<span class="lineNum">    3011 </span>            : /**
<span class="lineNum">    3012 </span>            :  * Tell the JS engine which Class is used for WindowProxy objects. Used by the
<span class="lineNum">    3013 </span>            :  * functions below.
<span class="lineNum">    3014 </span>            :  */
<span class="lineNum">    3015 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3016 </span>            : SetWindowProxyClass(JSContext* cx, const Class* clasp);
<span class="lineNum">    3017 </span>            : 
<span class="lineNum">    3018 </span>            : /**
<span class="lineNum">    3019 </span>            :  * Associates a WindowProxy with a Window (global object). `windowProxy` must
<span class="lineNum">    3020 </span>            :  * have the Class set by SetWindowProxyClass.
<span class="lineNum">    3021 </span>            :  */
<span class="lineNum">    3022 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3023 </span>            : SetWindowProxy(JSContext* cx, JS::HandleObject global, JS::HandleObject windowProxy);
<span class="lineNum">    3024 </span>            : 
<span class="lineNum">    3025 </span>            : namespace detail {
<span class="lineNum">    3026 </span>            : 
<span class="lineNum">    3027 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    3028 </span>            : IsWindowSlow(JSObject* obj);
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span>            : JS_FRIEND_API(JSObject*)
<span class="lineNum">    3031 </span>            : ToWindowProxyIfWindowSlow(JSObject* obj);
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span>            : } // namespace detail
<span class="lineNum">    3034 </span>            : 
<span class="lineNum">    3035 </span>            : /**
<span class="lineNum">    3036 </span>            :  * Returns true iff `obj` is a global object with an associated WindowProxy,
<span class="lineNum">    3037 </span>            :  * see SetWindowProxy.
<span class="lineNum">    3038 </span>            :  */
<span class="lineNum">    3039 </span>            : inline bool
<span class="lineNum">    3040 </span>            : IsWindow(JSObject* obj)
<span class="lineNum">    3041 </span>            : {
<span class="lineNum">    3042 </span>            :     if (GetObjectClass(obj)-&gt;flags &amp; JSCLASS_IS_GLOBAL)
<span class="lineNum">    3043 </span><span class="lineCov">          2 :         return detail::IsWindowSlow(obj);</span>
<span class="lineNum">    3044 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3045 </span>            : }
<span class="lineNum">    3046 </span>            : 
<span class="lineNum">    3047 </span>            : /**
<span class="lineNum">    3048 </span>            :  * Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass).
<span class="lineNum">    3049 </span>            :  */
<span class="lineNum">    3050 </span>            : JS_FRIEND_API(bool)
<span class="lineNum">    3051 </span>            : IsWindowProxy(JSObject* obj);
<span class="lineNum">    3052 </span>            : 
<span class="lineNum">    3053 </span>            : /**
<span class="lineNum">    3054 </span>            :  * If `obj` is a Window, get its associated WindowProxy (or a CCW or dead
<span class="lineNum">    3055 </span>            :  * wrapper if the page was navigated away from), else return `obj`. This
<span class="lineNum">    3056 </span>            :  * function is infallible and never returns nullptr.
<span class="lineNum">    3057 </span>            :  */
<span class="lineNum">    3058 </span>            : MOZ_ALWAYS_INLINE JSObject*
<span class="lineNum">    3059 </span>            : ToWindowProxyIfWindow(JSObject* obj)
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">    3061 </span>            :     if (GetObjectClass(obj)-&gt;flags &amp; JSCLASS_IS_GLOBAL)
<span class="lineNum">    3062 </span><span class="lineCov">          2 :         return detail::ToWindowProxyIfWindowSlow(obj);</span>
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :     return obj;</span>
<span class="lineNum">    3064 </span>            : }
<span class="lineNum">    3065 </span>            : 
<span class="lineNum">    3066 </span>            : /**
<span class="lineNum">    3067 </span>            :  * If `obj` is a WindowProxy, get its associated Window (the compartment's
<span class="lineNum">    3068 </span>            :  * global), else return `obj`. This function is infallible and never returns
<span class="lineNum">    3069 </span>            :  * nullptr.
<span class="lineNum">    3070 </span>            :  */
<span class="lineNum">    3071 </span>            : extern JS_FRIEND_API(JSObject*)
<span class="lineNum">    3072 </span>            : ToWindowIfWindowProxy(JSObject* obj);
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span>            : // Create and add the Intl.MozDateTimeFormat constructor function to the provided
<span class="lineNum">    3075 </span>            : // object.
<span class="lineNum">    3076 </span>            : //
<span class="lineNum">    3077 </span>            : // This custom date/time formatter constructor gives users the ability
<span class="lineNum">    3078 </span>            : // to specify a custom format pattern. This pattern is passed *directly*
<span class="lineNum">    3079 </span>            : // to ICU with NO SYNTAX PARSING OR VALIDATION WHATSOEVER. ICU appears to
<span class="lineNum">    3080 </span>            : // have a a modicum of testing of this, and it won't fall over completely
<span class="lineNum">    3081 </span>            : // if passed bad input. But the current behavior is entirely under-specified
<span class="lineNum">    3082 </span>            : // and emphatically not shippable on the web, and it *must* be fixed before
<span class="lineNum">    3083 </span>            : // this functionality can be exposed in the real world. (There are also some
<span class="lineNum">    3084 </span>            : // questions about whether the format exposed here is the *right* one to
<span class="lineNum">    3085 </span>            : // standardize, that will also need to be resolved to ship this.)
<span class="lineNum">    3086 </span>            : extern bool
<span class="lineNum">    3087 </span>            : AddMozDateTimeFormatConstructor(JSContext* cx, JS::Handle&lt;JSObject*&gt; intl);
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span>            : // Create and add the Intl.RelativeTimeFormat constructor function to the provided
<span class="lineNum">    3090 </span>            : // object.  This function throws if called more than once per realm/global
<span class="lineNum">    3091 </span>            : // object.
<span class="lineNum">    3092 </span>            : extern bool
<span class="lineNum">    3093 </span>            : AddRelativeTimeFormatConstructor(JSContext* cx, JS::Handle&lt;JSObject*&gt; intl);
<span class="lineNum">    3094 </span>            : 
<span class="lineNum">    3095 </span>            : class MOZ_STACK_CLASS JS_FRIEND_API(AutoAssertNoContentJS)
<span class="lineNum">    3096 </span>            : {
<span class="lineNum">    3097 </span>            :   public:
<span class="lineNum">    3098 </span>            :     explicit AutoAssertNoContentJS(JSContext* cx);
<span class="lineNum">    3099 </span>            :     ~AutoAssertNoContentJS();
<span class="lineNum">    3100 </span>            : 
<span class="lineNum">    3101 </span>            :   private:
<span class="lineNum">    3102 </span>            :     JSContext* context_;
<span class="lineNum">    3103 </span>            :     bool prevAllowContentJS_;
<span class="lineNum">    3104 </span>            : };
<span class="lineNum">    3105 </span>            : 
<span class="lineNum">    3106 </span>            : // Turn on assertions so that we assert that
<span class="lineNum">    3107 </span>            : //     !realm-&gt;validAccessPtr || *realm-&gt;validAccessPtr
<span class="lineNum">    3108 </span>            : // is true for every |realm| that we run JS code in. The realm's validAccessPtr
<span class="lineNum">    3109 </span>            : // is set via SetRealmValidAccessPtr.
<span class="lineNum">    3110 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3111 </span>            : EnableAccessValidation(JSContext* cx, bool enabled);
<span class="lineNum">    3112 </span>            : 
<span class="lineNum">    3113 </span>            : // See EnableAccessValidation above. The caller must guarantee that accessp will
<span class="lineNum">    3114 </span>            : // live at least as long as |global| is alive. The JS engine reads accessp from
<span class="lineNum">    3115 </span>            : // threads that are allowed to run code on |global|, so all changes to *accessp
<span class="lineNum">    3116 </span>            : // should be made from whichever thread owns |global| at a given time.
<span class="lineNum">    3117 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3118 </span>            : SetRealmValidAccessPtr(JSContext* cx, JS::HandleObject global, bool* accessp);
<span class="lineNum">    3119 </span>            : 
<span class="lineNum">    3120 </span>            : // Returns true if the system zone is available (i.e., if no cooperative contexts
<span class="lineNum">    3121 </span>            : // are using it now).
<span class="lineNum">    3122 </span>            : extern JS_FRIEND_API(bool)
<span class="lineNum">    3123 </span>            : SystemZoneAvailable(JSContext* cx);
<span class="lineNum">    3124 </span>            : 
<span class="lineNum">    3125 </span>            : typedef void
<span class="lineNum">    3126 </span>            : (* LogCtorDtor)(void* self, const char* type, uint32_t sz);
<span class="lineNum">    3127 </span>            : 
<span class="lineNum">    3128 </span>            : /**
<span class="lineNum">    3129 </span>            :  * Set global function used to monitor a few internal classes to highlight
<span class="lineNum">    3130 </span>            :  * leaks, and to hint at the origin of the leaks.
<span class="lineNum">    3131 </span>            :  */
<span class="lineNum">    3132 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3133 </span>            : SetLogCtorDtorFunctions(LogCtorDtor ctor, LogCtorDtor dtor);
<span class="lineNum">    3134 </span>            : 
<span class="lineNum">    3135 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3136 </span>            : LogCtor(void* self, const char* type, uint32_t sz);
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span>            : extern JS_FRIEND_API(void)
<span class="lineNum">    3139 </span>            : LogDtor(void* self, const char* type, uint32_t sz);
<span class="lineNum">    3140 </span>            : 
<span class="lineNum">    3141 </span>            : #define JS_COUNT_CTOR(Class)                            \
<span class="lineNum">    3142 </span>            :     LogCtor((void*) this, #Class, sizeof(Class))
<span class="lineNum">    3143 </span>            : 
<span class="lineNum">    3144 </span>            : #define JS_COUNT_DTOR(Class)                            \
<span class="lineNum">    3145 </span>            :     LogDtor((void*) this, #Class, sizeof(Class))
<span class="lineNum">    3146 </span>            : 
<span class="lineNum">    3147 </span>            : } /* namespace js */
<span class="lineNum">    3148 </span>            : 
<span class="lineNum">    3149 </span>            : #endif /* jsfriendapi_h */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13-14-ga5dd952</a></td></tr>
  </table>
  <br>

</body>
</html>
