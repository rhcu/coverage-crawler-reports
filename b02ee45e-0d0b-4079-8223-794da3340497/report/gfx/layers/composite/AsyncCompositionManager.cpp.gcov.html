<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - gfx/layers/composite/AsyncCompositionManager.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">gfx/layers/composite</a> - AsyncCompositionManager.cpp<span style="font-size: 80%;"> (source / <a href="AsyncCompositionManager.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">73</td>
            <td class="headerCovTableEntry">461</td>
            <td class="headerCovTableEntryLo">15.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-08-07 16:42:27</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;mozilla/layers/AsyncCompositionManager.h&quot;
<span class="lineNum">       8 </span>            : #include &lt;stdint.h&gt;                     // for uint32_t
<span class="lineNum">       9 </span>            : #include &quot;FrameMetrics.h&quot;               // for FrameMetrics
<span class="lineNum">      10 </span>            : #include &quot;LayerManagerComposite.h&quot;      // for LayerManagerComposite, etc
<span class="lineNum">      11 </span>            : #include &quot;Layers.h&quot;                     // for Layer, ContainerLayer, etc
<span class="lineNum">      12 </span>            : #include &quot;gfxPoint.h&quot;                   // for gfxPoint, gfxSize
<span class="lineNum">      13 </span>            : #include &quot;gfxPrefs.h&quot;                   // for gfxPrefs
<span class="lineNum">      14 </span>            : #include &quot;mozilla/ServoBindings.h&quot;      // for Servo_AnimationValue_GetOpacity, etc
<span class="lineNum">      15 </span>            : #include &quot;mozilla/WidgetUtils.h&quot;        // for ComputeTransformForRotation
<span class="lineNum">      16 </span>            : #include &quot;mozilla/gfx/BaseRect.h&quot;       // for BaseRect
<span class="lineNum">      17 </span>            : #include &quot;mozilla/gfx/Point.h&quot;          // for RoundedToInt, PointTyped
<span class="lineNum">      18 </span>            : #include &quot;mozilla/gfx/Rect.h&quot;           // for RoundedToInt, RectTyped
<span class="lineNum">      19 </span>            : #include &quot;mozilla/gfx/ScaleFactor.h&quot;    // for ScaleFactor
<span class="lineNum">      20 </span>            : #include &quot;mozilla/layers/AnimationHelper.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/layers/APZSampler.h&quot;  // for APZSampler
<span class="lineNum">      22 </span>            : #include &quot;mozilla/layers/APZUtils.h&quot;    // for CompleteAsyncTransform
<span class="lineNum">      23 </span>            : #include &quot;mozilla/layers/Compositor.h&quot;  // for Compositor
<span class="lineNum">      24 </span>            : #include &quot;mozilla/layers/CompositorBridgeParent.h&quot; // for CompositorBridgeParent, etc
<span class="lineNum">      25 </span>            : #include &quot;mozilla/layers/CompositorThread.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/layers/LayerAnimationUtils.h&quot; // for TimingFunctionToComputedTimingFunction
<span class="lineNum">      27 </span>            : #include &quot;mozilla/layers/LayerMetricsWrapper.h&quot; // for LayerMetricsWrapper
<span class="lineNum">      28 </span>            : #include &quot;nsCoord.h&quot;                    // for NSAppUnitsToFloatPixels, etc
<span class="lineNum">      29 </span>            : #include &quot;nsDebug.h&quot;                    // for NS_ASSERTION, etc
<span class="lineNum">      30 </span>            : #include &quot;nsDeviceContext.h&quot;            // for nsDeviceContext
<span class="lineNum">      31 </span>            : #include &quot;nsDisplayList.h&quot;              // for nsDisplayTransform, etc
<span class="lineNum">      32 </span>            : #include &quot;nsMathUtils.h&quot;                // for NS_round
<span class="lineNum">      33 </span>            : #include &quot;nsPoint.h&quot;                    // for nsPoint
<span class="lineNum">      34 </span>            : #include &quot;nsRect.h&quot;                     // for mozilla::gfx::IntRect
<span class="lineNum">      35 </span>            : #include &quot;nsRegion.h&quot;                   // for nsIntRegion
<span class="lineNum">      36 </span>            : #include &quot;nsTArray.h&quot;                   // for nsTArray, nsTArray_Impl, etc
<span class="lineNum">      37 </span>            : #include &quot;nsTArrayForwardDeclare.h&quot;     // for InfallibleTArray
<span class="lineNum">      38 </span>            : #include &quot;UnitTransforms.h&quot;             // for TransformTo
<span class="lineNum">      39 </span>            : #include &quot;gfxPrefs.h&quot;
<span class="lineNum">      40 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">      41 </span>            : # include &lt;android/log.h&gt;
<span class="lineNum">      42 </span>            : # include &quot;mozilla/layers/UiCompositorControllerParent.h&quot;
<span class="lineNum">      43 </span>            : # include &quot;mozilla/widget/AndroidCompositorWidget.h&quot;
<span class="lineNum">      44 </span>            : #endif
<span class="lineNum">      45 </span>            : #include &quot;GeckoProfiler.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;FrameUniformityData.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;TreeTraversal.h&quot;              // for ForEachNode, BreadthFirstSearch
<span class="lineNum">      48 </span>            : #include &quot;VsyncSource.h&quot;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : struct nsCSSValueSharedList;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : namespace mozilla {
<span class="lineNum">      53 </span>            : namespace layers {
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : static bool
<span class="lineNum">      58 </span><span class="lineNoCov">          0 : IsSameDimension(dom::ScreenOrientationInternal o1, dom::ScreenOrientationInternal o2)</span>
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :   bool isO1portrait = (o1 == dom::eScreenOrientation_PortraitPrimary || o1 == dom::eScreenOrientation_PortraitSecondary);</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 :   bool isO2portrait = (o2 == dom::eScreenOrientation_PortraitPrimary || o2 == dom::eScreenOrientation_PortraitSecondary);</span>
<span class="lineNum">      62 </span><span class="lineNoCov">          0 :   return !(isO1portrait ^ isO2portrait);</span>
<span class="lineNum">      63 </span>            : }
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : static bool
<span class="lineNum">      66 </span>            : ContentMightReflowOnOrientationChange(const IntRect&amp; rect)
<span class="lineNum">      67 </span>            : {
<span class="lineNum">      68 </span><span class="lineNoCov">          0 :   return rect.Width() != rect.Height();</span>
<span class="lineNum">      69 </span>            : }
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span><span class="lineNoCov">          0 : AsyncCompositionManager::AsyncCompositionManager(CompositorBridgeParent* aParent,</span>
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :                                                  HostLayerManager* aManager)</span>
<span class="lineNum">      73 </span>            :   : mLayerManager(aManager)
<span class="lineNum">      74 </span>            :   , mIsFirstPaint(true)
<span class="lineNum">      75 </span>            :   , mLayersUpdated(false)
<span class="lineNum">      76 </span>            :   , mReadyForCompose(true)
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   , mCompositorBridge(aParent)</span>
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mCompositorBridge);</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span><span class="lineNoCov">          0 : AsyncCompositionManager::~AsyncCompositionManager()</span>
<span class="lineNum">      83 </span>            : {
<span class="lineNum">      84 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : void
<span class="lineNum">      87 </span><span class="lineNoCov">          0 : AsyncCompositionManager::ResolveRefLayers(CompositorBridgeParent* aCompositor,</span>
<span class="lineNum">      88 </span>            :                                           bool* aHasRemoteContent,
<span class="lineNum">      89 </span>            :                                           bool* aResolvePlugins)
<span class="lineNum">      90 </span>            : {
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :   if (aHasRemoteContent) {</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :     *aHasRemoteContent = false;</span>
<span class="lineNum">      93 </span>            :   }
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
<span class="lineNum">      96 </span>            :   // If valid *aResolvePlugins indicates if we need to update plugin geometry
<span class="lineNum">      97 </span>            :   // when we walk the tree.
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   bool resolvePlugins = (aCompositor &amp;&amp; aResolvePlugins &amp;&amp; *aResolvePlugins);</span>
<span class="lineNum">      99 </span>            : #endif
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   if (!mLayerManager-&gt;GetRoot()) {</span>
<span class="lineNum">     102 </span>            :     // Updated the return value since this result controls completing composition.
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :     if (aResolvePlugins) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :       *aResolvePlugins = false;</span>
<span class="lineNum">     105 </span>            :     }
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     107 </span>            :   }
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   mReadyForCompose = true;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   bool hasRemoteContent = false;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   bool didResolvePlugins = false;</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   ForEachNode&lt;ForwardIterator&gt;(</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :     mLayerManager-&gt;GetRoot(),</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :     [&amp;](Layer* layer)</span>
<span class="lineNum">     116 </span>            :     {
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :       RefLayer* refLayer = layer-&gt;AsRefLayer();</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :       if (!refLayer) {</span>
<span class="lineNum">     119 </span>            :         return;
<span class="lineNum">     120 </span>            :       }
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       hasRemoteContent = true;</span>
<span class="lineNum">     123 </span>            :       const CompositorBridgeParent::LayerTreeState* state =
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         CompositorBridgeParent::GetIndirectShadowTree(refLayer-&gt;GetReferentId());</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :       if (!state) {</span>
<span class="lineNum">     126 </span>            :         return;
<span class="lineNum">     127 </span>            :       }
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :       Layer* referent = state-&gt;mRoot;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :       if (!referent) {</span>
<span class="lineNum">     131 </span>            :         return;
<span class="lineNum">     132 </span>            :       }
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :       if (!refLayer-&gt;GetLocalVisibleRegion().IsEmpty()) {</span>
<span class="lineNum">     135 </span>            :         dom::ScreenOrientationInternal chromeOrientation =
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :           mTargetConfig.orientation();</span>
<span class="lineNum">     137 </span>            :         dom::ScreenOrientationInternal contentOrientation =
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :           state-&gt;mTargetConfig.orientation();</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         if (!IsSameDimension(chromeOrientation, contentOrientation) &amp;&amp;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :             ContentMightReflowOnOrientationChange(mTargetConfig.naturalBounds())) {</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :           mReadyForCompose = false;</span>
<span class="lineNum">     142 </span>            :         }
<span class="lineNum">     143 </span>            :       }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       refLayer-&gt;ConnectReferentLayer(referent);</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :       if (resolvePlugins) {</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :         didResolvePlugins |=</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :           aCompositor-&gt;UpdatePluginWindowState(refLayer-&gt;GetReferentId());</span>
<span class="lineNum">     151 </span>            :       }
<span class="lineNum">     152 </span>            : #endif
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :     });</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   if (aHasRemoteContent) {</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :     *aHasRemoteContent = hasRemoteContent;</span>
<span class="lineNum">     157 </span>            :   }
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   if (aResolvePlugins) {</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     *aResolvePlugins = didResolvePlugins;</span>
<span class="lineNum">     160 </span>            :   }
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : void
<span class="lineNum">     164 </span><span class="lineNoCov">          0 : AsyncCompositionManager::DetachRefLayers()</span>
<span class="lineNum">     165 </span>            : {
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   if (!mLayerManager-&gt;GetRoot()) {</span>
<span class="lineNum">     167 </span>            :     return;
<span class="lineNum">     168 </span>            :   }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   mReadyForCompose = false;</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   ForEachNodePostOrder&lt;ForwardIterator&gt;(mLayerManager-&gt;GetRoot(),</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     [&amp;](Layer* layer)</span>
<span class="lineNum">     174 </span>            :     {
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :       RefLayer* refLayer = layer-&gt;AsRefLayer();</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :       if (!refLayer) {</span>
<span class="lineNum">     177 </span>            :         return;
<span class="lineNum">     178 </span>            :       }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            :       const CompositorBridgeParent::LayerTreeState* state =
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :         CompositorBridgeParent::GetIndirectShadowTree(refLayer-&gt;GetReferentId());</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 :       if (!state) {</span>
<span class="lineNum">     183 </span>            :         return;
<span class="lineNum">     184 </span>            :       }
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :       Layer* referent = state-&gt;mRoot;</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :       if (referent) {</span>
<span class="lineNum">     188 </span>            :         refLayer-&gt;DetachReferentLayer(referent);
<span class="lineNum">     189 </span>            :       }
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :     });</span>
<span class="lineNum">     191 </span>            : }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : void
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : AsyncCompositionManager::ComputeRotation()</span>
<span class="lineNum">     195 </span>            : {
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :   if (!mTargetConfig.naturalBounds().IsEmpty()) {</span>
<span class="lineNum">     197 </span>            :     mWorldTransform =
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :       ComputeTransformForRotation(mTargetConfig.naturalBounds(),</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :                                   mTargetConfig.rotation());</span>
<span class="lineNum">     200 </span>            :   }
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : #ifdef DEBUG
<span class="lineNum">     204 </span>            : static void
<span class="lineNum">     205 </span><span class="lineNoCov">          0 : GetBaseTransform(Layer* aLayer, Matrix4x4* aTransform)</span>
<span class="lineNum">     206 </span>            : {
<span class="lineNum">     207 </span>            :   // Start with the animated transform if there is one
<span class="lineNum">     208 </span>            :   *aTransform =
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :     (aLayer-&gt;AsHostLayer()-&gt;GetShadowTransformSetByAnimation()</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         ? aLayer-&gt;GetLocalTransform()</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         : aLayer-&gt;GetTransform());</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     213 </span>            : #endif
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : static void
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : TransformClipRect(Layer* aLayer,</span>
<span class="lineNum">     217 </span>            :                   const ParentLayerToParentLayerMatrix4x4&amp; aTransform)
<span class="lineNum">     218 </span>            : {
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aTransform.Is2D());</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   const Maybe&lt;ParentLayerIntRect&gt;&amp; clipRect = aLayer-&gt;AsHostLayer()-&gt;GetShadowClipRect();</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   if (clipRect) {</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     ParentLayerIntRect transformed = TransformBy(aTransform, *clipRect);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :     aLayer-&gt;AsHostLayer()-&gt;SetShadowClipRect(Some(transformed));</span>
<span class="lineNum">     224 </span>            :   }
<span class="lineNum">     225 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : // Similar to TransformFixedClip(), but only transforms the fixed part of the
<span class="lineNum">     228 </span>            : // clip.
<span class="lineNum">     229 </span>            : static void
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : TransformFixedClip(Layer* aLayer,</span>
<span class="lineNum">     231 </span>            :                    const ParentLayerToParentLayerMatrix4x4&amp; aTransform,
<span class="lineNum">     232 </span>            :                    AsyncCompositionManager::ClipParts&amp; aClipParts)
<span class="lineNum">     233 </span>            : {
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aTransform.Is2D());</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   if (aClipParts.mFixedClip) {</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     *aClipParts.mFixedClip = TransformBy(aTransform, *aClipParts.mFixedClip);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :     aLayer-&gt;AsHostLayer()-&gt;SetShadowClipRect(aClipParts.Intersect());</span>
<span class="lineNum">     238 </span>            :   }
<span class="lineNum">     239 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : /**
<span class="lineNum">     242 </span>            :  * Set the given transform as the shadow transform on the layer, assuming
<span class="lineNum">     243 </span>            :  * that the given transform already has the pre- and post-scales applied.
<span class="lineNum">     244 </span>            :  * That is, this function cancels out the pre- and post-scales from aTransform
<span class="lineNum">     245 </span>            :  * before setting it as the shadow transform on the layer, so that when
<span class="lineNum">     246 </span>            :  * the layer's effective transform is computed, the pre- and post-scales will
<span class="lineNum">     247 </span>            :  * only be applied once.
<span class="lineNum">     248 </span>            :  */
<span class="lineNum">     249 </span>            : static void
<span class="lineNum">     250 </span><span class="lineNoCov">          0 : SetShadowTransform(Layer* aLayer, LayerToParentLayerMatrix4x4 aTransform)</span>
<span class="lineNum">     251 </span>            : {
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :   if (ContainerLayer* c = aLayer-&gt;AsContainerLayer()) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     aTransform.PreScale(1.0f / c-&gt;GetPreXScale(),</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                         1.0f / c-&gt;GetPreYScale(),</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :                         1);</span>
<span class="lineNum">     256 </span>            :   }
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   aTransform.PostScale(1.0f / aLayer-&gt;GetPostXScale(),</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :                        1.0f / aLayer-&gt;GetPostYScale(),</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :                        1);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   aLayer-&gt;AsHostLayer()-&gt;SetShadowBaseTransform(aTransform.ToUnknownMatrix());</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : static void
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : TranslateShadowLayer(Layer* aLayer,</span>
<span class="lineNum">     265 </span>            :                      const ParentLayerPoint&amp; aTranslation,
<span class="lineNum">     266 </span>            :                      bool aAdjustClipRect,
<span class="lineNum">     267 </span>            :                      AsyncCompositionManager::ClipPartsCache* aClipPartsCache)
<span class="lineNum">     268 </span>            : {
<span class="lineNum">     269 </span>            :   // This layer might also be a scrollable layer and have an async transform.
<span class="lineNum">     270 </span>            :   // To make sure we don't clobber that, we start with the shadow transform.
<span class="lineNum">     271 </span>            :   // (i.e. GetLocalTransform() instead of GetTransform()).
<span class="lineNum">     272 </span>            :   // Note that the shadow transform is reset on every frame of composition so
<span class="lineNum">     273 </span>            :   // we don't have to worry about the adjustments compounding over successive
<span class="lineNum">     274 </span>            :   // frames.
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :   LayerToParentLayerMatrix4x4 layerTransform = aLayer-&gt;GetLocalTransformTyped();</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :   // Apply the translation to the layer transform.
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :   layerTransform.PostTranslate(aTranslation);</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   SetShadowTransform(aLayer, layerTransform);</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :   aLayer-&gt;AsHostLayer()-&gt;SetShadowTransformSetByAnimation(false);</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   if (aAdjustClipRect) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     auto transform = ParentLayerToParentLayerMatrix4x4::Translation(aTranslation);</span>
<span class="lineNum">     285 </span>            :     // If we're passed a clip parts cache, only transform the fixed part of
<span class="lineNum">     286 </span>            :     // the clip.
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     if (aClipPartsCache) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :       auto iter = aClipPartsCache-&gt;find(aLayer);</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(iter != aClipPartsCache-&gt;end());</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       TransformFixedClip(aLayer, transform, iter-&gt;second);</span>
<span class="lineNum">     291 </span>            :     } else {
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       TransformClipRect(aLayer, transform);</span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            :     // If a fixed- or sticky-position layer has a mask layer, that mask should
<span class="lineNum">     296 </span>            :     // move along with the layer, so apply the translation to the mask layer too.
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     if (Layer* maskLayer = aLayer-&gt;GetMaskLayer()) {</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :       TranslateShadowLayer(maskLayer, aTranslation, false, aClipPartsCache);</span>
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span>            :   }
<span class="lineNum">     301 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : #ifdef DEBUG
<span class="lineNum">     304 </span>            : static void
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : AccumulateLayerTransforms(Layer* aLayer,</span>
<span class="lineNum">     306 </span>            :                           Layer* aAncestor,
<span class="lineNum">     307 </span>            :                           Matrix4x4&amp; aMatrix)
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span>            :   // Accumulate the transforms between this layer and the subtree root layer.
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   for (Layer* l = aLayer; l &amp;&amp; l != aAncestor; l = l-&gt;GetParent()) {</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :     Matrix4x4 transform;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :     GetBaseTransform(l, &amp;transform);</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :     aMatrix *= transform;</span>
<span class="lineNum">     314 </span>            :   }
<span class="lineNum">     315 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     316 </span>            : #endif
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : static LayerPoint
<span class="lineNum">     319 </span><span class="lineNoCov">          0 : GetLayerFixedMarginsOffset(Layer* aLayer,</span>
<span class="lineNum">     320 </span>            :                            const ScreenMargin&amp; aFixedLayerMargins)
<span class="lineNum">     321 </span>            : {
<span class="lineNum">     322 </span>            :   // Work out the necessary translation, in root scrollable layer space.
<span class="lineNum">     323 </span>            :   // Because fixed layer margins are stored relative to the root scrollable
<span class="lineNum">     324 </span>            :   // layer, we can just take the difference between these values.
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   LayerPoint translation;</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   int32_t sides = aLayer-&gt;GetFixedPositionSides();</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   if ((sides &amp; eSideBitsLeftRight) == eSideBitsLeftRight) {</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :     translation.x += (aFixedLayerMargins.left - aFixedLayerMargins.right) / 2;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   } else if (sides &amp; eSideBitsRight) {</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     translation.x -= aFixedLayerMargins.right;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   } else if (sides &amp; eSideBitsLeft) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     translation.x += aFixedLayerMargins.left;</span>
<span class="lineNum">     334 </span>            :   }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :   if ((sides &amp; eSideBitsTopBottom) == eSideBitsTopBottom) {</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     translation.y += (aFixedLayerMargins.top - aFixedLayerMargins.bottom) / 2;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   } else if (sides &amp; eSideBitsBottom) {</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     translation.y -= aFixedLayerMargins.bottom;</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   } else if (sides &amp; eSideBitsTop) {</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :     translation.y += aFixedLayerMargins.top;</span>
<span class="lineNum">     342 </span>            :   }
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :   return translation;</span>
<span class="lineNum">     345 </span>            : }
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : static gfxFloat
<span class="lineNum">     348 </span><span class="lineNoCov">          0 : IntervalOverlap(gfxFloat aTranslation, gfxFloat aMin, gfxFloat aMax)</span>
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span>            :   // Determine the amount of overlap between the 1D vector |aTranslation|
<span class="lineNum">     351 </span>            :   // and the interval [aMin, aMax].
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   if (aTranslation &gt; 0) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     return std::max(0.0, std::min(aMax, aTranslation) - std::max(aMin, 0.0));</span>
<span class="lineNum">     354 </span>            :   } else {
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     return std::min(0.0, std::max(aMin, aTranslation) - std::min(aMax, 0.0));</span>
<span class="lineNum">     356 </span>            :   }
<span class="lineNum">     357 </span>            : }
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            : /**
<span class="lineNum">     360 </span>            :  * Finds the metrics on |aLayer| with scroll id |aScrollId|, and returns a
<span class="lineNum">     361 </span>            :  * LayerMetricsWrapper representing the (layer, metrics) pair, or the null
<span class="lineNum">     362 </span>            :  * LayerMetricsWrapper if no matching metrics could be found.
<span class="lineNum">     363 </span>            :  */
<span class="lineNum">     364 </span>            : static LayerMetricsWrapper
<span class="lineNum">     365 </span><span class="lineNoCov">          0 : FindMetricsWithScrollId(Layer* aLayer, FrameMetrics::ViewID aScrollId)</span>
<span class="lineNum">     366 </span>            : {
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   for (uint64_t i = 0; i &lt; aLayer-&gt;GetScrollMetadataCount(); ++i) {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     if (aLayer-&gt;GetFrameMetrics(i).GetScrollId() == aScrollId) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :       return LayerMetricsWrapper(aLayer, i);</span>
<span class="lineNum">     370 </span>            :     }
<span class="lineNum">     371 </span>            :   }
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   return LayerMetricsWrapper();</span>
<span class="lineNum">     373 </span>            : }
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : /**
<span class="lineNum">     376 </span>            :  * Checks whether the (layer, metrics) pair (aTransformedLayer, aTransformedMetrics)
<span class="lineNum">     377 </span>            :  * is on the path from |aFixedLayer| to the metrics with scroll id
<span class="lineNum">     378 </span>            :  * |aFixedWithRespectTo|, inclusive.
<span class="lineNum">     379 </span>            :  */
<span class="lineNum">     380 </span>            : static bool
<span class="lineNum">     381 </span><span class="lineNoCov">          0 : AsyncTransformShouldBeUnapplied(Layer* aFixedLayer,</span>
<span class="lineNum">     382 </span>            :                                 FrameMetrics::ViewID aFixedWithRespectTo,
<span class="lineNum">     383 </span>            :                                 Layer* aTransformedLayer,
<span class="lineNum">     384 </span>            :                                 FrameMetrics::ViewID aTransformedMetrics)
<span class="lineNum">     385 </span>            : {
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :   LayerMetricsWrapper transformed = FindMetricsWithScrollId(aTransformedLayer, aTransformedMetrics);</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   if (!transformed.IsValid()) {</span>
<span class="lineNum">     388 </span>            :     return false;
<span class="lineNum">     389 </span>            :   }
<span class="lineNum">     390 </span>            :   // It's important to start at the bottom, because the fixed layer itself
<span class="lineNum">     391 </span>            :   // could have the transformed metrics, and they can be at the bottom.
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   LayerMetricsWrapper current(aFixedLayer, LayerMetricsWrapper::StartAt::BOTTOM);</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :   bool encounteredTransformedLayer = false;</span>
<span class="lineNum">     394 </span>            :   // The transformed layer is on the path from |aFixedLayer| to the fixed-to
<span class="lineNum">     395 </span>            :   // layer if as we walk up the (layer, metrics) tree starting from
<span class="lineNum">     396 </span>            :   // |aFixedLayer|, we *first* encounter the transformed layer, and *then* (or
<span class="lineNum">     397 </span>            :   // at the same time) the fixed-to layer.
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :   while (current) {</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     if (!encounteredTransformedLayer &amp;&amp; current == transformed) {</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :       encounteredTransformedLayer = true;</span>
<span class="lineNum">     401 </span>            :     }
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :     if (current.Metrics().GetScrollId() == aFixedWithRespectTo) {</span>
<span class="lineNum">     403 </span>            :       return encounteredTransformedLayer;
<span class="lineNum">     404 </span>            :     }
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     current = current.GetParent();</span>
<span class="lineNum">     406 </span>            :     // It's possible that we reach a layers id boundary before we reach an
<span class="lineNum">     407 </span>            :     // ancestor with the scroll id |aFixedWithRespectTo| (this could happen
<span class="lineNum">     408 </span>            :     // e.g. if the scroll frame with that scroll id uses containerless
<span class="lineNum">     409 </span>            :     // scrolling). In such a case, stop the walk, as a new layers id could
<span class="lineNum">     410 </span>            :     // have a different layer with scroll id |aFixedWithRespectTo| which we
<span class="lineNum">     411 </span>            :     // don't intend to match.
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     if (current &amp;&amp; current.AsRefLayer() != nullptr) {</span>
<span class="lineNum">     413 </span>            :       break;
<span class="lineNum">     414 </span>            :     }
<span class="lineNum">     415 </span>            :   }
<span class="lineNum">     416 </span>            :   return false;
<span class="lineNum">     417 </span>            : }
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            : // If |aLayer| is fixed or sticky, returns the scroll id of the scroll frame
<span class="lineNum">     420 </span>            : // that it's fixed or sticky to. Otherwise, returns Nothing().
<span class="lineNum">     421 </span>            : static Maybe&lt;FrameMetrics::ViewID&gt;
<span class="lineNum">     422 </span><span class="lineNoCov">          0 : IsFixedOrSticky(Layer* aLayer)</span>
<span class="lineNum">     423 </span>            : {
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :   bool isRootOfFixedSubtree = aLayer-&gt;GetIsFixedPosition() &amp;&amp;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :     !aLayer-&gt;GetParent()-&gt;GetIsFixedPosition();</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   if (isRootOfFixedSubtree) {</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :     return Some(aLayer-&gt;GetFixedPositionScrollContainerId());</span>
<span class="lineNum">     428 </span>            :   }
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   if (aLayer-&gt;GetIsStickyPosition()) {</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :     return Some(aLayer-&gt;GetStickyScrollContainerId());</span>
<span class="lineNum">     431 </span>            :   }
<span class="lineNum">     432 </span>            :   return Nothing();
<span class="lineNum">     433 </span>            : }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : void
<span class="lineNum">     436 </span><span class="lineNoCov">          0 : AsyncCompositionManager::AlignFixedAndStickyLayers(Layer* aTransformedSubtreeRoot,</span>
<span class="lineNum">     437 </span>            :                                                    Layer* aStartTraversalAt,
<span class="lineNum">     438 </span>            :                                                    FrameMetrics::ViewID aTransformScrollId,
<span class="lineNum">     439 </span>            :                                                    const LayerToParentLayerMatrix4x4&amp; aPreviousTransformForRoot,
<span class="lineNum">     440 </span>            :                                                    const LayerToParentLayerMatrix4x4&amp; aCurrentTransformForRoot,
<span class="lineNum">     441 </span>            :                                                    const ScreenMargin&amp; aFixedLayerMargins,
<span class="lineNum">     442 </span>            :                                                    ClipPartsCache* aClipPartsCache)
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span>            :   // We're going to be inverting |aCurrentTransformForRoot|.
<span class="lineNum">     445 </span>            :   // If it's singular, there's nothing we can do.
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   if (aCurrentTransformForRoot.IsSingular()) {</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     448 </span>            :   }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   Layer* layer = aStartTraversalAt;</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :   bool needsAsyncTransformUnapplied = false;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   if (Maybe&lt;FrameMetrics::ViewID&gt; fixedTo = IsFixedOrSticky(layer)) {</span>
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :     needsAsyncTransformUnapplied = AsyncTransformShouldBeUnapplied(layer,</span>
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :         *fixedTo, aTransformedSubtreeRoot, aTransformScrollId);</span>
<span class="lineNum">     455 </span>            :   }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :   // We want to process all the fixed and sticky descendants of
<span class="lineNum">     458 </span>            :   // aTransformedSubtreeRoot. Once we do encounter such a descendant, we don't
<span class="lineNum">     459 </span>            :   // need to recurse any deeper because the adjustment to the fixed or sticky
<span class="lineNum">     460 </span>            :   // layer will apply to its subtree.
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :   if (!needsAsyncTransformUnapplied) {</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :     for (Layer* child = layer-&gt;GetFirstChild(); child; child = child-&gt;GetNextSibling()) {</span>
<span class="lineNum">     463 </span>            :       AlignFixedAndStickyLayers(aTransformedSubtreeRoot, child,
<span class="lineNum">     464 </span>            :           aTransformScrollId, aPreviousTransformForRoot,
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :           aCurrentTransformForRoot, aFixedLayerMargins, aClipPartsCache);</span>
<span class="lineNum">     466 </span>            :     }
<span class="lineNum">     467 </span>            :     return;
<span class="lineNum">     468 </span>            :   }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :   // Insert a translation so that the position of the anchor point is the same
<span class="lineNum">     471 </span>            :   // before and after the change to the transform of aTransformedSubtreeRoot.
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            :   // A transform creates a containing block for fixed-position descendants,
<span class="lineNum">     474 </span>            :   // so there shouldn't be a transform in between the fixed layer and
<span class="lineNum">     475 </span>            :   // the subtree root layer.
<span class="lineNum">     476 </span>            : #ifdef DEBUG
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   Matrix4x4 ancestorTransform;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   if (layer != aTransformedSubtreeRoot) {</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     AccumulateLayerTransforms(layer-&gt;GetParent(), aTransformedSubtreeRoot,</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                               ancestorTransform);</span>
<span class="lineNum">     481 </span>            :   }
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   ancestorTransform.NudgeToIntegersFixedEpsilon();</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(ancestorTransform.IsIdentity());</span>
<span class="lineNum">     484 </span>            : #endif
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            :   // Since we create container layers for fixed layers, there shouldn't
<span class="lineNum">     487 </span>            :   // a local CSS or OMTA transform on the fixed layer, either (any local
<span class="lineNum">     488 </span>            :   // transform would go onto a descendant layer inside the container
<span class="lineNum">     489 </span>            :   // layer).
<span class="lineNum">     490 </span>            : #ifdef DEBUG
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :   Matrix4x4 localTransform;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :   GetBaseTransform(layer, &amp;localTransform);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :   localTransform.NudgeToIntegersFixedEpsilon();</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(localTransform.IsIdentity());</span>
<span class="lineNum">     495 </span>            : #endif
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span>            :   // Now work out the translation necessary to make sure the layer doesn't
<span class="lineNum">     498 </span>            :   // move given the new sub-tree root transform.
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   // Get the layer's fixed anchor point, in the layer's local coordinate space
<span class="lineNum">     501 </span>            :   // (before any transform is applied).
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :   LayerPoint anchor = layer-&gt;GetFixedPositionAnchor();</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :   // Offset the layer's anchor point to make sure fixed position content
<span class="lineNum">     505 </span>            :   // respects content document fixed position margins.
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   LayerPoint offsetAnchor = anchor + GetLayerFixedMarginsOffset(layer, aFixedLayerMargins);</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :   // Additionally transform the anchor to compensate for the change
<span class="lineNum">     509 </span>            :   // from the old transform to the new transform. We do
<span class="lineNum">     510 </span>            :   // this by using the old transform to take the offset anchor back into
<span class="lineNum">     511 </span>            :   // subtree root space, and then the inverse of the new transform
<span class="lineNum">     512 </span>            :   // to bring it back to layer space.
<span class="lineNum">     513 </span>            :   ParentLayerPoint offsetAnchorInSubtreeRootSpace =
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       aPreviousTransformForRoot.TransformPoint(offsetAnchor);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   LayerPoint transformedAnchor = aCurrentTransformForRoot.Inverse()</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :       .TransformPoint(offsetAnchorInSubtreeRootSpace);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :   // We want to translate the layer by the difference between
<span class="lineNum">     519 </span>            :   // |transformedAnchor| and |anchor|.
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   LayerPoint translation = transformedAnchor - anchor;</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            :   // A fixed layer will &quot;consume&quot; (be unadjusted by) the entire translation
<span class="lineNum">     523 </span>            :   // calculated above. A sticky layer may consume all, part, or none of it,
<span class="lineNum">     524 </span>            :   // depending on where we are relative to its sticky scroll range.
<span class="lineNum">     525 </span>            :   // The remainder of the translation (the unconsumed portion) needs to
<span class="lineNum">     526 </span>            :   // be propagated to descendant fixed/sticky layers.
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   LayerPoint unconsumedTranslation;</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :   if (layer-&gt;GetIsStickyPosition()) {</span>
<span class="lineNum">     530 </span>            :     // For sticky positioned layers, the difference between the two rectangles
<span class="lineNum">     531 </span>            :     // defines a pair of translation intervals in each dimension through which
<span class="lineNum">     532 </span>            :     // the layer should not move relative to the scroll container. To
<span class="lineNum">     533 </span>            :     // accomplish this, we limit each dimension of the |translation| to that
<span class="lineNum">     534 </span>            :     // part of it which overlaps those intervals.
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :     const LayerRectAbsolute&amp; stickyOuter = layer-&gt;GetStickyScrollRangeOuter();</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :     const LayerRectAbsolute&amp; stickyInner = layer-&gt;GetStickyScrollRangeInner();</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :     LayerPoint originalTranslation = translation;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     translation.y = IntervalOverlap(translation.y, stickyOuter.Y(), stickyOuter.YMost()) -</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                     IntervalOverlap(translation.y, stickyInner.Y(), stickyInner.YMost());</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     translation.x = IntervalOverlap(translation.x, stickyOuter.X(), stickyOuter.XMost()) -</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :                     IntervalOverlap(translation.x, stickyInner.X(), stickyInner.XMost());</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     unconsumedTranslation = translation - originalTranslation;</span>
<span class="lineNum">     544 </span>            :   }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :   // Finally, apply the translation to the layer transform. Note that in cases
<span class="lineNum">     547 </span>            :   // where the async transform on |aTransformedSubtreeRoot| affects this layer's
<span class="lineNum">     548 </span>            :   // clip rect, we need to apply the same translation to said clip rect, so
<span class="lineNum">     549 </span>            :   // that the effective transform on the clip rect takes it back to where it was
<span class="lineNum">     550 </span>            :   // originally, had there been no async scroll.
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :   TranslateShadowLayer(layer, ViewAs&lt;ParentLayerPixel&gt;(translation,</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       PixelCastJustification::NoTransformOnLayer), true, aClipPartsCache);</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   // Propragate the unconsumed portion of the translation to descendant
<span class="lineNum">     555 </span>            :   // fixed/sticky layers.
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (unconsumedTranslation != LayerPoint()) {</span>
<span class="lineNum">     557 </span>            :     // Take the computations we performed to derive |translation| from
<span class="lineNum">     558 </span>            :     // |aCurrentTransformForRoot|, and perform them in reverse, keeping other
<span class="lineNum">     559 </span>            :     // quantities fixed, to come up with a new transform |newTransform| that
<span class="lineNum">     560 </span>            :     // would produce |unconsumedTranslation|.
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     LayerPoint newTransformedAnchor = unconsumedTranslation + anchor;</span>
<span class="lineNum">     562 </span>            :     ParentLayerPoint newTransformedAnchorInSubtreeRootSpace =
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :         aPreviousTransformForRoot.TransformPoint(newTransformedAnchor);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :     LayerToParentLayerMatrix4x4 newTransform = aPreviousTransformForRoot;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     newTransform.PostTranslate(newTransformedAnchorInSubtreeRootSpace -</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                                offsetAnchorInSubtreeRootSpace);</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :     // Propagate this new transform to our descendants as the new value of
<span class="lineNum">     569 </span>            :     // |aCurrentTransformForRoot|. This allows them to consume the unconsumed
<span class="lineNum">     570 </span>            :     // translation.
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     for (Layer* child = layer-&gt;GetFirstChild(); child; child = child-&gt;GetNextSibling()) {</span>
<span class="lineNum">     572 </span>            :       AlignFixedAndStickyLayers(aTransformedSubtreeRoot, child, aTransformScrollId,
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :           aPreviousTransformForRoot, newTransform, aFixedLayerMargins, aClipPartsCache);</span>
<span class="lineNum">     574 </span>            :     }
<span class="lineNum">     575 </span>            :   }
<span class="lineNum">     576 </span>            : }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            : static Matrix4x4
<span class="lineNum">     579 </span><span class="lineNoCov">          0 : ServoAnimationValueToMatrix4x4(const RefPtr&lt;RawServoAnimationValue&gt;&amp; aValue,</span>
<span class="lineNum">     580 </span>            :                                const TransformData&amp; aTransformData)
<span class="lineNum">     581 </span>            : {
<span class="lineNum">     582 </span>            :   // FIXME: Bug 1457033: We should convert servo's animation value to matrix
<span class="lineNum">     583 </span>            :   // directly without nsCSSValueSharedList.
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   RefPtr&lt;nsCSSValueSharedList&gt; list;</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   Servo_AnimationValue_GetTransform(aValue, &amp;list);</span>
<span class="lineNum">     586 </span>            :   // we expect all our transform data to arrive in device pixels
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   Point3D transformOrigin = aTransformData.transformOrigin();</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :   nsDisplayTransform::FrameTransformProperties props(std::move(list),</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                                                      transformOrigin);</span>
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            :   return nsDisplayTransform::GetResultingTransformMatrix(
<span class="lineNum">     592 </span>            :     props, aTransformData.origin(),
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :     aTransformData.appUnitsPerDevPixel(),</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :     0, &amp;aTransformData.bounds());</span>
<span class="lineNum">     595 </span>            : }
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : static Matrix4x4
<span class="lineNum">     599 </span><span class="lineNoCov">          0 : FrameTransformToTransformInDevice(const Matrix4x4&amp; aFrameTransform,</span>
<span class="lineNum">     600 </span>            :                                   Layer* aLayer,
<span class="lineNum">     601 </span>            :                                   const TransformData&amp; aTransformData)
<span class="lineNum">     602 </span>            : {
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   Matrix4x4 transformInDevice = aFrameTransform;</span>
<span class="lineNum">     604 </span>            :   // If our parent layer is a perspective layer, then the offset into reference
<span class="lineNum">     605 </span>            :   // frame coordinates is already on that layer. If not, then we need to ask
<span class="lineNum">     606 </span>            :   // for it to be added here.
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   if (!aLayer-&gt;GetParent() ||</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       !aLayer-&gt;GetParent()-&gt;GetTransformIsPerspective()) {</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     nsLayoutUtils::PostTranslate(transformInDevice, aTransformData.origin(),</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       aTransformData.appUnitsPerDevPixel(),</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :       true);</span>
<span class="lineNum">     612 </span>            :   }
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :   if (ContainerLayer* c = aLayer-&gt;AsContainerLayer()) {</span>
<span class="lineNum">     615 </span>            :     transformInDevice.PostScale(c-&gt;GetInheritedXScale(),
<span class="lineNum">     616 </span>            :                                 c-&gt;GetInheritedYScale(),
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :                                 1);</span>
<span class="lineNum">     618 </span>            :   }
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   return transformInDevice;</span>
<span class="lineNum">     621 </span>            : }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            : static void
<span class="lineNum">     624 </span><span class="lineNoCov">          0 : ApplyAnimatedValue(Layer* aLayer,</span>
<span class="lineNum">     625 </span>            :                    CompositorAnimationStorage* aStorage,
<span class="lineNum">     626 </span>            :                    nsCSSPropertyID aProperty,
<span class="lineNum">     627 </span>            :                    const AnimationData&amp; aAnimationData,
<span class="lineNum">     628 </span>            :                    const RefPtr&lt;RawServoAnimationValue&gt;&amp; aValue)
<span class="lineNum">     629 </span>            : {
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   if (!aValue) {</span>
<span class="lineNum">     631 </span>            :     // Return gracefully if we have no valid AnimationValue.
<span class="lineNum">     632 </span>            :     return;
<span class="lineNum">     633 </span>            :   }
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :   HostLayer* layerCompositor = aLayer-&gt;AsHostLayer();</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :   switch (aProperty) {</span>
<span class="lineNum">     637 </span>            :     case eCSSProperty_opacity: {
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :       float opacity = Servo_AnimationValue_GetOpacity(aValue);</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowOpacity(opacity);</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowOpacitySetByAnimation(true);</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :       aStorage-&gt;SetAnimatedValue(aLayer-&gt;GetCompositorAnimationsId(), opacity);</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowBaseTransform(aLayer-&gt;GetBaseTransform());</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowTransformSetByAnimation(false);</span>
<span class="lineNum">     645 </span>            :       break;
<span class="lineNum">     646 </span>            :     }
<span class="lineNum">     647 </span>            :     case eCSSProperty_transform: {
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       const TransformData&amp; transformData = aAnimationData.get_TransformData();</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            :       Matrix4x4 frameTransform =
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :         ServoAnimationValueToMatrix4x4(aValue, transformData);</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :       Matrix4x4 transform =
<span class="lineNum">     654 </span>            :         FrameTransformToTransformInDevice(frameTransform,
<span class="lineNum">     655 </span>            :                                           aLayer,
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :                                           transformData);</span>
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowBaseTransform(transform);</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowTransformSetByAnimation(true);</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :       aStorage-&gt;SetAnimatedValue(aLayer-&gt;GetCompositorAnimationsId(),</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :                                  std::move(transform), std::move(frameTransform),</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :                                  transformData);</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowOpacity(aLayer-&gt;GetOpacity());</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :       layerCompositor-&gt;SetShadowOpacitySetByAnimation(false);</span>
<span class="lineNum">     666 </span>            :       break;
<span class="lineNum">     667 </span>            :     }
<span class="lineNum">     668 </span>            :     default:
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :       MOZ_ASSERT_UNREACHABLE(&quot;Unhandled animated property&quot;);</span>
<span class="lineNum">     670 </span>            :   }
<span class="lineNum">     671 </span>            : }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : static bool
<span class="lineNum">     674 </span><span class="lineNoCov">          0 : SampleAnimations(Layer* aLayer,</span>
<span class="lineNum">     675 </span>            :                  CompositorAnimationStorage* aStorage,
<span class="lineNum">     676 </span>            :                  TimeStamp aPreviousFrameTime,
<span class="lineNum">     677 </span>            :                  TimeStamp aCurrentFrameTime)
<span class="lineNum">     678 </span>            : {
<span class="lineNum">     679 </span><span class="lineNoCov">          0 :   bool isAnimating = false;</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   ForEachNode&lt;ForwardIterator&gt;(</span>
<span class="lineNum">     682 </span>            :       aLayer,
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :       [&amp;] (Layer* layer)</span>
<span class="lineNum">     684 </span>            :       {
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :         AnimationArray&amp; animations = layer-&gt;GetAnimations();</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :         if (animations.IsEmpty()) {</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">     688 </span>            :         }
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         isAnimating = true;</span>
<span class="lineNum">     690 </span>            :         AnimatedValue* previousValue =
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :           aStorage-&gt;GetAnimatedValue(layer-&gt;GetCompositorAnimationsId());</span>
<span class="lineNum">     692 </span>            :         RefPtr&lt;RawServoAnimationValue&gt; animationValue =
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :           layer-&gt;GetBaseAnimationStyle();</span>
<span class="lineNum">     694 </span>            :         AnimationHelper::SampleResult sampleResult =
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :           AnimationHelper::SampleAnimationForEachNode(aPreviousFrameTime,</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :                                                       aCurrentFrameTime,</span>
<span class="lineNum">     697 </span>            :                                                       animations,
<span class="lineNum">     698 </span>            :                                                       layer-&gt;GetAnimationData(),
<span class="lineNum">     699 </span>            :                                                       animationValue,
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :                                                       previousValue);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         switch (sampleResult) {</span>
<span class="lineNum">     702 </span>            :           case AnimationHelper::SampleResult::Sampled: {
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :             Animation&amp; animation = animations.LastElement();</span>
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :             ApplyAnimatedValue(layer,</span>
<span class="lineNum">     705 </span>            :                                aStorage,
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :                                animation.property(),</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                                animation.data(),</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :                                animationValue);</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     710 </span>            :           }
<span class="lineNum">     711 </span>            :           case AnimationHelper::SampleResult::Skipped:
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :             switch (animations[0].property()) {</span>
<span class="lineNum">     713 </span>            :               case eCSSProperty_opacity: {
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(</span>
<span class="lineNum">     715 </span>            :                   layer-&gt;AsHostLayer()-&gt;GetShadowOpacitySetByAnimation());
<span class="lineNum">     716 </span>            : #ifdef DEBUG
<span class="lineNum">     717 </span>            :                 // Disable this assertion until the root cause is fixed in bug
<span class="lineNum">     718 </span>            :                 // 1459775.
<span class="lineNum">     719 </span>            :                 // MOZ_ASSERT(FuzzyEqualsMultiplicative(
<span class="lineNum">     720 </span>            :                 //   Servo_AnimationValue_GetOpacity(animationValue),
<span class="lineNum">     721 </span>            :                 //   *(aStorage-&gt;GetAnimationOpacity(layer-&gt;GetCompositorAnimationsId()))));
<span class="lineNum">     722 </span>            : #endif
<span class="lineNum">     723 </span>            :                 // Even if opacity animation value has unchanged, we have to set
<span class="lineNum">     724 </span>            :                 // the shadow base transform value here since the value might
<span class="lineNum">     725 </span>            :                 // have been changed by APZC.
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :                 HostLayer* layerCompositor = layer-&gt;AsHostLayer();</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :                 layerCompositor-&gt;SetShadowBaseTransform(</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :                   layer-&gt;GetBaseTransform());</span>
<span class="lineNum">     729 </span>            :                 layerCompositor-&gt;SetShadowTransformSetByAnimation(false);
<span class="lineNum">     730 </span>            :                 break;
<span class="lineNum">     731 </span>            :               }
<span class="lineNum">     732 </span>            :               case eCSSProperty_transform: {
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(</span>
<span class="lineNum">     734 </span>            :                   layer-&gt;AsHostLayer()-&gt;GetShadowTransformSetByAnimation());
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(previousValue);</span>
<span class="lineNum">     736 </span>            : #ifdef DEBUG
<span class="lineNum">     737 </span>            :                 const TransformData&amp; transformData =
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :                   animations[0].data().get_TransformData();</span>
<span class="lineNum">     739 </span>            :                 Matrix4x4 frameTransform =
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                   ServoAnimationValueToMatrix4x4(animationValue, transformData);</span>
<span class="lineNum">     741 </span>            :                 Matrix4x4 transformInDevice =
<span class="lineNum">     742 </span>            :                   FrameTransformToTransformInDevice(frameTransform,
<span class="lineNum">     743 </span>            :                                                     layer,
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                                                     transformData);</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(</span>
<span class="lineNum">     746 </span>            :                   previousValue-&gt;mTransform.mTransformInDevSpace.FuzzyEqualsMultiplicative(
<span class="lineNum">     747 </span>            :                   transformInDevice));
<span class="lineNum">     748 </span>            : #endif
<span class="lineNum">     749 </span>            :                 // In the case of transform we have to set the unchanged
<span class="lineNum">     750 </span>            :                 // transform value again becasue APZC might have modified the
<span class="lineNum">     751 </span>            :                 // previous shadow base transform value.
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :                 HostLayer* layerCompositor = layer-&gt;AsHostLayer();</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :                 layerCompositor-&gt;SetShadowBaseTransform(</span>
<span class="lineNum">     754 </span>            :                   // FIXME: Bug 1459775: It seems possible that we somehow try
<span class="lineNum">     755 </span>            :                   // to sample animations and skip it even if the previous value
<span class="lineNum">     756 </span>            :                   // has been discarded from the animation storage when we enable
<span class="lineNum">     757 </span>            :                   // layer tree cache. So for the safety, in the case where we
<span class="lineNum">     758 </span>            :                   // have no previous animation value, we set non-animating value
<span class="lineNum">     759 </span>            :                   // instead.
<span class="lineNum">     760 </span>            :                   previousValue
<span class="lineNum">     761 </span>            :                     ? previousValue-&gt;mTransform.mTransformInDevSpace
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :                     : layer-&gt;GetBaseTransform());</span>
<span class="lineNum">     763 </span>            :                 break;
<span class="lineNum">     764 </span>            :               }
<span class="lineNum">     765 </span>            :               default:
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT_UNREACHABLE(&quot;Unsupported properties&quot;);</span>
<span class="lineNum">     767 </span>            :                 break;
<span class="lineNum">     768 </span>            :             }
<span class="lineNum">     769 </span>            :             break;
<span class="lineNum">     770 </span>            :           case AnimationHelper::SampleResult::None: {
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :             HostLayer* layerCompositor = layer-&gt;AsHostLayer();</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :             layerCompositor-&gt;SetShadowBaseTransform(layer-&gt;GetBaseTransform());</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :             layerCompositor-&gt;SetShadowTransformSetByAnimation(false);</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :             layerCompositor-&gt;SetShadowOpacity(layer-&gt;GetOpacity());</span>
<span class="lineNum">     775 </span>            :             layerCompositor-&gt;SetShadowOpacitySetByAnimation(false);
<span class="lineNum">     776 </span>            :             break;
<span class="lineNum">     777 </span>            :           }
<span class="lineNum">     778 </span>            :           default:
<span class="lineNum">     779 </span>            :             break;
<span class="lineNum">     780 </span>            :         }
<span class="lineNum">     781 </span><span class="lineCov">          1 :       });</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span><span class="lineCov">          8 :   return isAnimating;</span>
<span class="lineNum">     784 </span>            : }
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : void
<span class="lineNum">     787 </span><span class="lineNoCov">          0 : AsyncCompositionManager::RecordShadowTransforms(Layer* aLayer)</span>
<span class="lineNum">     788 </span>            : {
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(gfxPrefs::CollectScrollTransforms());</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CompositorThreadHolder::IsInCompositorThread());</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :   ForEachNodePostOrder&lt;ForwardIterator&gt;(</span>
<span class="lineNum">     793 </span>            :       aLayer,
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :       [this] (Layer* layer)</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :         for (uint32_t i = 0; i &lt; layer-&gt;GetScrollMetadataCount(); i++) {</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :           if (!layer-&gt;GetFrameMetrics(i).IsScrollable()) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     799 </span>            :           }
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :           gfx::Matrix4x4 shadowTransform = layer-&gt;AsHostLayer()-&gt;GetShadowBaseTransform();</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :           if (!shadowTransform.Is2D()) {</span>
<span class="lineNum">     802 </span>            :             continue;
<span class="lineNum">     803 </span>            :           }
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :           Matrix transform = shadowTransform.As2D();</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :           if (transform.IsTranslation() &amp;&amp; !shadowTransform.IsIdentity()) {</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :             Point translation = transform.GetTranslation();</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :             mLayerTransformRecorder.RecordTransform(layer, translation);</span>
<span class="lineNum">     809 </span>            :             return;
<span class="lineNum">     810 </span>            :           }
<span class="lineNum">     811 </span>            :         }
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       });</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : static AsyncTransformComponentMatrix
<span class="lineNum">     816 </span><span class="lineNoCov">          0 : AdjustForClip(const AsyncTransformComponentMatrix&amp; asyncTransform, Layer* aLayer)</span>
<span class="lineNum">     817 </span>            : {
<span class="lineNum">     818 </span><span class="lineCov">         16 :   AsyncTransformComponentMatrix result = asyncTransform;</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :   // Container layers start at the origin, but they are clipped to where they
<span class="lineNum">     821 </span>            :   // actually have content on the screen. The tree transform is meant to apply
<span class="lineNum">     822 </span>            :   // to the clipped area. If the tree transform includes a scale component,
<span class="lineNum">     823 </span>            :   // then applying it to container as-is will produce incorrect results. To
<span class="lineNum">     824 </span>            :   // avoid this, translate the layer so that the clip rect starts at the origin,
<span class="lineNum">     825 </span>            :   // apply the tree transform, and translate back.
<span class="lineNum">     826 </span><span class="lineCov">         32 :   if (const Maybe&lt;ParentLayerIntRect&gt;&amp; shadowClipRect = aLayer-&gt;AsHostLayer()-&gt;GetShadowClipRect()) {</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :     if (shadowClipRect-&gt;TopLeft() != ParentLayerIntPoint()) {  // avoid a gratuitous change of basis</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       result.ChangeBasis(shadowClipRect-&gt;X(), shadowClipRect-&gt;Y(), 0);</span>
<span class="lineNum">     829 </span>            :     }
<span class="lineNum">     830 </span>            :   }
<span class="lineNum">     831 </span><span class="lineCov">         16 :   return result;</span>
<span class="lineNum">     832 </span>            : }
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            : static void
<span class="lineNum">     835 </span><span class="lineCov">         16 : ExpandRootClipRect(Layer* aLayer, const ScreenMargin&amp; aFixedLayerMargins)</span>
<span class="lineNum">     836 </span>            : {
<span class="lineNum">     837 </span>            :   // For Fennec we want to expand the root scrollable layer clip rect based on
<span class="lineNum">     838 </span>            :   // the fixed position margins. In particular, we want this while the dynamic
<span class="lineNum">     839 </span>            :   // toolbar is in the process of sliding offscreen and the area of the
<span class="lineNum">     840 </span>            :   // LayerView visible to the user is larger than the viewport size that Gecko
<span class="lineNum">     841 </span>            :   // knows about (and therefore larger than the clip rect). We could also just
<span class="lineNum">     842 </span>            :   // clear the clip rect on aLayer entirely but this seems more precise.
<span class="lineNum">     843 </span><span class="lineCov">         48 :   Maybe&lt;ParentLayerIntRect&gt; rootClipRect = aLayer-&gt;AsHostLayer()-&gt;GetShadowClipRect();</span>
<span class="lineNum">     844 </span><span class="lineCov">         32 :   if (rootClipRect &amp;&amp; aFixedLayerMargins != ScreenMargin()) {</span>
<span class="lineNum">     845 </span>            : #ifndef MOZ_WIDGET_ANDROID
<span class="lineNum">     846 </span>            :     // We should never enter here on anything other than Fennec, since
<span class="lineNum">     847 </span>            :     // aFixedLayerMargins should be empty everywhere else.
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(false);</span>
<span class="lineNum">     849 </span>            : #endif
<span class="lineNum">     850 </span>            :     ParentLayerRect rect(rootClipRect.value());
<span class="lineNum">     851 </span>            :     rect.Deflate(ViewAs&lt;ParentLayerPixel&gt;(aFixedLayerMargins,
<span class="lineNum">     852 </span>            :       PixelCastJustification::ScreenIsParentLayerForRoot));
<span class="lineNum">     853 </span>            :     aLayer-&gt;AsHostLayer()-&gt;SetShadowClipRect(Some(RoundedOut(rect)));
<span class="lineNum">     854 </span>            :   }
<span class="lineNum">     855 </span><span class="lineCov">         16 : }</span>
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            : #ifdef MOZ_WIDGET_ANDROID
<span class="lineNum">     858 </span>            : static void
<span class="lineNum">     859 </span>            : MoveScrollbarForLayerMargin(Layer* aRoot, FrameMetrics::ViewID aRootScrollId,
<span class="lineNum">     860 </span>            :                             const ScreenMargin&amp; aFixedLayerMargins)
<span class="lineNum">     861 </span>            : {
<span class="lineNum">     862 </span>            :   // See bug 1223928 comment 9 - once we can detect the RCD with just the
<span class="lineNum">     863 </span>            :   // isRootContent flag on the metrics, we can probably move this code into
<span class="lineNum">     864 </span>            :   // ApplyAsyncTransformToScrollbar rather than having it as a separate
<span class="lineNum">     865 </span>            :   // adjustment on the layer tree.
<span class="lineNum">     866 </span>            :   Layer* scrollbar = BreadthFirstSearch&lt;ReverseIterator&gt;(aRoot,
<span class="lineNum">     867 </span>            :     [aRootScrollId](Layer* aNode) {
<span class="lineNum">     868 </span>            :       return (aNode-&gt;GetScrollbarData().IsThumb() &amp;&amp;
<span class="lineNum">     869 </span>            :               aNode-&gt;GetScrollbarData().mDirection.isSome() &amp;&amp;
<span class="lineNum">     870 </span>            :               *aNode-&gt;GetScrollbarData().mDirection == ScrollDirection::eHorizontal &amp;&amp;
<span class="lineNum">     871 </span>            :               aNode-&gt;GetScrollbarData().mTargetViewId == aRootScrollId);
<span class="lineNum">     872 </span>            :     });
<span class="lineNum">     873 </span>            :   if (scrollbar) {
<span class="lineNum">     874 </span>            :     // Shift the horizontal scrollbar down into the new space exposed by the
<span class="lineNum">     875 </span>            :     // dynamic toolbar hiding. Technically we should also scale the vertical
<span class="lineNum">     876 </span>            :     // scrollbar a bit to expand into the new space but it's not as noticeable
<span class="lineNum">     877 </span>            :     // and it would add a lot more complexity, so we're going with the &quot;it's not
<span class="lineNum">     878 </span>            :     // worth it&quot; justification.
<span class="lineNum">     879 </span>            :     TranslateShadowLayer(scrollbar, ParentLayerPoint(0, -aFixedLayerMargins.bottom), true, nullptr);
<span class="lineNum">     880 </span>            :     if (scrollbar-&gt;GetParent()) {
<span class="lineNum">     881 </span>            :       // The layer that has the HORIZONTAL direction sits inside another
<span class="lineNum">     882 </span>            :       // ContainerLayer. This ContainerLayer also has a clip rect that causes
<span class="lineNum">     883 </span>            :       // the scrollbar to get clipped. We need to expand that clip rect to
<span class="lineNum">     884 </span>            :       // prevent that from happening. This is kind of ugly in that we're
<span class="lineNum">     885 </span>            :       // assuming a particular layer tree structure but short of adding more
<span class="lineNum">     886 </span>            :       // flags to the layer there doesn't appear to be a good way to do this.
<span class="lineNum">     887 </span>            :       ExpandRootClipRect(scrollbar-&gt;GetParent(), aFixedLayerMargins);
<span class="lineNum">     888 </span>            :     }
<span class="lineNum">     889 </span>            :   }
<span class="lineNum">     890 </span>            : }
<span class="lineNum">     891 </span>            : #endif
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span>            : bool
<span class="lineNum">     894 </span><span class="lineNoCov">          0 : AsyncCompositionManager::ApplyAsyncContentTransformToTree(Layer *aLayer,</span>
<span class="lineNum">     895 </span>            :                                                           bool* aOutFoundRoot)
<span class="lineNum">     896 </span>            : {
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   bool appliedTransform = false;</span>
<span class="lineNum">     898 </span><span class="lineCov">         24 :   std::stack&lt;Maybe&lt;ParentLayerIntRect&gt;&gt; stackDeferredClips;</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :   // Maps layers to their ClipParts. The parts are not stored individually
<span class="lineNum">     901 </span>            :   // on the layer, but during AlignFixedAndStickyLayers we need access to
<span class="lineNum">     902 </span>            :   // the individual parts for descendant layers.
<span class="lineNum">     903 </span><span class="lineCov">         16 :   ClipPartsCache clipPartsCache;</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineCov">         16 :   ForEachNode&lt;ForwardIterator&gt;(</span>
<span class="lineNum">     906 </span>            :       aLayer,
<span class="lineNum">     907 </span><span class="lineCov">         16 :       [&amp;stackDeferredClips] (Layer* layer)</span>
<span class="lineNum">     908 </span><span class="lineCov">         16 :       {</span>
<span class="lineNum">     909 </span><span class="lineCov">         48 :         stackDeferredClips.push(Maybe&lt;ParentLayerIntRect&gt;());</span>
<span class="lineNum">     910 </span><span class="lineCov">         16 :       },</span>
<span class="lineNum">     911 </span><span class="lineCov">         16 :       [this, &amp;aOutFoundRoot, &amp;stackDeferredClips, &amp;appliedTransform, &amp;clipPartsCache] (Layer* layer)</span>
<span class="lineNum">     912 </span><span class="lineCov">        104 :       {</span>
<span class="lineNum">     913 </span><span class="lineCov">         32 :         Maybe&lt;ParentLayerIntRect&gt; clipDeferredFromChildren = stackDeferredClips.top();</span>
<span class="lineNum">     914 </span><span class="lineCov">         16 :         stackDeferredClips.pop();</span>
<span class="lineNum">     915 </span><span class="lineCov">         32 :         LayerToParentLayerMatrix4x4 oldTransform = layer-&gt;GetTransformTyped() *</span>
<span class="lineNum">     916 </span><span class="lineCov">         48 :             AsyncTransformMatrix();</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineCov">         16 :         AsyncTransformComponentMatrix combinedAsyncTransform;</span>
<span class="lineNum">     919 </span><span class="lineCov">         16 :         bool hasAsyncTransform = false;</span>
<span class="lineNum">     920 </span>            :         // Only set on the root layer for Android.
<span class="lineNum">     921 </span><span class="lineCov">         16 :         ScreenMargin fixedLayerMargins;</span>
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            :         // Each layer has multiple clips:
<span class="lineNum">     924 </span>            :         //  - Its local clip, which is fixed to the layer contents, i.e. it moves
<span class="lineNum">     925 </span>            :         //    with those async transforms which the layer contents move with.
<span class="lineNum">     926 </span>            :         //  - Its scrolled clip, which moves with all async transforms.
<span class="lineNum">     927 </span>            :         //  - For each ScrollMetadata on the layer, a scroll clip. This includes
<span class="lineNum">     928 </span>            :         //    the composition bounds and any other clips induced by layout. This
<span class="lineNum">     929 </span>            :         //    moves with async transforms from ScrollMetadatas above it.
<span class="lineNum">     930 </span>            :         // In this function, these clips are combined into two shadow clip parts:
<span class="lineNum">     931 </span>            :         //  - The fixed clip, which consists of the local clip only, initially
<span class="lineNum">     932 </span>            :         //    transformed by all async transforms.
<span class="lineNum">     933 </span>            :         //  - The scrolled clip, which consists of the other clips, transformed by
<span class="lineNum">     934 </span>            :         //    the appropriate transforms.
<span class="lineNum">     935 </span>            :         // These two parts are kept separate for now, because for fixed layers, we
<span class="lineNum">     936 </span>            :         // need to adjust the fixed clip (to cancel out some async transforms).
<span class="lineNum">     937 </span>            :         // The parts are kept in a cache which is cleared at the beginning of every
<span class="lineNum">     938 </span>            :         // composite.
<span class="lineNum">     939 </span>            :         // The final shadow clip for the layer is the intersection of the (possibly
<span class="lineNum">     940 </span>            :         // adjusted) fixed clip and the scrolled clip.
<span class="lineNum">     941 </span><span class="lineCov">         16 :         ClipParts&amp; clipParts = clipPartsCache[layer];</span>
<span class="lineNum">     942 </span><span class="lineCov">         32 :         clipParts.mFixedClip = layer-&gt;GetClipRect();</span>
<span class="lineNum">     943 </span><span class="lineCov">         32 :         clipParts.mScrolledClip = layer-&gt;GetScrolledClipRect();</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :         // If we are a perspective transform ContainerLayer, apply the clip deferred
<span class="lineNum">     946 </span>            :         // from our child (if there is any) before we iterate over our frame metrics,
<span class="lineNum">     947 </span>            :         // because this clip is subject to all async transforms of this layer.
<span class="lineNum">     948 </span>            :         // Since this clip came from the a scroll clip on the child, it becomes part
<span class="lineNum">     949 </span>            :         // of our scrolled clip.
<span class="lineNum">     950 </span><span class="lineCov">         32 :         clipParts.mScrolledClip = IntersectMaybeRects(</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :             clipDeferredFromChildren, clipParts.mScrolledClip);</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :         // The transform of a mask layer is relative to the masked layer's parent
<span class="lineNum">     954 </span>            :         // layer. So whenever we apply an async transform to a layer, we need to
<span class="lineNum">     955 </span>            :         // apply that same transform to the layer's own mask layer.
<span class="lineNum">     956 </span>            :         // A layer can also have &quot;ancestor&quot; mask layers for any rounded clips from
<span class="lineNum">     957 </span>            :         // its ancestor scroll frames. A scroll frame mask layer only needs to be
<span class="lineNum">     958 </span>            :         // async transformed for async scrolls of this scroll frame's ancestor
<span class="lineNum">     959 </span>            :         // scroll frames, not for async scrolls of this scroll frame itself.
<span class="lineNum">     960 </span>            :         // In the loop below, we iterate over scroll frames from inside to outside.
<span class="lineNum">     961 </span>            :         // At each iteration, this array contains the layer's ancestor mask layers
<span class="lineNum">     962 </span>            :         // of all scroll frames inside the current one.
<span class="lineNum">     963 </span><span class="lineCov">         32 :         nsTArray&lt;Layer*&gt; ancestorMaskLayers;</span>
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            :         // The layer's scrolled clip can have an ancestor mask layer as well,
<span class="lineNum">     966 </span>            :         // which is moved by all async scrolls on this layer.
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         if (const Maybe&lt;LayerClip&gt;&amp; scrolledClip = layer-&gt;GetScrolledClip()) {</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :           if (scrolledClip-&gt;GetMaskLayerIndex()) {</span>
<span class="lineNum">     969 </span>            :             ancestorMaskLayers.AppendElement(
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                 layer-&gt;GetAncestorMaskLayerAt(*scrolledClip-&gt;GetMaskLayerIndex()));</span>
<span class="lineNum">     971 </span>            :           }
<span class="lineNum">     972 </span>            :         }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :         if (RefPtr&lt;APZSampler&gt; sampler = mCompositorBridge-&gt;GetAPZSampler()) {</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :           for (uint32_t i = 0; i &lt; layer-&gt;GetScrollMetadataCount(); i++) {</span>
<span class="lineNum">     976 </span><span class="lineCov">          8 :             LayerMetricsWrapper wrapper(layer, i);</span>
<span class="lineNum">     977 </span><span class="lineCov">          8 :             if (!wrapper.GetApzc()) {</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :               continue;</span>
<span class="lineNum">     979 </span>            :             }
<span class="lineNum">     980 </span><span class="lineCov">          8 :             const FrameMetrics&amp; metrics = wrapper.Metrics();</span>
<span class="lineNum">     981 </span><span class="lineCov">          8 :             MOZ_ASSERT(metrics.IsScrollable());</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineCov">          8 :             hasAsyncTransform = true;</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :             AsyncTransform asyncTransformWithoutOverscroll =
<span class="lineNum">     986 </span><span class="lineCov">          8 :                 sampler-&gt;GetCurrentAsyncTransform(wrapper);</span>
<span class="lineNum">     987 </span>            :             AsyncTransformComponentMatrix overscrollTransform =
<span class="lineNum">     988 </span><span class="lineCov">          8 :                 sampler-&gt;GetOverscrollTransform(wrapper);</span>
<span class="lineNum">     989 </span>            :             AsyncTransformComponentMatrix asyncTransform =
<span class="lineNum">     990 </span><span class="lineCov">         16 :                 AsyncTransformComponentMatrix(asyncTransformWithoutOverscroll)</span>
<span class="lineNum">     991 </span><span class="lineCov">          8 :               * overscrollTransform;</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineCov">          8 :             if (!layer-&gt;IsScrollableWithoutContent()) {</span>
<span class="lineNum">     994 </span><span class="lineCov">          8 :               sampler-&gt;MarkAsyncTransformAppliedToContent(wrapper);</span>
<span class="lineNum">     995 </span>            :             }
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineCov">          8 :             const ScrollMetadata&amp; scrollMetadata = wrapper.Metadata();</span>
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1000 </span>            :             // If we find a metrics which is the root content doc, use that. If not, use
<span class="lineNum">    1001 </span>            :             // the root layer. Since this function recurses on children first we should
<span class="lineNum">    1002 </span>            :             // only end up using the root layer if the entire tree was devoid of a
<span class="lineNum">    1003 </span>            :             // root content metrics. This is a temporary solution; in the long term we
<span class="lineNum">    1004 </span>            :             // should not need the root content metrics at all. See bug 1201529 comment
<span class="lineNum">    1005 </span>            :             // 6 for details.
<span class="lineNum">    1006 </span>            :             if (!(*aOutFoundRoot)) {
<span class="lineNum">    1007 </span>            :               *aOutFoundRoot = metrics.IsRootContent() ||       /* RCD */
<span class="lineNum">    1008 </span>            :                     (layer-&gt;GetParent() == nullptr &amp;&amp;          /* rootmost metrics */
<span class="lineNum">    1009 </span>            :                      i + 1 &gt;= layer-&gt;GetScrollMetadataCount());
<span class="lineNum">    1010 </span>            :               if (*aOutFoundRoot) {
<span class="lineNum">    1011 </span>            :                 mRootScrollableId = metrics.GetScrollId();
<span class="lineNum">    1012 </span>            :                 Compositor* compositor = mLayerManager-&gt;GetCompositor();
<span class="lineNum">    1013 </span>            :                 if (CompositorBridgeParent* bridge = compositor-&gt;GetCompositorBridgeParent()) {
<span class="lineNum">    1014 </span>            :                   AndroidDynamicToolbarAnimator* animator = bridge-&gt;GetAndroidDynamicToolbarAnimator();
<span class="lineNum">    1015 </span>            :                   MOZ_ASSERT(animator);
<span class="lineNum">    1016 </span>            :                   if (mIsFirstPaint) {
<span class="lineNum">    1017 </span>            :                     animator-&gt;UpdateRootFrameMetrics(metrics);
<span class="lineNum">    1018 </span>            :                     animator-&gt;FirstPaint();
<span class="lineNum">    1019 </span>            :                     mIsFirstPaint = false;
<span class="lineNum">    1020 </span>            :                   }
<span class="lineNum">    1021 </span>            :                   if (mLayersUpdated) {
<span class="lineNum">    1022 </span>            :                     animator-&gt;NotifyLayersUpdated();
<span class="lineNum">    1023 </span>            :                     mLayersUpdated = false;
<span class="lineNum">    1024 </span>            :                   }
<span class="lineNum">    1025 </span>            :                   // If this is not actually the root content then the animator is not getting updated in AsyncPanZoomController::NotifyLayersUpdated
<span class="lineNum">    1026 </span>            :                   // because the root content document is not scrollable. So update it here so it knows if the root composition size has changed.
<span class="lineNum">    1027 </span>            :                   if (!metrics.IsRootContent()) {
<span class="lineNum">    1028 </span>            :                     animator-&gt;MaybeUpdateCompositionSizeAndRootFrameMetrics(metrics);
<span class="lineNum">    1029 </span>            :                   }
<span class="lineNum">    1030 </span>            :                 }
<span class="lineNum">    1031 </span>            :                 fixedLayerMargins = mFixedLayerMargins;
<span class="lineNum">    1032 </span>            :               }
<span class="lineNum">    1033 </span>            :             }
<span class="lineNum">    1034 </span>            : #else
<span class="lineNum">    1035 </span><span class="lineCov">          8 :             *aOutFoundRoot = false;</span>
<span class="lineNum">    1036 </span>            :             // Non-Android platforms still care about this flag being cleared after
<span class="lineNum">    1037 </span>            :             // the first call to TransformShadowTree().
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :             mIsFirstPaint = false;</span>
<span class="lineNum">    1039 </span>            : #endif
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span>            :             // Transform the current local clips by this APZC's async transform. If we're
<span class="lineNum">    1042 </span>            :             // using containerful scrolling, then the clip is not part of the scrolled
<span class="lineNum">    1043 </span>            :             // frame and should not be transformed.
<span class="lineNum">    1044 </span><span class="lineCov">          8 :             if (!scrollMetadata.UsesContainerScrolling()) {</span>
<span class="lineNum">    1045 </span><span class="lineCov">          8 :               MOZ_ASSERT(asyncTransform.Is2D());</span>
<span class="lineNum">    1046 </span><span class="lineCov">         16 :               if (clipParts.mFixedClip) {</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                 *clipParts.mFixedClip = TransformBy(asyncTransform, *clipParts.mFixedClip);</span>
<span class="lineNum">    1048 </span>            :               }
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :               if (clipParts.mScrolledClip) {</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                 *clipParts.mScrolledClip = TransformBy(asyncTransform, *clipParts.mScrolledClip);</span>
<span class="lineNum">    1051 </span>            :               }
<span class="lineNum">    1052 </span>            :             }
<span class="lineNum">    1053 </span>            :             // Note: we don't set the layer's shadow clip rect property yet;
<span class="lineNum">    1054 </span>            :             // AlignFixedAndStickyLayers will use the clip parts from the clip parts
<span class="lineNum">    1055 </span>            :             // cache.
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineCov">          8 :             combinedAsyncTransform *= asyncTransform;</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span>            :             // For the purpose of aligning fixed and sticky layers, we disregard
<span class="lineNum">    1060 </span>            :             // the overscroll transform as well as any OMTA transform when computing the
<span class="lineNum">    1061 </span>            :             // 'aCurrentTransformForRoot' parameter. This ensures that the overscroll
<span class="lineNum">    1062 </span>            :             // and OMTA transforms are not unapplied, and therefore that the visual
<span class="lineNum">    1063 </span>            :             // effects apply to fixed and sticky layers. We do this by using
<span class="lineNum">    1064 </span>            :             // GetTransform() as the base transform rather than GetLocalTransform(),
<span class="lineNum">    1065 </span>            :             // which would include those factors.
<span class="lineNum">    1066 </span>            :             LayerToParentLayerMatrix4x4 transformWithoutOverscrollOrOmta =
<span class="lineNum">    1067 </span><span class="lineCov">         16 :                 layer-&gt;GetTransformTyped()</span>
<span class="lineNum">    1068 </span><span class="lineCov">         16 :               * CompleteAsyncTransform(</span>
<span class="lineNum">    1069 </span><span class="lineCov">         24 :                   AdjustForClip(asyncTransformWithoutOverscroll, layer));</span>
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :             AlignFixedAndStickyLayers(layer, layer, metrics.GetScrollId(), oldTransform,
<span class="lineNum">    1072 </span>            :                                       transformWithoutOverscrollOrOmta, fixedLayerMargins,
<span class="lineNum">    1073 </span><span class="lineCov">          1 :                                       &amp;clipPartsCache);</span>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :             // Combine the local clip with the ancestor scrollframe clip. This is not
<span class="lineNum">    1076 </span>            :             // included in the async transform above, since the ancestor clip should not
<span class="lineNum">    1077 </span>            :             // move with this APZC.
<span class="lineNum">    1078 </span><span class="lineCov">          8 :             if (scrollMetadata.HasScrollClip()) {</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :               ParentLayerIntRect clip = scrollMetadata.ScrollClip().GetClipRect();</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :               if (layer-&gt;GetParent() &amp;&amp; layer-&gt;GetParent()-&gt;GetTransformIsPerspective()) {</span>
<span class="lineNum">    1081 </span>            :                 // If our parent layer has a perspective transform, we want to apply
<span class="lineNum">    1082 </span>            :                 // our scroll clip to it instead of to this layer (see bug 1168263).
<span class="lineNum">    1083 </span>            :                 // A layer with a perspective transform shouldn't have multiple
<span class="lineNum">    1084 </span>            :                 // children with FrameMetrics, nor a child with multiple FrameMetrics.
<span class="lineNum">    1085 </span>            :                 // (A child with multiple FrameMetrics would mean that there's *another*
<span class="lineNum">    1086 </span>            :                 // scrollable element between the one with the CSS perspective and the
<span class="lineNum">    1087 </span>            :                 // transformed element. But you'd have to use preserve-3d on the inner
<span class="lineNum">    1088 </span>            :                 // scrollable element in order to have the perspective apply to the
<span class="lineNum">    1089 </span>            :                 // transformed child, and preserve-3d is not supported on scrollable
<span class="lineNum">    1090 </span>            :                 // elements, so this case can't occur.)
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                 MOZ_ASSERT(!stackDeferredClips.top());</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :                 stackDeferredClips.top().emplace(clip);</span>
<span class="lineNum">    1093 </span>            :               } else {
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :                 clipParts.mScrolledClip = IntersectMaybeRects(Some(clip),</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                     clipParts.mScrolledClip);</span>
<span class="lineNum">    1096 </span>            :               }
<span class="lineNum">    1097 </span>            :             }
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :             // Do the same for the ancestor mask layers: ancestorMaskLayers contains
<span class="lineNum">    1100 </span>            :             // the ancestor mask layers for scroll frames *inside* the current scroll
<span class="lineNum">    1101 </span>            :             // frame, so these are the ones we need to shift by our async transform.
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :             for (Layer* ancestorMaskLayer : ancestorMaskLayers) {</span>
<span class="lineNum">    1103 </span>            :               SetShadowTransform(ancestorMaskLayer,
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                   ancestorMaskLayer-&gt;GetLocalTransformTyped() * asyncTransform);</span>
<span class="lineNum">    1105 </span>            :             }
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            :             // Append the ancestor mask layer for this scroll frame to ancestorMaskLayers.
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :             if (scrollMetadata.HasScrollClip()) {</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :               const LayerClip&amp; scrollClip = scrollMetadata.ScrollClip();</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :               if (scrollClip.GetMaskLayerIndex()) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :                 size_t maskLayerIndex = scrollClip.GetMaskLayerIndex().value();</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                 Layer* ancestorMaskLayer = layer-&gt;GetAncestorMaskLayerAt(maskLayerIndex);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :                 ancestorMaskLayers.AppendElement(ancestorMaskLayer);</span>
<span class="lineNum">    1114 </span>            :               }
<span class="lineNum">    1115 </span>            :             }
<span class="lineNum">    1116 </span>            :           }
<span class="lineNum">    1117 </span>            :         }
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineCov">         40 :         bool clipChanged = (hasAsyncTransform || clipDeferredFromChildren ||</span>
<span class="lineNum">    1120 </span><span class="lineCov">         40 :                             layer-&gt;GetScrolledClipRect());</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :         if (clipChanged) {</span>
<span class="lineNum">    1122 </span>            :           // Intersect the two clip parts and apply them to the layer.
<span class="lineNum">    1123 </span>            :           // During ApplyAsyncContentTransformTree on an ancestor layer,
<span class="lineNum">    1124 </span>            :           // AlignFixedAndStickyLayers may overwrite this with a new clip it
<span class="lineNum">    1125 </span>            :           // computes from the clip parts, but if that doesn't happen, this
<span class="lineNum">    1126 </span>            :           // is the layer's final clip rect.
<span class="lineNum">    1127 </span><span class="lineCov">         24 :           layer-&gt;AsHostLayer()-&gt;SetShadowClipRect(clipParts.Intersect());</span>
<span class="lineNum">    1128 </span>            :         }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineCov">         16 :         if (hasAsyncTransform) {</span>
<span class="lineNum">    1131 </span>            :           // Apply the APZ transform on top of GetLocalTransform() here (rather than
<span class="lineNum">    1132 </span>            :           // GetTransform()) in case the OMTA code in SampleAnimations already set a
<span class="lineNum">    1133 </span>            :           // shadow transform; in that case we want to apply ours on top of that one
<span class="lineNum">    1134 </span>            :           // rather than clobber it.
<span class="lineNum">    1135 </span>            :           SetShadowTransform(layer,
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :               layer-&gt;GetLocalTransformTyped()</span>
<span class="lineNum">    1137 </span><span class="lineCov">         24 :             * AdjustForClip(combinedAsyncTransform, layer));</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            :           // Do the same for the layer's own mask layer, if it has one.
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :           if (Layer* maskLayer = layer-&gt;GetMaskLayer()) {</span>
<span class="lineNum">    1141 </span>            :             SetShadowTransform(maskLayer,
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                 maskLayer-&gt;GetLocalTransformTyped() * combinedAsyncTransform);</span>
<span class="lineNum">    1143 </span>            :           }
<span class="lineNum">    1144 </span>            : 
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :           appliedTransform = true;</span>
<span class="lineNum">    1146 </span>            :         }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineCov">         16 :         ExpandRootClipRect(layer, fixedLayerMargins);</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :         if (layer-&gt;GetScrollbarData().mScrollbarLayerType == layers::ScrollbarLayerType::Thumb) {</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :           ApplyAsyncTransformToScrollbar(layer);</span>
<span class="lineNum">    1152 </span>            :         }
<span class="lineNum">    1153 </span><span class="lineCov">         24 :       });</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineCov">         16 :   return appliedTransform;</span>
<span class="lineNum">    1156 </span>            : }
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : static bool
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 : LayerIsScrollbarTarget(const LayerMetricsWrapper&amp; aTarget, Layer* aScrollbar)</span>
<span class="lineNum">    1160 </span>            : {
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :   if (!aTarget.GetApzc()) {</span>
<span class="lineNum">    1162 </span>            :     return false;
<span class="lineNum">    1163 </span>            :   }
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :   const FrameMetrics&amp; metrics = aTarget.Metrics();</span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(metrics.IsScrollable());</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   if (metrics.GetScrollId() != aScrollbar-&gt;GetScrollbarData().mTargetViewId) {</span>
<span class="lineNum">    1167 </span>            :     return false;
<span class="lineNum">    1168 </span>            :   }
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :   return !metrics.IsScrollInfoLayer();</span>
<span class="lineNum">    1170 </span>            : }
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span>            : static void
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 : ApplyAsyncTransformToScrollbarForContent(const RefPtr&lt;APZSampler&gt;&amp; aSampler,</span>
<span class="lineNum">    1174 </span>            :                                          Layer* aScrollbar,
<span class="lineNum">    1175 </span>            :                                          const LayerMetricsWrapper&amp; aContent,
<span class="lineNum">    1176 </span>            :                                          bool aScrollbarIsDescendant)
<span class="lineNum">    1177 </span>            : {
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   AsyncTransformComponentMatrix clipTransform;</span>
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aSampler);</span>
<span class="lineNum">    1181 </span>            :   LayerToParentLayerMatrix4x4 transform =
<span class="lineNum">    1182 </span>            :       aSampler-&gt;ComputeTransformForScrollThumb(
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :           aScrollbar-&gt;GetLocalTransformTyped(),</span>
<span class="lineNum">    1184 </span>            :           aContent,
<span class="lineNum">    1185 </span>            :           aScrollbar-&gt;GetScrollbarData(),
<span class="lineNum">    1186 </span>            :           aScrollbarIsDescendant,
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :           &amp;clipTransform);</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :   if (aScrollbarIsDescendant) {</span>
<span class="lineNum">    1190 </span>            :     // We also need to make a corresponding change on the clip rect of all the
<span class="lineNum">    1191 </span>            :     // layers on the ancestor chain from the scrollbar layer up to but not
<span class="lineNum">    1192 </span>            :     // including the layer with the async transform. Otherwise the scrollbar
<span class="lineNum">    1193 </span>            :     // shifts but gets clipped and so appears to flicker.
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :     for (Layer* ancestor = aScrollbar; ancestor != aContent.GetLayer(); ancestor = ancestor-&gt;GetParent()) {</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :       TransformClipRect(ancestor, clipTransform);</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span>            :   }
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   SetShadowTransform(aScrollbar, transform);</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            : static LayerMetricsWrapper
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 : FindScrolledLayerForScrollbar(Layer* aScrollbar, bool* aOutIsAncestor)</span>
<span class="lineNum">    1204 </span>            : {
<span class="lineNum">    1205 </span>            :   // First check if the scrolled layer is an ancestor of the scrollbar layer.
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :   LayerMetricsWrapper root(aScrollbar-&gt;Manager()-&gt;GetRoot());</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   LayerMetricsWrapper prevAncestor(aScrollbar);</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   LayerMetricsWrapper scrolledLayer;</span>
<span class="lineNum">    1209 </span>            : 
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :   for (LayerMetricsWrapper ancestor(aScrollbar); ancestor; ancestor = ancestor.GetParent()) {</span>
<span class="lineNum">    1211 </span>            :     // Don't walk into remote layer trees; the scrollbar will always be in
<span class="lineNum">    1212 </span>            :     // the same layer space.
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     if (ancestor.AsRefLayer()) {</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :       root = prevAncestor;</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1216 </span>            :     }
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     prevAncestor = ancestor;</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     if (LayerIsScrollbarTarget(ancestor, aScrollbar)) {</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :       *aOutIsAncestor = true;</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :       return ancestor;</span>
<span class="lineNum">    1222 </span>            :     }
<span class="lineNum">    1223 </span>            :   }
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span>            :   // Search the entire layer space of the scrollbar.
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :   ForEachNode&lt;ForwardIterator&gt;(</span>
<span class="lineNum">    1227 </span>            :       root,
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :       [&amp;root, &amp;scrolledLayer, &amp;aScrollbar](LayerMetricsWrapper aLayerMetrics)</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    1230 </span>            :         // Do not recurse into RefLayers, since our initial aSubtreeRoot is the
<span class="lineNum">    1231 </span>            :         // root (or RefLayer root) of a single layer space to search.
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         if (root != aLayerMetrics &amp;&amp; aLayerMetrics.AsRefLayer()) {</span>
<span class="lineNum">    1233 </span>            :           return TraversalFlag::Skip;
<span class="lineNum">    1234 </span>            :         }
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :         if (LayerIsScrollbarTarget(aLayerMetrics, aScrollbar)) {</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :           scrolledLayer = aLayerMetrics;</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :           return TraversalFlag::Abort;</span>
<span class="lineNum">    1238 </span>            :         }
<span class="lineNum">    1239 </span>            :         return TraversalFlag::Continue;
<span class="lineNum">    1240 </span>            :       }
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :   );</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   return scrolledLayer;</span>
<span class="lineNum">    1243 </span>            : }
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span>            : void
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 : AsyncCompositionManager::ApplyAsyncTransformToScrollbar(Layer* aLayer)</span>
<span class="lineNum">    1247 </span>            : {
<span class="lineNum">    1248 </span>            :   // If this layer corresponds to a scrollbar, then there should be a layer that
<span class="lineNum">    1249 </span>            :   // is a previous sibling or a parent that has a matching ViewID on its FrameMetrics.
<span class="lineNum">    1250 </span>            :   // That is the content that this scrollbar is for. We pick up the transient
<span class="lineNum">    1251 </span>            :   // async transform from that layer and use it to update the scrollbar position.
<span class="lineNum">    1252 </span>            :   // Note that it is possible that the content layer is no longer there; in
<span class="lineNum">    1253 </span>            :   // this case we don't need to do anything because there can't be an async
<span class="lineNum">    1254 </span>            :   // transform on the content.
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :   bool isAncestor = false;</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   const LayerMetricsWrapper&amp; scrollTarget = FindScrolledLayerForScrollbar(aLayer, &amp;isAncestor);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :   if (scrollTarget) {</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     ApplyAsyncTransformToScrollbarForContent(mCompositorBridge-&gt;GetAPZSampler(),</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :         aLayer, scrollTarget, isAncestor);</span>
<span class="lineNum">    1260 </span>            :   }
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            : void
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 : AsyncCompositionManager::GetFrameUniformity(FrameUniformityData* aOutData)</span>
<span class="lineNum">    1265 </span>            : {
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(CompositorThreadHolder::IsInCompositorThread());</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   mLayerTransformRecorder.EndTest(aOutData);</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            : bool
<span class="lineNum">    1271 </span><span class="lineCov">          8 : AsyncCompositionManager::TransformShadowTree(</span>
<span class="lineNum">    1272 </span>            :   TimeStamp aCurrentFrame,
<span class="lineNum">    1273 </span>            :   TimeDuration aVsyncRate,
<span class="lineNum">    1274 </span>            :   CompositorBridgeParentBase::TransformsToSkip aSkip)
<span class="lineNum">    1275 </span>            : {
<span class="lineNum">    1276 </span><span class="lineCov">         16 :   AUTO_PROFILER_LABEL(&quot;AsyncCompositionManager::TransformShadowTree&quot;, GRAPHICS);</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineCov">         16 :   Layer* root = mLayerManager-&gt;GetRoot();</span>
<span class="lineNum">    1279 </span><span class="lineCov">          8 :   if (!root) {</span>
<span class="lineNum">    1280 </span>            :     return false;
<span class="lineNum">    1281 </span>            :   }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span>            :   CompositorAnimationStorage* storage =
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     mCompositorBridge-&gt;GetAnimationStorage();</span>
<span class="lineNum">    1285 </span>            :   // First, compute and set the shadow transforms from OMT animations.
<span class="lineNum">    1286 </span>            :   // NB: we must sample animations *before* sampling pan/zoom
<span class="lineNum">    1287 </span>            :   // transforms.
<span class="lineNum">    1288 </span>            :   bool wantNextFrame =
<span class="lineNum">    1289 </span>            :     SampleAnimations(root,
<span class="lineNum">    1290 </span>            :                      storage,
<span class="lineNum">    1291 </span>            :                      mPreviousFrameTimeStamp,
<span class="lineNum">    1292 </span><span class="lineCov">          8 :                      aCurrentFrame);</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">          8 :   if (!wantNextFrame) {</span>
<span class="lineNum">    1295 </span>            :     // Clean up the CompositorAnimationStorage because
<span class="lineNum">    1296 </span>            :     // there are no active animations running
<span class="lineNum">    1297 </span><span class="lineCov">          8 :     storage-&gt;Clear();</span>
<span class="lineNum">    1298 </span>            :   }
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span>            :   // Advance animations to the next expected vsync timestamp, if we can
<span class="lineNum">    1301 </span>            :   // get it.
<span class="lineNum">    1302 </span><span class="lineCov">          8 :   TimeStamp nextFrame = aCurrentFrame;</span>
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineCov">         16 :   MOZ_ASSERT(aVsyncRate != TimeDuration::Forever());</span>
<span class="lineNum">    1305 </span><span class="lineCov">          8 :   if (aVsyncRate != TimeDuration::Forever()) {</span>
<span class="lineNum">    1306 </span><span class="lineCov">          8 :     nextFrame += aVsyncRate;</span>
<span class="lineNum">    1307 </span>            :   }
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1310 </span>            :   Compositor* compositor = mLayerManager-&gt;GetCompositor();
<span class="lineNum">    1311 </span>            :   if (CompositorBridgeParent* bridge = compositor-&gt;GetCompositorBridgeParent()) {
<span class="lineNum">    1312 </span>            :     AndroidDynamicToolbarAnimator* animator = bridge-&gt;GetAndroidDynamicToolbarAnimator();
<span class="lineNum">    1313 </span>            :     MOZ_ASSERT(animator);
<span class="lineNum">    1314 </span>            :     wantNextFrame |= animator-&gt;UpdateAnimation(nextFrame);
<span class="lineNum">    1315 </span>            :   }
<span class="lineNum">    1316 </span>            : #endif // defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            :   // Reset the previous time stamp if we don't already have any running
<span class="lineNum">    1319 </span>            :   // animations to avoid using the time which is far behind for newly
<span class="lineNum">    1320 </span>            :   // started animations.
<span class="lineNum">    1321 </span><span class="lineCov">          8 :   mPreviousFrameTimeStamp = wantNextFrame ? aCurrentFrame : TimeStamp();</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineCov">          8 :   if (!(aSkip &amp; CompositorBridgeParentBase::TransformsToSkip::APZ)) {</span>
<span class="lineNum">    1324 </span>            :     // FIXME/bug 775437: unify this interface with the ~native-fennec
<span class="lineNum">    1325 </span>            :     // derived code
<span class="lineNum">    1326 </span>            :     //
<span class="lineNum">    1327 </span>            :     // Attempt to apply an async content transform to any layer that has
<span class="lineNum">    1328 </span>            :     // an async pan zoom controller (which means that it is rendered
<span class="lineNum">    1329 </span>            :     // async using Gecko). If this fails, fall back to transforming the
<span class="lineNum">    1330 </span>            :     // primary scrollable layer.  &quot;Failing&quot; here means that we don't
<span class="lineNum">    1331 </span>            :     // find a frame that is async scrollable.  Note that the fallback
<span class="lineNum">    1332 </span>            :     // code also includes Fennec which is rendered async.  Fennec uses
<span class="lineNum">    1333 </span>            :     // its own platform-specific async rendering that is done partially
<span class="lineNum">    1334 </span>            :     // in Gecko and partially in Java.
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     bool foundRoot = false;</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     if (ApplyAsyncContentTransformToTree(root, &amp;foundRoot)) {</span>
<span class="lineNum">    1337 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1338 </span>            :       MOZ_ASSERT(foundRoot);
<span class="lineNum">    1339 </span>            :       if (foundRoot &amp;&amp; mFixedLayerMargins != ScreenMargin()) {
<span class="lineNum">    1340 </span>            :         MoveScrollbarForLayerMargin(root, mRootScrollableId, mFixedLayerMargins);
<span class="lineNum">    1341 </span>            :       }
<span class="lineNum">    1342 </span>            : #endif
<span class="lineNum">    1343 </span>            :     }
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            :     bool apzAnimating = false;
<span class="lineNum">    1346 </span>            :     if (RefPtr&lt;APZSampler&gt; apz = mCompositorBridge-&gt;GetAPZSampler()) {
<span class="lineNum">    1347 </span>            :       apzAnimating = apz-&gt;SampleAnimations(LayerMetricsWrapper(root), nextFrame);
<span class="lineNum">    1348 </span>            :     }
<span class="lineNum">    1349 </span>            :     wantNextFrame |= apzAnimating;
<span class="lineNum">    1350 </span>            :   }
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span>            :   HostLayer* rootComposite = root-&gt;AsHostLayer();
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span>            :   gfx::Matrix4x4 trans = rootComposite-&gt;GetShadowBaseTransform();
<span class="lineNum">    1355 </span>            :   trans *= gfx::Matrix4x4::From2D(mWorldTransform);
<span class="lineNum">    1356 </span>            :   rootComposite-&gt;SetShadowBaseTransform(trans);
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            :   if (gfxPrefs::CollectScrollTransforms()) {
<span class="lineNum">    1359 </span>            :     RecordShadowTransforms(root);
<span class="lineNum">    1360 </span>            :   }
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span>            :   return wantNextFrame;
<span class="lineNum">    1363 </span>            : }
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1366 </span>            : void
<span class="lineNum">    1367 </span>            : AsyncCompositionManager::SetFixedLayerMargins(ScreenIntCoord aTop, ScreenIntCoord aBottom)
<span class="lineNum">    1368 </span>            : {
<span class="lineNum">    1369 </span>            :   mFixedLayerMargins.top = aTop;
<span class="lineNum">    1370 </span>            :   mFixedLayerMargins.bottom = aBottom;
<span class="lineNum">    1371 </span>            : }
<span class="lineNum">    1372 </span>            : #endif // defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            : } // namespace layers
<span class="lineNum">    1375 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13-14-ga5dd952</a></td></tr>
  </table>
  <br>

</body>
</html>
