<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - /home/assiya/coverage-crawler/mozilla-central/layout/generic/nsGfxScrollFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">home/assiya/coverage-crawler/mozilla-central/layout/generic</a> - nsGfxScrollFrame.cpp<span style="font-size: 80%;"> (source / <a href="nsGfxScrollFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">581</td>
            <td class="headerCovTableEntry">2894</td>
            <td class="headerCovTableEntryLo">20.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-08-03 01:26:20</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=8 sts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : /* rendering object to wrap rendering objects that should be scrollable */
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : #include &quot;nsGfxScrollFrame.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;ActiveLayerTracker.h&quot;
<span class="lineNum">      12 </span>            : #include &quot;base/compiler_specific.h&quot;
<span class="lineNum">      13 </span>            : #include &quot;DisplayItemClip.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;nsCOMPtr.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;nsIContentViewer.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;nsPresContext.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;nsView.h&quot;
<span class="lineNum">      18 </span>            : #include &quot;nsIScrollable.h&quot;
<span class="lineNum">      19 </span>            : #include &quot;nsContainerFrame.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;nsGkAtoms.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;nsNameSpaceManager.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;nsIDocumentInlines.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;nsFontMetrics.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;nsBoxLayoutState.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/dom/NodeInfo.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;nsScrollbarFrame.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsINode.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsIScrollbarMediator.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;nsITextControlFrame.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;nsNodeInfoManager.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;nsContentCreatorFunctions.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;mozilla/PresState.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;nsIHTMLDocument.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;nsContentUtils.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;nsLayoutUtils.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;nsBidiPresUtils.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;nsBidiUtils.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;mozilla/ContentEvents.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;mozilla/EventDispatcher.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;mozilla/Preferences.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;mozilla/LookAndFeel.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;mozilla/dom/Element.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;mozilla/dom/Event.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;mozilla/dom/HTMLTextAreaElement.h&quot;
<span class="lineNum">      45 </span>            : #include &lt;stdint.h&gt;
<span class="lineNum">      46 </span>            : #include &quot;mozilla/MathAlgorithms.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;mozilla/Telemetry.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;FrameLayerBuilder.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;nsSMILKeySpline.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;nsSubDocumentFrame.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;nsSVGOuterSVGFrame.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;nsIObjectLoadingContent.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;mozilla/Attributes.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;ScrollbarActivity.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;nsRefreshDriver.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;nsThemeConstants.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;nsSVGIntegrationUtils.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;nsIScrollPositionListener.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;StickyScrollContainer.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;nsIFrameInlines.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;nsILayoutHistoryState.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;gfxPlatform.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;gfxPrefs.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;ScrollAnimationPhysics.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;ScrollAnimationBezierPhysics.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;ScrollAnimationMSDPhysics.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;ScrollSnap.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;UnitTransforms.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;nsPluginFrame.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;nsSliderFrame.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;mozilla/layers/APZCCallbackHelper.h&quot;
<span class="lineNum">      72 </span>            : #include &lt;mozilla/layers/AxisPhysicsModel.h&gt;
<span class="lineNum">      73 </span>            : #include &lt;mozilla/layers/AxisPhysicsMSDModel.h&gt;
<span class="lineNum">      74 </span>            : #include &quot;mozilla/layers/LayerTransactionChild.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;mozilla/layers/ScrollLinkedEffectDetector.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;mozilla/Unused.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;LayersLogging.h&quot;  // for Stringify
<span class="lineNum">      78 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      79 </span>            : #include &lt;cstdlib&gt; // for std::abs(int/long)
<span class="lineNum">      80 </span>            : #include &lt;cmath&gt; // for std::abs(float/double)
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : #define PAINT_SKIP_LOG(...)
<span class="lineNum">      83 </span>            : // #define PAINT_SKIP_LOG(...) printf_stderr(&quot;PSKIP: &quot; __VA_ARGS__)
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : using namespace mozilla;
<span class="lineNum">      86 </span>            : using namespace mozilla::dom;
<span class="lineNum">      87 </span>            : using namespace mozilla::gfx;
<span class="lineNum">      88 </span>            : using namespace mozilla::layers;
<span class="lineNum">      89 </span>            : using namespace mozilla::layout;
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : static uint32_t
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : GetOverflowChange(const nsRect&amp; aCurScrolledRect, const nsRect&amp; aPrevScrolledRect)</span>
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :   uint32_t result = 0;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :   if (aPrevScrolledRect.x != aCurScrolledRect.x ||</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :       aPrevScrolledRect.width != aCurScrolledRect.width) {</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :     result |= nsIScrollableFrame::HORIZONTAL;</span>
<span class="lineNum">      98 </span>            :   }
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   if (aPrevScrolledRect.y != aCurScrolledRect.y ||</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :       aPrevScrolledRect.height != aCurScrolledRect.height) {</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     result |= nsIScrollableFrame::VERTICAL;</span>
<span class="lineNum">     102 </span>            :   }
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">     104 </span>            : }
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : //----------------------------------------------------------------------
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            : //----------nsHTMLScrollFrame-------------------------------------------
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : nsHTMLScrollFrame*
<span class="lineNum">     111 </span><span class="lineNoCov">          0 : NS_NewHTMLScrollFrame(nsIPresShell* aPresShell, ComputedStyle* aStyle, bool aIsRoot)</span>
<span class="lineNum">     112 </span>            : {
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :   return new (aPresShell) nsHTMLScrollFrame(aStyle, aIsRoot);</span>
<span class="lineNum">     114 </span>            : }
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineNoCov">          0 : NS_IMPL_FRAMEARENA_HELPERS(nsHTMLScrollFrame)</span>
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::nsHTMLScrollFrame(ComputedStyle* aStyle,</span>
<span class="lineNum">     119 </span>            :                                      nsIFrame::ClassID aID,
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                                      bool aIsRoot)</span>
<span class="lineNum">     121 </span>            :   : nsContainerFrame(aStyle, aID)
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   , mHelper(ALLOW_THIS_IN_INITIALIZER_LIST(this), aIsRoot)</span>
<span class="lineNum">     123 </span>            : {
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : void
<span class="lineNum">     127 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::ScrollbarActivityStarted() const</span>
<span class="lineNum">     128 </span>            : {
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   if (mHelper.mScrollbarActivity) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     mHelper.mScrollbarActivity-&gt;ActivityStarted();</span>
<span class="lineNum">     131 </span>            :   }
<span class="lineNum">     132 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : void
<span class="lineNum">     135 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::ScrollbarActivityStopped() const</span>
<span class="lineNum">     136 </span>            : {
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   if (mHelper.mScrollbarActivity) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     mHelper.mScrollbarActivity-&gt;ActivityStopped();</span>
<span class="lineNum">     139 </span>            :   }
<span class="lineNum">     140 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : nsresult
<span class="lineNum">     143 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::CreateAnonymousContent(nsTArray&lt;ContentInfo&gt;&amp; aElements)</span>
<span class="lineNum">     144 </span>            : {
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   return mHelper.CreateAnonymousContent(aElements);</span>
<span class="lineNum">     146 </span>            : }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : void
<span class="lineNum">     149 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::AppendAnonymousContentTo(nsTArray&lt;nsIContent*&gt;&amp; aElements,</span>
<span class="lineNum">     150 </span>            :                                             uint32_t aFilter)
<span class="lineNum">     151 </span>            : {
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   mHelper.AppendAnonymousContentTo(aElements, aFilter);</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : void
<span class="lineNum">     156 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::DestroyFrom(nsIFrame* aDestructRoot, PostDestroyData&amp; aPostDestroyData)</span>
<span class="lineNum">     157 </span>            : {
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :   DestroyAbsoluteFrames(aDestructRoot, aPostDestroyData);</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :   mHelper.Destroy(aPostDestroyData);</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   nsContainerFrame::DestroyFrom(aDestructRoot, aPostDestroyData);</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : void
<span class="lineNum">     164 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::SetInitialChildList(ChildListID  aListID,</span>
<span class="lineNum">     165 </span>            :                                        nsFrameList&amp; aChildList)
<span class="lineNum">     166 </span>            : {
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   nsContainerFrame::SetInitialChildList(aListID, aChildList);</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : void
<span class="lineNum">     173 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::AppendFrames(ChildListID  aListID,</span>
<span class="lineNum">     174 </span>            :                                 nsFrameList&amp; aFrameList)
<span class="lineNum">     175 </span>            : {
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aListID == kPrincipalList, &quot;Only main list supported&quot;);</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   mFrames.AppendFrames(nullptr, aFrameList);</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : void
<span class="lineNum">     182 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::InsertFrames(ChildListID aListID,</span>
<span class="lineNum">     183 </span>            :                                 nsIFrame* aPrevFrame,
<span class="lineNum">     184 </span>            :                                 nsFrameList&amp; aFrameList)
<span class="lineNum">     185 </span>            : {
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aListID == kPrincipalList, &quot;Only main list supported&quot;);</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   NS_ASSERTION(!aPrevFrame || aPrevFrame-&gt;GetParent() == this,</span>
<span class="lineNum">     188 </span>            :                &quot;inserting after sibling frame with different parent&quot;);
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   mFrames.InsertFrames(nullptr, aPrevFrame, aFrameList);</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : void
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::RemoveFrame(ChildListID aListID,</span>
<span class="lineNum">     195 </span>            :                                nsIFrame* aOldFrame)
<span class="lineNum">     196 </span>            : {
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aListID == kPrincipalList, &quot;Only main list supported&quot;);</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :   mFrames.DestroyFrame(aOldFrame);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : nsSplittableType
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::GetSplittableType() const</span>
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :   return NS_FRAME_NOT_SPLITTABLE;</span>
<span class="lineNum">     206 </span>            : }
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /**
<span class="lineNum">     209 </span>            :  HTML scrolling implementation
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :  All other things being equal, we prefer layouts with fewer scrollbars showing.
<span class="lineNum">     212 </span>            : */
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : namespace mozilla {
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : struct MOZ_STACK_CLASS ScrollReflowInput {</span>
<span class="lineNum">     217 </span>            :   const ReflowInput&amp; mReflowInput;
<span class="lineNum">     218 </span>            :   nsBoxLayoutState mBoxState;
<span class="lineNum">     219 </span>            :   ScrollbarStyles mStyles;
<span class="lineNum">     220 </span>            :   nsMargin mComputedBorder;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :   // === Filled in by ReflowScrolledFrame ===
<span class="lineNum">     223 </span>            :   nsOverflowAreas mContentsOverflowAreas;
<span class="lineNum">     224 </span>            :   MOZ_INIT_OUTSIDE_CTOR
<span class="lineNum">     225 </span>            :   bool mReflowedContentsWithHScrollbar;
<span class="lineNum">     226 </span>            :   MOZ_INIT_OUTSIDE_CTOR
<span class="lineNum">     227 </span>            :   bool mReflowedContentsWithVScrollbar;
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   // === Filled in when TryLayout succeeds ===
<span class="lineNum">     230 </span>            :   // The size of the inside-border area
<span class="lineNum">     231 </span>            :   nsSize mInsideBorderSize;
<span class="lineNum">     232 </span>            :   // Whether we decided to show the horizontal scrollbar
<span class="lineNum">     233 </span>            :   MOZ_INIT_OUTSIDE_CTOR
<span class="lineNum">     234 </span>            :   bool mShowHScrollbar;
<span class="lineNum">     235 </span>            :   // Whether we decided to show the vertical scrollbar
<span class="lineNum">     236 </span>            :   MOZ_INIT_OUTSIDE_CTOR
<span class="lineNum">     237 </span>            :   bool mShowVScrollbar;
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   ScrollReflowInput(nsIScrollableFrame* aFrame,</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                     const ReflowInput&amp; aReflowInput) :</span>
<span class="lineNum">     241 </span>            :     mReflowInput(aReflowInput),
<span class="lineNum">     242 </span>            :     // mBoxState is just used for scrollbars so we don't need to
<span class="lineNum">     243 </span>            :     // worry about the reflow depth here
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :     mBoxState(aReflowInput.mFrame-&gt;PresContext(), aReflowInput.mRenderingContext, 0),</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     mStyles(aFrame-&gt;GetScrollbarStyles()) {</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     247 </span>            : };
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : } // namespace mozilla
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : // XXXldb Can this go away?
<span class="lineNum">     252 </span><span class="lineNoCov">          0 : static nsSize ComputeInsideBorderSize(ScrollReflowInput* aState,</span>
<span class="lineNum">     253 </span>            :                                       const nsSize&amp; aDesiredInsideBorderSize)
<span class="lineNum">     254 </span>            : {
<span class="lineNum">     255 </span>            :   // aDesiredInsideBorderSize is the frame size; i.e., it includes
<span class="lineNum">     256 </span>            :   // borders and padding (but the scrolled child doesn't have
<span class="lineNum">     257 </span>            :   // borders). The scrolled child has the same padding as us.
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :   nscoord contentWidth = aState-&gt;mReflowInput.ComputedWidth();</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :   if (contentWidth == NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :     contentWidth = aDesiredInsideBorderSize.width -</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :       aState-&gt;mReflowInput.ComputedPhysicalPadding().LeftRight();</span>
<span class="lineNum">     262 </span>            :   }
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   nscoord contentHeight = aState-&gt;mReflowInput.ComputedHeight();</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   if (contentHeight == NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :     contentHeight = aDesiredInsideBorderSize.height -</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :       aState-&gt;mReflowInput.ComputedPhysicalPadding().TopBottom();</span>
<span class="lineNum">     267 </span>            :   }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :   contentWidth  = aState-&gt;mReflowInput.ApplyMinMaxWidth(contentWidth);</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :   contentHeight = aState-&gt;mReflowInput.ApplyMinMaxHeight(contentHeight);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   return nsSize(contentWidth + aState-&gt;mReflowInput.ComputedPhysicalPadding().LeftRight(),</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                 contentHeight + aState-&gt;mReflowInput.ComputedPhysicalPadding().TopBottom());</span>
<span class="lineNum">     273 </span>            : }
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : static void
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : GetScrollbarMetrics(nsBoxLayoutState&amp; aState, nsIFrame* aBox, nsSize* aMin,</span>
<span class="lineNum">     277 </span>            :                     nsSize* aPref, bool aVertical)
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aState.GetRenderingContext(),</span>
<span class="lineNum">     280 </span>            :                &quot;Must have rendering context in layout state for size &quot;
<span class="lineNum">     281 </span>            :                &quot;computations&quot;);
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   if (aMin) {</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :     *aMin = aBox-&gt;GetXULMinSize(aState);</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     nsBox::AddMargin(aBox, *aMin);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     if (aMin-&gt;width &lt; 0) {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       aMin-&gt;width = 0;</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :     if (aMin-&gt;height &lt; 0) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       aMin-&gt;height = 0;</span>
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            :   }
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   if (aPref) {</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     *aPref = aBox-&gt;GetXULPrefSize(aState);</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :     nsBox::AddMargin(aBox, *aPref);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :     if (aPref-&gt;width &lt; 0) {</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :       aPref-&gt;width = 0;</span>
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     if (aPref-&gt;height &lt; 0) {</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :       aPref-&gt;height = 0;</span>
<span class="lineNum">     302 </span>            :     }
<span class="lineNum">     303 </span>            :   }
<span class="lineNum">     304 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : /**
<span class="lineNum">     307 </span>            :  * Assuming that we know the metrics for our wrapped frame and
<span class="lineNum">     308 </span>            :  * whether the horizontal and/or vertical scrollbars are present,
<span class="lineNum">     309 </span>            :  * compute the resulting layout and return true if the layout is
<span class="lineNum">     310 </span>            :  * consistent. If the layout is consistent then we fill in the
<span class="lineNum">     311 </span>            :  * computed fields of the ScrollReflowInput.
<span class="lineNum">     312 </span>            :  *
<span class="lineNum">     313 </span>            :  * The layout is consistent when both scrollbars are showing if and only
<span class="lineNum">     314 </span>            :  * if they should be showing. A horizontal scrollbar should be showing if all
<span class="lineNum">     315 </span>            :  * following conditions are met:
<span class="lineNum">     316 </span>            :  * 1) the style is not HIDDEN
<span class="lineNum">     317 </span>            :  * 2) our inside-border height is at least the scrollbar height (i.e., the
<span class="lineNum">     318 </span>            :  * scrollbar fits vertically)
<span class="lineNum">     319 </span>            :  * 3) our scrollport width (the inside-border width minus the width allocated for a
<span class="lineNum">     320 </span>            :  * vertical scrollbar, if showing) is at least the scrollbar's min-width
<span class="lineNum">     321 </span>            :  * (i.e., the scrollbar fits horizontally)
<span class="lineNum">     322 </span>            :  * 4) the style is SCROLL, or the kid's overflow-area XMost is
<span class="lineNum">     323 </span>            :  * greater than the scrollport width
<span class="lineNum">     324 </span>            :  *
<span class="lineNum">     325 </span>            :  * @param aForce if true, then we just assume the layout is consistent.
<span class="lineNum">     326 </span>            :  */
<span class="lineNum">     327 </span>            : bool
<span class="lineNum">     328 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::TryLayout(ScrollReflowInput* aState,</span>
<span class="lineNum">     329 </span>            :                              ReflowOutput* aKidMetrics,
<span class="lineNum">     330 </span>            :                              bool aAssumeHScroll, bool aAssumeVScroll,
<span class="lineNum">     331 </span>            :                              bool aForce)
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   if ((aState-&gt;mStyles.mVertical == NS_STYLE_OVERFLOW_HIDDEN &amp;&amp; aAssumeVScroll) ||</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :       (aState-&gt;mStyles.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN &amp;&amp; aAssumeHScroll)) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     NS_ASSERTION(!aForce, &quot;Shouldn't be forcing a hidden scrollbar to show!&quot;);</span>
<span class="lineNum">     336 </span>            :     return false;
<span class="lineNum">     337 </span>            :   }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   if (aAssumeVScroll != aState-&gt;mReflowedContentsWithVScrollbar ||</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       (aAssumeHScroll != aState-&gt;mReflowedContentsWithHScrollbar &amp;&amp;</span>
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :        ScrolledContentDependsOnHeight(aState))) {</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :     if (aAssumeHScroll != aState-&gt;mReflowedContentsWithHScrollbar) {</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       nsLayoutUtils::MarkIntrinsicISizesDirtyIfDependentOnBSize(</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :           mHelper.mScrolledFrame);</span>
<span class="lineNum">     345 </span>            :     }
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     aKidMetrics-&gt;mOverflowAreas.Clear();</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :     ReflowScrolledFrame(aState, aAssumeHScroll, aAssumeVScroll, aKidMetrics,</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                         false);</span>
<span class="lineNum">     349 </span>            :   }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   nsSize vScrollbarMinSize(0, 0);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   nsSize vScrollbarPrefSize(0, 0);</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :   if (mHelper.mVScrollbarBox) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :     GetScrollbarMetrics(aState-&gt;mBoxState, mHelper.mVScrollbarBox,</span>
<span class="lineNum">     355 </span>            :                         &amp;vScrollbarMinSize,
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                         aAssumeVScroll ? &amp;vScrollbarPrefSize : nullptr, true);</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     nsScrollbarFrame* scrollbar = do_QueryFrame(mHelper.mVScrollbarBox);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :     scrollbar-&gt;SetScrollbarMediatorContent(mContent);</span>
<span class="lineNum">     359 </span>            :   }
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :   nscoord vScrollbarDesiredWidth = aAssumeVScroll ? vScrollbarPrefSize.width : 0;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   nscoord vScrollbarMinHeight = aAssumeVScroll ? vScrollbarMinSize.height : 0;</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   nsSize hScrollbarMinSize(0, 0);</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   nsSize hScrollbarPrefSize(0, 0);</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (mHelper.mHScrollbarBox) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     GetScrollbarMetrics(aState-&gt;mBoxState, mHelper.mHScrollbarBox,</span>
<span class="lineNum">     367 </span>            :                         &amp;hScrollbarMinSize,
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                         aAssumeHScroll ? &amp;hScrollbarPrefSize : nullptr, false);</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :     nsScrollbarFrame* scrollbar = do_QueryFrame(mHelper.mHScrollbarBox);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :     scrollbar-&gt;SetScrollbarMediatorContent(mContent);</span>
<span class="lineNum">     371 </span>            :   }
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   nscoord hScrollbarDesiredHeight = aAssumeHScroll ? hScrollbarPrefSize.height : 0;</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   nscoord hScrollbarMinWidth = aAssumeHScroll ? hScrollbarMinSize.width : 0;</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :   // First, compute our inside-border size and scrollport size
<span class="lineNum">     376 </span>            :   // XXXldb Can we depend more on ComputeSize here?
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   nsSize desiredInsideBorderSize;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :   desiredInsideBorderSize.width = vScrollbarDesiredWidth +</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     std::max(aKidMetrics-&gt;Width(), hScrollbarMinWidth);</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :   desiredInsideBorderSize.height = hScrollbarDesiredHeight +</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     std::max(aKidMetrics-&gt;Height(), vScrollbarMinHeight);</span>
<span class="lineNum">     382 </span>            :   aState-&gt;mInsideBorderSize =
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     ComputeInsideBorderSize(aState, desiredInsideBorderSize);</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :   nsSize scrollPortSize = nsSize(std::max(0, aState-&gt;mInsideBorderSize.width - vScrollbarDesiredWidth),</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                                  std::max(0, aState-&gt;mInsideBorderSize.height - hScrollbarDesiredHeight));</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   nsSize visualScrollPortSize = scrollPortSize;</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   nsIPresShell* presShell = PresShell();</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   if (mHelper.mIsRoot &amp;&amp; presShell-&gt;IsScrollPositionClampingScrollPortSizeSet()) {</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     nsSize compositionSize = nsLayoutUtils::CalculateCompositionSizeForFrame(this, false);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     float resolution = presShell-&gt;GetResolution();</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     compositionSize.width /= resolution;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     compositionSize.height /= resolution;</span>
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     visualScrollPortSize = nsSize(std::max(0, compositionSize.width - vScrollbarDesiredWidth),</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                                   std::max(0, compositionSize.height - hScrollbarDesiredHeight));</span>
<span class="lineNum">     396 </span>            :   }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :   nsRect scrolledRect =
<span class="lineNum">     399 </span><span class="lineCov">         84 :     mHelper.GetUnsnappedScrolledRectInternal(aState-&gt;mContentsOverflowAreas.ScrollableOverflow(),</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                                              scrollPortSize);</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :   nscoord oneDevPixel = aState-&gt;mBoxState.PresContext()-&gt;DevPixelsToAppUnits(1);</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineCov">         42 :   if (!aForce) {</span>
<span class="lineNum">     404 </span>            :     // If the style is HIDDEN then we already know that aAssumeHScroll is false
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :     if (aState-&gt;mStyles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN) {</span>
<span class="lineNum">     406 </span>            :       bool wantHScrollbar =
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :         aState-&gt;mStyles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL ||</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         scrolledRect.XMost() &gt;= visualScrollPortSize.width + oneDevPixel ||</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         scrolledRect.x &lt;= -oneDevPixel;</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       if (scrollPortSize.width &lt; hScrollbarMinSize.width)</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :         wantHScrollbar = false;</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       if (wantHScrollbar != aAssumeHScroll)</span>
<span class="lineNum">     413 </span>            :         return false;
<span class="lineNum">     414 </span>            :     }
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :     // If the style is HIDDEN then we already know that aAssumeVScroll is false
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :     if (aState-&gt;mStyles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) {</span>
<span class="lineNum">     418 </span>            :       bool wantVScrollbar =
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         aState-&gt;mStyles.mVertical == NS_STYLE_OVERFLOW_SCROLL ||</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         scrolledRect.YMost() &gt;= visualScrollPortSize.height + oneDevPixel ||</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         scrolledRect.y &lt;= -oneDevPixel;</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       if (scrollPortSize.height &lt; vScrollbarMinSize.height)</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         wantVScrollbar = false;</span>
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :       if (wantVScrollbar != aAssumeVScroll)</span>
<span class="lineNum">     425 </span>            :         return false;
<span class="lineNum">     426 </span>            :     }
<span class="lineNum">     427 </span>            :   }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :   do {
<span class="lineNum">     430 </span><span class="lineCov">         42 :     if (!mHelper.mIsRoot) {</span>
<span class="lineNum">     431 </span>            :       break;
<span class="lineNum">     432 </span>            :     }
<span class="lineNum">     433 </span>            :     // Check whether there is actually any overflow.
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :     nscoord scrolledWidth = scrolledRect.width + oneDevPixel;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :     if (scrolledWidth &lt;= scrollPortSize.width) {</span>
<span class="lineNum">     436 </span>            :       break;
<span class="lineNum">     437 </span>            :     }
<span class="lineNum">     438 </span>            :     // Viewport scrollbar style is used below instead of aState-&gt;mStyles
<span class="lineNum">     439 </span>            :     // because the latter can be affected by various factors, while we
<span class="lineNum">     440 </span>            :     // only care about what the page itself specifies.
<span class="lineNum">     441 </span><span class="lineCov">         64 :     nsPresContext* pc = PresContext();</span>
<span class="lineNum">     442 </span><span class="lineCov">         32 :     ScrollbarStyles styles = pc-&gt;GetViewportScrollbarStylesOverride();</span>
<span class="lineNum">     443 </span><span class="lineCov">         32 :     if (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN) {</span>
<span class="lineNum">     444 </span>            :       break;
<span class="lineNum">     445 </span>            :     }
<span class="lineNum">     446 </span>            :     // Only top level content document is considered.
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :     nsIDocument* doc = pc-&gt;Document();</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :     if (!doc-&gt;IsTopLevelContentDocument()) {</span>
<span class="lineNum">     449 </span>            :       break;
<span class="lineNum">     450 </span>            :     }
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :     doc-&gt;UpdateViewportOverflowType(scrolledWidth, scrollPortSize.width);</span>
<span class="lineNum">     452 </span>            :   } while (false);
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   nscoord vScrollbarActualWidth = aState-&gt;mInsideBorderSize.width - scrollPortSize.width;</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineCov">         42 :   aState-&gt;mShowHScrollbar = aAssumeHScroll;</span>
<span class="lineNum">     457 </span><span class="lineCov">         42 :   aState-&gt;mShowVScrollbar = aAssumeVScroll;</span>
<span class="lineNum">     458 </span>            :   nsPoint scrollPortOrigin(aState-&gt;mComputedBorder.left,
<span class="lineNum">     459 </span><span class="lineCov">         84 :                            aState-&gt;mComputedBorder.top);</span>
<span class="lineNum">     460 </span><span class="lineCov">         42 :   if (!IsScrollbarOnRight()) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :     scrollPortOrigin.x += vScrollbarActualWidth;</span>
<span class="lineNum">     462 </span>            :   }
<span class="lineNum">     463 </span><span class="lineCov">         42 :   mHelper.mScrollPort = nsRect(scrollPortOrigin, scrollPortSize);</span>
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     465 </span>            : }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : // XXX Height/BSize mismatch needs to be addressed here; check the caller!
<span class="lineNum">     468 </span>            : // Currently this will only behave as expected for horizontal writing modes.
<span class="lineNum">     469 </span>            : // (See bug 1175509.)
<span class="lineNum">     470 </span>            : bool
<span class="lineNum">     471 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::ScrolledContentDependsOnHeight(ScrollReflowInput* aState)</span>
<span class="lineNum">     472 </span>            : {
<span class="lineNum">     473 </span>            :   // Return true if ReflowScrolledFrame is going to do something different
<span class="lineNum">     474 </span>            :   // based on the presence of a horizontal scrollbar.
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   return mHelper.mScrolledFrame-&gt;HasAnyStateBits(</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       NS_FRAME_CONTAINS_RELATIVE_BSIZE | NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE) ||</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     aState-&gt;mReflowInput.ComputedBSize() != NS_UNCONSTRAINEDSIZE ||</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     aState-&gt;mReflowInput.ComputedMinBSize() &gt; 0 ||</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     aState-&gt;mReflowInput.ComputedMaxBSize() != NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">     480 </span>            : }
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : void
<span class="lineNum">     483 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::ReflowScrolledFrame(ScrollReflowInput* aState,</span>
<span class="lineNum">     484 </span>            :                                        bool aAssumeHScroll,
<span class="lineNum">     485 </span>            :                                        bool aAssumeVScroll,
<span class="lineNum">     486 </span>            :                                        ReflowOutput* aMetrics,
<span class="lineNum">     487 </span>            :                                        bool aFirstPass)
<span class="lineNum">     488 </span>            : {
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :   WritingMode wm = mHelper.mScrolledFrame-&gt;GetWritingMode();</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            :   // these could be NS_UNCONSTRAINEDSIZE ... std::min arithmetic should
<span class="lineNum">     492 </span>            :   // be OK
<span class="lineNum">     493 </span><span class="lineCov">         94 :   LogicalMargin padding = aState-&gt;mReflowInput.ComputedLogicalPadding();</span>
<span class="lineNum">     494 </span>            :   nscoord availISize =
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :     aState-&gt;mReflowInput.ComputedISize() + padding.IStartEnd(wm);</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   nscoord computedBSize = aState-&gt;mReflowInput.ComputedBSize();</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :   nscoord computedMinBSize = aState-&gt;mReflowInput.ComputedMinBSize();</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :   nscoord computedMaxBSize = aState-&gt;mReflowInput.ComputedMaxBSize();</span>
<span class="lineNum">     500 </span><span class="lineCov">         47 :   if (!ShouldPropagateComputedBSizeToScrolledContent()) {</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     computedBSize = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :     computedMinBSize = 0;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     computedMaxBSize = NS_UNCONSTRAINEDSIZE;</span>
<span class="lineNum">     504 </span>            :   }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :   if (wm.IsVertical()) {</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :     if (aAssumeVScroll) {</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :       nsSize vScrollbarPrefSize;</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       GetScrollbarMetrics(aState-&gt;mBoxState, mHelper.mVScrollbarBox,</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :                           nullptr, &amp;vScrollbarPrefSize, false);</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :       if (computedBSize != NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         computedBSize = std::max(0, computedBSize - vScrollbarPrefSize.width);</span>
<span class="lineNum">     513 </span>            :       }
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :       computedMinBSize = std::max(0, computedMinBSize - vScrollbarPrefSize.width);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :       if (computedMaxBSize != NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         computedMaxBSize = std::max(0, computedMaxBSize - vScrollbarPrefSize.width);</span>
<span class="lineNum">     517 </span>            :       }
<span class="lineNum">     518 </span>            :     }
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     if (aAssumeHScroll) {</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :       nsSize hScrollbarPrefSize;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :       GetScrollbarMetrics(aState-&gt;mBoxState, mHelper.mHScrollbarBox,</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :                           nullptr, &amp;hScrollbarPrefSize, true);</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       availISize = std::max(0, availISize - hScrollbarPrefSize.height);</span>
<span class="lineNum">     525 </span>            :     }
<span class="lineNum">     526 </span>            :   } else {
<span class="lineNum">     527 </span><span class="lineCov">         47 :     if (aAssumeHScroll) {</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :       nsSize hScrollbarPrefSize;</span>
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       GetScrollbarMetrics(aState-&gt;mBoxState, mHelper.mHScrollbarBox,</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :                           nullptr, &amp;hScrollbarPrefSize, false);</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :       if (computedBSize != NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         computedBSize = std::max(0, computedBSize - hScrollbarPrefSize.height);</span>
<span class="lineNum">     533 </span>            :       }
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :       computedMinBSize = std::max(0, computedMinBSize - hScrollbarPrefSize.height);</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       if (computedMaxBSize != NS_UNCONSTRAINEDSIZE) {</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :         computedMaxBSize = std::max(0, computedMaxBSize - hScrollbarPrefSize.height);</span>
<span class="lineNum">     537 </span>            :       }
<span class="lineNum">     538 </span>            :     }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span><span class="lineCov">         47 :     if (aAssumeVScroll) {</span>
<span class="lineNum">     541 </span><span class="lineCov">          5 :       nsSize vScrollbarPrefSize;</span>
<span class="lineNum">     542 </span><span class="lineCov">          5 :       GetScrollbarMetrics(aState-&gt;mBoxState, mHelper.mVScrollbarBox,</span>
<span class="lineNum">     543 </span><span class="lineCov">          5 :                           nullptr, &amp;vScrollbarPrefSize, true);</span>
<span class="lineNum">     544 </span><span class="lineCov">         10 :       availISize = std::max(0, availISize - vScrollbarPrefSize.width);</span>
<span class="lineNum">     545 </span>            :     }
<span class="lineNum">     546 </span>            :   }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = PresContext();</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :   // Pass false for aInit so we can pass in the correct padding.
<span class="lineNum">     551 </span>            :   ReflowInput
<span class="lineNum">     552 </span>            :     kidReflowInput(presContext, aState-&gt;mReflowInput,
<span class="lineNum">     553 </span>            :                    mHelper.mScrolledFrame,
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :                    LogicalSize(wm, availISize, NS_UNCONSTRAINEDSIZE),</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :                    nullptr, ReflowInput::CALLER_WILL_INIT);</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   const nsMargin physicalPadding = padding.GetPhysicalMargin(wm);</span>
<span class="lineNum">     557 </span>            :   kidReflowInput.Init(presContext, nullptr, nullptr,
<span class="lineNum">     558 </span><span class="lineCov">         47 :                       &amp;physicalPadding);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :   kidReflowInput.mFlags.mAssumingHScrollbar = aAssumeHScroll;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   kidReflowInput.mFlags.mAssumingVScrollbar = aAssumeVScroll;</span>
<span class="lineNum">     561 </span><span class="lineCov">         47 :   kidReflowInput.SetComputedBSize(computedBSize);</span>
<span class="lineNum">     562 </span><span class="lineCov">         47 :   kidReflowInput.ComputedMinBSize() = computedMinBSize;</span>
<span class="lineNum">     563 </span><span class="lineCov">         47 :   kidReflowInput.ComputedMaxBSize() = computedMaxBSize;</span>
<span class="lineNum">     564 </span><span class="lineCov">         47 :   if (aState-&gt;mReflowInput.IsBResizeForWM(kidReflowInput.GetWritingMode())) {</span>
<span class="lineNum">     565 </span>            :     kidReflowInput.SetBResize(true);
<span class="lineNum">     566 </span>            :   }
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :   // Temporarily set mHasHorizontalScrollbar/mHasVerticalScrollbar to
<span class="lineNum">     569 </span>            :   // reflect our assumptions while we reflow the child.
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :   bool didHaveHorizontalScrollbar = mHelper.mHasHorizontalScrollbar;</span>
<span class="lineNum">     571 </span><span class="lineCov">         47 :   bool didHaveVerticalScrollbar = mHelper.mHasVerticalScrollbar;</span>
<span class="lineNum">     572 </span><span class="lineCov">         47 :   mHelper.mHasHorizontalScrollbar = aAssumeHScroll;</span>
<span class="lineNum">     573 </span><span class="lineCov">         47 :   mHelper.mHasVerticalScrollbar = aAssumeVScroll;</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineCov">         47 :   nsReflowStatus status;</span>
<span class="lineNum">     576 </span>            :   // No need to pass a true container-size to ReflowChild or
<span class="lineNum">     577 </span>            :   // FinishReflowChild, because it's only used there when positioning
<span class="lineNum">     578 </span>            :   // the frame (i.e. if NS_FRAME_NO_MOVE_FRAME isn't set)
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :   const nsSize dummyContainerSize;</span>
<span class="lineNum">     580 </span><span class="lineCov">         47 :   ReflowChild(mHelper.mScrolledFrame, presContext, *aMetrics,</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :               kidReflowInput, wm, LogicalPoint(wm), dummyContainerSize,</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :               NS_FRAME_NO_MOVE_FRAME, status);</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov">         47 :   mHelper.mHasHorizontalScrollbar = didHaveHorizontalScrollbar;</span>
<span class="lineNum">     585 </span><span class="lineCov">         47 :   mHelper.mHasVerticalScrollbar = didHaveVerticalScrollbar;</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   // Don't resize or position the view (if any) because we're going to resize
<span class="lineNum">     588 </span>            :   // it to the correct size anyway in PlaceScrollArea. Allowing it to
<span class="lineNum">     589 </span>            :   // resize here would size it to the natural height of the frame,
<span class="lineNum">     590 </span>            :   // which will usually be different from the scrollport height;
<span class="lineNum">     591 </span>            :   // invalidating the difference will cause unnecessary repainting.
<span class="lineNum">     592 </span><span class="lineCov">         47 :   FinishReflowChild(mHelper.mScrolledFrame, presContext,</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :                     *aMetrics, &amp;kidReflowInput, wm, LogicalPoint(wm),</span>
<span class="lineNum">     594 </span>            :                     dummyContainerSize,
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :                     NS_FRAME_NO_MOVE_FRAME | NS_FRAME_NO_SIZE_VIEW);</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :   // XXX Some frames (e.g., nsPluginFrame, nsFrameFrame, nsTextFrame) don't bother
<span class="lineNum">     598 </span>            :   // setting their mOverflowArea. This is wrong because every frame should
<span class="lineNum">     599 </span>            :   // always set mOverflowArea. In fact nsPluginFrame and nsFrameFrame don't
<span class="lineNum">     600 </span>            :   // support the 'outline' property because of this. Rather than fix the world
<span class="lineNum">     601 </span>            :   // right now, just fix up the overflow area if necessary. Note that we don't
<span class="lineNum">     602 </span>            :   // check HasOverflowRect() because it could be set even though the
<span class="lineNum">     603 </span>            :   // overflow area doesn't include the frame bounds.
<span class="lineNum">     604 </span><span class="lineCov">         47 :   aMetrics-&gt;UnionOverflowAreasWithDesiredBounds();</span>
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   auto* disp = StyleDisplay();</span>
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :   if (MOZ_UNLIKELY(disp-&gt;mOverflowClipBoxBlock ==</span>
<span class="lineNum">     608 </span>            :                      NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX ||
<span class="lineNum">     609 </span>            :                    disp-&gt;mOverflowClipBoxInline ==
<span class="lineNum">     610 </span>            :                      NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX)) {
<span class="lineNum">     611 </span><span class="lineCov">         12 :     nsOverflowAreas childOverflow;</span>
<span class="lineNum">     612 </span><span class="lineCov">          1 :     nsLayoutUtils::UnionChildOverflow(mHelper.mScrolledFrame, childOverflow);</span>
<span class="lineNum">     613 </span><span class="lineCov">         12 :     nsRect childScrollableOverflow = childOverflow.ScrollableOverflow();</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     if (disp-&gt;mOverflowClipBoxBlock == NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX) {</span>
<span class="lineNum">     615 </span><span class="lineCov">          6 :       padding.BStart(wm) = nscoord(0);</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :       padding.BEnd(wm) = nscoord(0);</span>
<span class="lineNum">     617 </span>            :     }
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     if (disp-&gt;mOverflowClipBoxInline == NS_STYLE_OVERFLOW_CLIP_BOX_PADDING_BOX) {</span>
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       padding.IStart(wm) = nscoord(0);</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :       padding.IEnd(wm) = nscoord(0);</span>
<span class="lineNum">     621 </span>            :     }
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     childScrollableOverflow.Inflate(padding.GetPhysicalMargin(wm));</span>
<span class="lineNum">     623 </span>            :     nsRect contentArea =
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       wm.IsVertical() ? nsRect(0, 0, computedBSize, availISize)</span>
<span class="lineNum">     625 </span><span class="lineCov">         12 :                       : nsRect(0, 0, availISize, computedBSize);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     if (!contentArea.Contains(childScrollableOverflow)) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       aMetrics-&gt;mOverflowAreas.ScrollableOverflow() = childScrollableOverflow;</span>
<span class="lineNum">     628 </span>            :     }
<span class="lineNum">     629 </span>            :   }
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :   aState-&gt;mContentsOverflowAreas = aMetrics-&gt;mOverflowAreas;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   aState-&gt;mReflowedContentsWithHScrollbar = aAssumeHScroll;</span>
<span class="lineNum">     633 </span><span class="lineCov">         47 :   aState-&gt;mReflowedContentsWithVScrollbar = aAssumeVScroll;</span>
<span class="lineNum">     634 </span><span class="lineCov">         47 : }</span>
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : bool
<span class="lineNum">     637 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::GuessHScrollbarNeeded(const ScrollReflowInput&amp; aState)</span>
<span class="lineNum">     638 </span>            : {
<span class="lineNum">     639 </span><span class="lineCov">         42 :   if (aState.mStyles.mHorizontal != NS_STYLE_OVERFLOW_AUTO)</span>
<span class="lineNum">     640 </span>            :     // no guessing required
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     return aState.mStyles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL;</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :   return mHelper.mHasHorizontalScrollbar;</span>
<span class="lineNum">     644 </span>            : }
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : bool
<span class="lineNum">     647 </span><span class="lineCov">         42 : nsHTMLScrollFrame::GuessVScrollbarNeeded(const ScrollReflowInput&amp; aState)</span>
<span class="lineNum">     648 </span>            : {
<span class="lineNum">     649 </span><span class="lineCov">         42 :   if (aState.mStyles.mVertical != NS_STYLE_OVERFLOW_AUTO)</span>
<span class="lineNum">     650 </span>            :     // no guessing required
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :     return aState.mStyles.mVertical == NS_STYLE_OVERFLOW_SCROLL;</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :   // If we've had at least one non-initial reflow, then just assume
<span class="lineNum">     654 </span>            :   // the state of the vertical scrollbar will be what we determined
<span class="lineNum">     655 </span>            :   // last time.
<span class="lineNum">     656 </span><span class="lineCov">          8 :   if (mHelper.mHadNonInitialReflow) {</span>
<span class="lineNum">     657 </span><span class="lineCov">          3 :     return mHelper.mHasVerticalScrollbar;</span>
<span class="lineNum">     658 </span>            :   }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :   // If this is the initial reflow, guess false because usually
<span class="lineNum">     661 </span>            :   // we have very little content by then.
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :   if (InInitialReflow())</span>
<span class="lineNum">     663 </span>            :     return false;
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">          5 :   if (mHelper.mIsRoot) {</span>
<span class="lineNum">     666 </span><span class="lineCov">          5 :     nsIFrame *f = mHelper.mScrolledFrame-&gt;PrincipalChildList().FirstChild();</span>
<span class="lineNum">     667 </span><span class="lineCov">          5 :     if (f &amp;&amp; f-&gt;IsSVGOuterSVGFrame() &amp;&amp;</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :         static_cast&lt;nsSVGOuterSVGFrame*&gt;(f)-&gt;VerticalScrollbarNotNeeded()) {</span>
<span class="lineNum">     669 </span>            :       // Common SVG case - avoid a bad guess.
<span class="lineNum">     670 </span>            :       return false;
<span class="lineNum">     671 </span>            :     }
<span class="lineNum">     672 </span>            :     // Assume that there will be a scrollbar; it seems to me
<span class="lineNum">     673 </span>            :     // that 'most pages' do have a scrollbar, and anyway, it's cheaper
<span class="lineNum">     674 </span>            :     // to do an extra reflow for the pages that *don't* need a
<span class="lineNum">     675 </span>            :     // scrollbar (because on average they will have less content).
<span class="lineNum">     676 </span><span class="lineCov">          5 :     return true;</span>
<span class="lineNum">     677 </span>            :   }
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            :   // For non-viewports, just guess that we don't need a scrollbar.
<span class="lineNum">     680 </span>            :   // XXX I wonder if statistically this is the right idea; I'm
<span class="lineNum">     681 </span>            :   // basically guessing that there are a lot of overflow:auto DIVs
<span class="lineNum">     682 </span>            :   // that get their intrinsic size and don't overflow
<span class="lineNum">     683 </span>            :   return false;
<span class="lineNum">     684 </span>            : }
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : bool
<span class="lineNum">     687 </span><span class="lineCov">         47 : nsHTMLScrollFrame::InInitialReflow() const</span>
<span class="lineNum">     688 </span>            : {
<span class="lineNum">     689 </span>            :   // We're in an initial reflow if NS_FRAME_FIRST_REFLOW is set, unless we're a
<span class="lineNum">     690 </span>            :   // root scrollframe.  In that case we want to skip this clause altogether.
<span class="lineNum">     691 </span>            :   // The guess here is that there are lots of overflow:auto divs out there that
<span class="lineNum">     692 </span>            :   // end up auto-sizing so they don't overflow, and that the root basically
<span class="lineNum">     693 </span>            :   // always needs a scrollbar if it did last time we loaded this page (good
<span class="lineNum">     694 </span>            :   // assumption, because our initial reflow is no longer synchronous).
<span class="lineNum">     695 </span><span class="lineCov">         57 :   return !mHelper.mIsRoot &amp;&amp; (GetStateBits() &amp; NS_FRAME_FIRST_REFLOW);</span>
<span class="lineNum">     696 </span>            : }
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : void
<span class="lineNum">     699 </span><span class="lineCov">         42 : nsHTMLScrollFrame::ReflowContents(ScrollReflowInput* aState,</span>
<span class="lineNum">     700 </span>            :                                   const ReflowOutput&amp; aDesiredSize)
<span class="lineNum">     701 </span>            : {
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :   ReflowOutput kidDesiredSize(aDesiredSize.GetWritingMode());</span>
<span class="lineNum">     703 </span><span class="lineCov">         84 :   ReflowScrolledFrame(aState, GuessHScrollbarNeeded(*aState),</span>
<span class="lineNum">     704 </span><span class="lineCov">         84 :                       GuessVScrollbarNeeded(*aState), &amp;kidDesiredSize, true);</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :   // There's an important special case ... if the child appears to fit
<span class="lineNum">     707 </span>            :   // in the inside-border rect (but overflows the scrollport), we
<span class="lineNum">     708 </span>            :   // should try laying it out without a vertical scrollbar. It will
<span class="lineNum">     709 </span>            :   // usually fit because making the available-width wider will not
<span class="lineNum">     710 </span>            :   // normally make the child taller. (The only situation I can think
<span class="lineNum">     711 </span>            :   // of is when you have a line containing %-width inline replaced
<span class="lineNum">     712 </span>            :   // elements whose percentages sum to more than 100%, so increasing
<span class="lineNum">     713 </span>            :   // the available width makes the line break where it was fitting
<span class="lineNum">     714 </span>            :   // before.) If we don't treat this case specially, then we will
<span class="lineNum">     715 </span>            :   // decide that showing scrollbars is OK because the content
<span class="lineNum">     716 </span>            :   // overflows when we're showing scrollbars and we won't try to
<span class="lineNum">     717 </span>            :   // remove the vertical scrollbar.
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :   // Detecting when we enter this special case is important for when
<span class="lineNum">     720 </span>            :   // people design layouts that exactly fit the container &quot;most of the
<span class="lineNum">     721 </span>            :   // time&quot;.
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span>            :   // XXX Is this check really sufficient to catch all the incremental cases
<span class="lineNum">     724 </span>            :   // where the ideal case doesn't have a scrollbar?
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :   if ((aState-&gt;mReflowedContentsWithHScrollbar || aState-&gt;mReflowedContentsWithVScrollbar) &amp;&amp;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :       aState-&gt;mStyles.mVertical != NS_STYLE_OVERFLOW_SCROLL &amp;&amp;</span>
<span class="lineNum">     727 </span><span class="lineCov">          5 :       aState-&gt;mStyles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL) {</span>
<span class="lineNum">     728 </span>            :     nsSize insideBorderSize =
<span class="lineNum">     729 </span>            :       ComputeInsideBorderSize(aState,
<span class="lineNum">     730 </span><span class="lineCov">         10 :                               nsSize(kidDesiredSize.Width(), kidDesiredSize.Height()));</span>
<span class="lineNum">     731 </span>            :     nsRect scrolledRect =
<span class="lineNum">     732 </span><span class="lineCov">          5 :       mHelper.GetUnsnappedScrolledRectInternal(kidDesiredSize.ScrollableOverflow(),</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                                                insideBorderSize);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :     if (nsRect(nsPoint(0, 0), insideBorderSize).Contains(scrolledRect)) {</span>
<span class="lineNum">     735 </span>            :       // Let's pretend we had no scrollbars coming in here
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       kidDesiredSize.mOverflowAreas.Clear();</span>
<span class="lineNum">     737 </span><span class="lineCov">          5 :       ReflowScrolledFrame(aState, false, false, &amp;kidDesiredSize, false);</span>
<span class="lineNum">     738 </span>            :     }
<span class="lineNum">     739 </span>            :   }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :   // Try vertical scrollbar settings that leave the vertical scrollbar unchanged.
<span class="lineNum">     742 </span>            :   // Do this first because changing the vertical scrollbar setting is expensive,
<span class="lineNum">     743 </span>            :   // forcing a reflow always.
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :   // Try leaving the horizontal scrollbar unchanged first. This will be more
<span class="lineNum">     746 </span>            :   // efficient.
<span class="lineNum">     747 </span><span class="lineCov">         42 :   if (TryLayout(aState, &amp;kidDesiredSize, aState-&gt;mReflowedContentsWithHScrollbar,</span>
<span class="lineNum">     748 </span><span class="lineCov">         42 :                 aState-&gt;mReflowedContentsWithVScrollbar, false))</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   if (TryLayout(aState, &amp;kidDesiredSize, !aState-&gt;mReflowedContentsWithHScrollbar,</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :                 aState-&gt;mReflowedContentsWithVScrollbar, false))</span>
<span class="lineNum">     752 </span>            :     return;
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span>            :   // OK, now try toggling the vertical scrollbar. The performance advantage
<span class="lineNum">     755 </span>            :   // of trying the status-quo horizontal scrollbar state
<span class="lineNum">     756 </span>            :   // does not exist here (we'll have to reflow due to the vertical scrollbar
<span class="lineNum">     757 </span>            :   // change), so always try no horizontal scrollbar first.
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :   bool newVScrollbarState = !aState-&gt;mReflowedContentsWithVScrollbar;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   if (TryLayout(aState, &amp;kidDesiredSize, false, newVScrollbarState, false))</span>
<span class="lineNum">     760 </span>            :     return;
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   if (TryLayout(aState, &amp;kidDesiredSize, true, newVScrollbarState, false))</span>
<span class="lineNum">     762 </span>            :     return;
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :   // OK, we're out of ideas. Try again enabling whatever scrollbars we can
<span class="lineNum">     765 </span>            :   // enable and force the layout to stick even if it's inconsistent.
<span class="lineNum">     766 </span>            :   // This just happens sometimes.
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :   TryLayout(aState, &amp;kidDesiredSize,</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :             aState-&gt;mStyles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN,</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :             aState-&gt;mStyles.mVertical != NS_STYLE_OVERFLOW_HIDDEN,</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :             true);</span>
<span class="lineNum">     771 </span>            : }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : void
<span class="lineNum">     774 </span><span class="lineCov">         42 : nsHTMLScrollFrame::PlaceScrollArea(ScrollReflowInput&amp; aState,</span>
<span class="lineNum">     775 </span>            :                                    const nsPoint&amp; aScrollPosition)
<span class="lineNum">     776 </span>            : {
<span class="lineNum">     777 </span><span class="lineCov">         42 :   nsIFrame *scrolledFrame = mHelper.mScrolledFrame;</span>
<span class="lineNum">     778 </span>            :   // Set the x,y of the scrolled frame to the correct value
<span class="lineNum">     779 </span><span class="lineCov">         84 :   scrolledFrame-&gt;SetPosition(mHelper.mScrollPort.TopLeft() - aScrollPosition);</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :   // Recompute our scrollable overflow, taking perspective children into
<span class="lineNum">     782 </span>            :   // account. Note that this only recomputes the overflow areas stored on the
<span class="lineNum">     783 </span>            :   // helper (which are used to compute scrollable length and scrollbar thumb
<span class="lineNum">     784 </span>            :   // sizes) but not the overflow areas stored on the frame. This seems to work
<span class="lineNum">     785 </span>            :   // for now, but it's possible that we may need to update both in the future.
<span class="lineNum">     786 </span><span class="lineCov">         84 :   AdjustForPerspective(aState.mContentsOverflowAreas.ScrollableOverflow());</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineCov">         84 :   nsRect scrolledArea;</span>
<span class="lineNum">     789 </span>            :   // Preserve the width or height of empty rects
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :   nsSize portSize = mHelper.mScrollPort.Size();</span>
<span class="lineNum">     791 </span>            :   nsRect scrolledRect =
<span class="lineNum">     792 </span><span class="lineCov">         42 :     mHelper.GetUnsnappedScrolledRectInternal(aState.mContentsOverflowAreas.ScrollableOverflow(),</span>
<span class="lineNum">     793 </span><span class="lineCov">         84 :                                              portSize);</span>
<span class="lineNum">     794 </span>            :   scrolledArea.UnionRectEdges(scrolledRect,
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :                               nsRect(nsPoint(0,0), portSize));</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :   // Store the new overflow area. Note that this changes where an outline
<span class="lineNum">     798 </span>            :   // of the scrolled frame would be painted, but scrolled frames can't have
<span class="lineNum">     799 </span>            :   // outlines (the outline would go on this scrollframe instead).
<span class="lineNum">     800 </span>            :   // Using FinishAndStoreOverflow is needed so the overflow rect
<span class="lineNum">     801 </span>            :   // gets set correctly.  It also messes with the overflow rect in the
<span class="lineNum">     802 </span>            :   // -moz-hidden-unscrollable case, but scrolled frames can't have
<span class="lineNum">     803 </span>            :   // 'overflow' either.
<span class="lineNum">     804 </span>            :   // This needs to happen before SyncFrameViewAfterReflow so
<span class="lineNum">     805 </span>            :   // HasOverflowRect() will return the correct value.
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   nsOverflowAreas overflow(scrolledArea, scrolledArea);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :   scrolledFrame-&gt;FinishAndStoreOverflow(overflow,</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :                                         scrolledFrame-&gt;GetSize());</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            :   // Note that making the view *exactly* the size of the scrolled area
<span class="lineNum">     811 </span>            :   // is critical, since the view scrolling code uses the size of the
<span class="lineNum">     812 </span>            :   // scrolled view to clamp scroll requests.
<span class="lineNum">     813 </span>            :   // Normally the scrolledFrame won't have a view but in some cases it
<span class="lineNum">     814 </span>            :   // might create its own.
<span class="lineNum">     815 </span><span class="lineCov">         84 :   nsContainerFrame::SyncFrameViewAfterReflow(scrolledFrame-&gt;PresContext(),</span>
<span class="lineNum">     816 </span>            :                                              scrolledFrame,
<span class="lineNum">     817 </span>            :                                              scrolledFrame-&gt;GetView(),
<span class="lineNum">     818 </span>            :                                              scrolledArea,
<span class="lineNum">     819 </span><span class="lineCov">         42 :                                              0);</span>
<span class="lineNum">     820 </span><span class="lineCov">         42 : }</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            : nscoord
<span class="lineNum">     823 </span><span class="lineCov">         12 : nsHTMLScrollFrame::GetIntrinsicVScrollbarWidth(gfxContext *aRenderingContext)</span>
<span class="lineNum">     824 </span>            : {
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :   ScrollbarStyles ss = GetScrollbarStyles();</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :   if (ss.mVertical != NS_STYLE_OVERFLOW_SCROLL || !mHelper.mVScrollbarBox)</span>
<span class="lineNum">     827 </span>            :     return 0;
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   // Don't need to worry about reflow depth here since it's
<span class="lineNum">     830 </span>            :   // just for scrollbars
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :   nsBoxLayoutState bls(PresContext(), aRenderingContext, 0);</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :   nsSize vScrollbarPrefSize(0, 0);</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   GetScrollbarMetrics(bls, mHelper.mVScrollbarBox,</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                       nullptr, &amp;vScrollbarPrefSize, true);</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :   return vScrollbarPrefSize.width;</span>
<span class="lineNum">     836 </span>            : }
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : /* virtual */ nscoord
<span class="lineNum">     839 </span><span class="lineCov">          6 : nsHTMLScrollFrame::GetMinISize(gfxContext *aRenderingContext)</span>
<span class="lineNum">     840 </span>            : {
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :   nscoord result = mHelper.mScrolledFrame-&gt;GetMinISize(aRenderingContext);</span>
<span class="lineNum">     842 </span><span class="lineCov">         12 :   DISPLAY_MIN_WIDTH(this, result);</span>
<span class="lineNum">     843 </span><span class="lineCov">         12 :   return result + GetIntrinsicVScrollbarWidth(aRenderingContext);</span>
<span class="lineNum">     844 </span>            : }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : /* virtual */ nscoord
<span class="lineNum">     847 </span><span class="lineCov">          6 : nsHTMLScrollFrame::GetPrefISize(gfxContext *aRenderingContext)</span>
<span class="lineNum">     848 </span>            : {
<span class="lineNum">     849 </span><span class="lineCov">          6 :   nscoord result = mHelper.mScrolledFrame-&gt;GetPrefISize(aRenderingContext);</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :   DISPLAY_PREF_WIDTH(this, result);</span>
<span class="lineNum">     851 </span><span class="lineCov">         12 :   return NSCoordSaturatingAdd(result, GetIntrinsicVScrollbarWidth(aRenderingContext));</span>
<span class="lineNum">     852 </span>            : }
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : nsresult
<span class="lineNum">     855 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::GetXULPadding(nsMargin&amp; aMargin)</span>
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span>            :   // Our padding hangs out on the inside of the scrollframe, but XUL doesn't
<span class="lineNum">     858 </span>            :   // reaize that.  If we're stuck inside a XUL box, we need to claim no
<span class="lineNum">     859 </span>            :   // padding.
<span class="lineNum">     860 </span>            :   // @see also nsXULScrollFrame::GetXULPadding.
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :   aMargin.SizeTo(0,0,0,0);</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">     863 </span>            : }
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            : bool
<span class="lineNum">     866 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::IsXULCollapsed()</span>
<span class="lineNum">     867 </span>            : {
<span class="lineNum">     868 </span>            :   // We're never collapsed in the box sense.
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">     870 </span>            : }
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            : // Return the &lt;browser&gt; if the scrollframe is for the root frame directly
<span class="lineNum">     873 </span>            : // inside a &lt;browser&gt;.
<span class="lineNum">     874 </span>            : static Element*
<span class="lineNum">     875 </span><span class="lineCov">         32 : GetBrowserRoot(nsIContent* aContent)</span>
<span class="lineNum">     876 </span>            : {
<span class="lineNum">     877 </span><span class="lineCov">         32 :   if (aContent) {</span>
<span class="lineNum">     878 </span><span class="lineCov">         32 :     nsIDocument* doc = aContent-&gt;GetUncomposedDoc();</span>
<span class="lineNum">     879 </span><span class="lineCov">         32 :     if (nsPIDOMWindowOuter* win = doc-&gt;GetWindow()) {</span>
<span class="lineNum">     880 </span><span class="lineCov">          8 :       Element* frameElement = win-&gt;GetFrameElementInternal();</span>
<span class="lineNum">     881 </span><span class="lineCov">         11 :       if (frameElement &amp;&amp;</span>
<span class="lineNum">     882 </span><span class="lineCov">          9 :           frameElement-&gt;NodeInfo()-&gt;Equals(nsGkAtoms::browser, kNameSpaceID_XUL))</span>
<span class="lineNum">     883 </span>            :         return frameElement;
<span class="lineNum">     884 </span>            :     }
<span class="lineNum">     885 </span>            :   }
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            :   return nullptr;
<span class="lineNum">     888 </span>            : }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            : // When we have perspective set on the outer scroll frame, and transformed
<span class="lineNum">     891 </span>            : // children (possibly with preserve-3d) then the effective transform on the
<span class="lineNum">     892 </span>            : // child depends on the offset to the scroll frame, which changes as we scroll.
<span class="lineNum">     893 </span>            : // This perspective transform can cause the element to move relative to the
<span class="lineNum">     894 </span>            : // scrolled inner frame, which would cause the scrollable length changes during
<span class="lineNum">     895 </span>            : // scrolling if we didn't account for it. Since we don't want scrollHeight/Width
<span class="lineNum">     896 </span>            : // and the size of scrollbar thumbs to change during scrolling, we compute the
<span class="lineNum">     897 </span>            : // scrollable overflow by determining the scroll position at which the child
<span class="lineNum">     898 </span>            : // becomes completely visible within the scrollport rather than using the union
<span class="lineNum">     899 </span>            : // of the overflow areas at their current position.
<span class="lineNum">     900 </span>            : static void
<span class="lineNum">     901 </span><span class="lineNoCov">          0 : GetScrollableOverflowForPerspective(nsIFrame* aScrolledFrame,</span>
<span class="lineNum">     902 </span>            :                                     nsIFrame* aCurrentFrame,
<span class="lineNum">     903 </span>            :                                     const nsRect aScrollPort,
<span class="lineNum">     904 </span>            :                                     nsPoint aOffset,
<span class="lineNum">     905 </span>            :                                     nsRect&amp; aScrolledFrameOverflowArea)
<span class="lineNum">     906 </span>            : {
<span class="lineNum">     907 </span>            :   // Iterate over all children except pop-ups.
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   FrameChildListIDs skip = nsIFrame::kSelectPopupList | nsIFrame::kPopupList;</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   for (nsIFrame::ChildListIterator childLists(aCurrentFrame);</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :        !childLists.IsDone(); childLists.Next()) {</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     if (skip.Contains(childLists.CurrentID())) {</span>
<span class="lineNum">     912 </span>            :       continue;
<span class="lineNum">     913 </span>            :     }
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     for (nsIFrame* child : childLists.CurrentList()) {</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :       nsPoint offset = aOffset;</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            :       // When we reach a direct child of the scroll, then we record the offset
<span class="lineNum">     919 </span>            :       // to convert from that frame's coordinate into the scroll frame's
<span class="lineNum">     920 </span>            :       // coordinates. Preserve-3d descendant frames use the same offset as their
<span class="lineNum">     921 </span>            :       // ancestors, since TransformRect already converts us into the coordinate
<span class="lineNum">     922 </span>            :       // space of the preserve-3d root.
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :       if (aScrolledFrame == aCurrentFrame) {</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :         offset = child-&gt;GetPosition();</span>
<span class="lineNum">     925 </span>            :       }
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :       if (child-&gt;Extend3DContext()) {</span>
<span class="lineNum">     928 </span>            :         // If we're a preserve-3d frame, then recurse and include our
<span class="lineNum">     929 </span>            :         // descendants since overflow of preserve-3d frames is only included
<span class="lineNum">     930 </span>            :         // in the post-transform overflow area of the preserve-3d root frame.
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         GetScrollableOverflowForPerspective(aScrolledFrame, child, aScrollPort,</span>
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :                                             offset, aScrolledFrameOverflowArea);</span>
<span class="lineNum">     933 </span>            :       }
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :       // If we're transformed, then we want to consider the possibility that
<span class="lineNum">     936 </span>            :       // this frame might move relative to the scrolled frame when scrolling.
<span class="lineNum">     937 </span>            :       // For preserve-3d, leaf frames have correct overflow rects relative to
<span class="lineNum">     938 </span>            :       // themselves. preserve-3d 'nodes' (intermediate frames and the root) have
<span class="lineNum">     939 </span>            :       // only their untransformed children included in their overflow relative
<span class="lineNum">     940 </span>            :       // to self, which is what we want to include here.
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :       if (child-&gt;IsTransformed()) {</span>
<span class="lineNum">     942 </span>            :         // Compute the overflow rect for this leaf transform frame in the
<span class="lineNum">     943 </span>            :         // coordinate space of the scrolled frame.
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :         nsPoint scrollPos = aScrolledFrame-&gt;GetPosition();</span>
<span class="lineNum">     945 </span>            :         nsRect preScroll = nsDisplayTransform::TransformRect(
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :           child-&gt;GetScrollableOverflowRectRelativeToSelf(), child);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span>            :         // Temporarily override the scroll position of the scrolled frame by
<span class="lineNum">     949 </span>            :         // 10 CSS pixels, and then recompute what the overflow rect would be.
<span class="lineNum">     950 </span>            :         // This scroll position may not be valid, but that shouldn't matter
<span class="lineNum">     951 </span>            :         // for our calculations.
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         aScrolledFrame-&gt;SetPosition(scrollPos + nsPoint(600, 600));</span>
<span class="lineNum">     953 </span>            :         nsRect postScroll = nsDisplayTransform::TransformRect(
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :           child-&gt;GetScrollableOverflowRectRelativeToSelf(), child);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :         aScrolledFrame-&gt;SetPosition(scrollPos);</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :         // Compute how many app units the overflow rects moves by when we adjust
<span class="lineNum">     958 </span>            :         // the scroll position by 1 app unit.
<span class="lineNum">     959 </span>            :         double rightDelta =
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :           (postScroll.XMost() - preScroll.XMost() + 600.0) / 600.0;</span>
<span class="lineNum">     961 </span>            :         double bottomDelta =
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :           (postScroll.YMost() - preScroll.YMost() + 600.0) / 600.0;</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :         // We can't ever have negative scrolling.
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         NS_ASSERTION(rightDelta &gt; 0.0f &amp;&amp; bottomDelta &gt; 0.0f,</span>
<span class="lineNum">     966 </span>            :                      &quot;Scrolling can't be reversed!&quot;);
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :         // Move preScroll into the coordinate space of the scrollport.
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         preScroll += offset + scrollPos;</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            :         // For each of the four edges of preScroll, figure out how far they
<span class="lineNum">     972 </span>            :         // extend beyond the scrollport. Ignore negative values since that means
<span class="lineNum">     973 </span>            :         // that side is already scrolled in to view and we don't need to add
<span class="lineNum">     974 </span>            :         // overflow to account for it.
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         nsMargin overhang(std::max(0, aScrollPort.Y() - preScroll.Y()),</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :                           std::max(0, preScroll.XMost() - aScrollPort.XMost()),</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :                           std::max(0, preScroll.YMost() - aScrollPort.YMost()),</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                           std::max(0, aScrollPort.X() - preScroll.X()));</span>
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            :         // Scale according to rightDelta/bottomDelta to adjust for the different
<span class="lineNum">     981 </span>            :         // scroll rates.
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :         overhang.top /= bottomDelta;</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         overhang.right /= rightDelta;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :         overhang.bottom /= bottomDelta;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :         overhang.left /= rightDelta;</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span>            :         // Take the minimum overflow rect that would allow the current scroll
<span class="lineNum">     988 </span>            :         // position, using the size of the scroll port and offset by the
<span class="lineNum">     989 </span>            :         // inverse of the scroll position.
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :         nsRect overflow = aScrollPort - scrollPos;</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            :         // Expand it by our margins to get an overflow rect that would allow all
<span class="lineNum">     993 </span>            :         // edges of our transformed content to be scrolled into view.
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :         overflow.Inflate(overhang);</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :         // Merge it with the combined overflow
<span class="lineNum">     997 </span>            :         aScrolledFrameOverflowArea.UnionRect(aScrolledFrameOverflowArea,
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :                                              overflow);</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :       } else if (aCurrentFrame == aScrolledFrame) {</span>
<span class="lineNum">    1000 </span>            :         aScrolledFrameOverflowArea.UnionRect(
<span class="lineNum">    1001 </span>            :           aScrolledFrameOverflowArea,
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :           child-&gt;GetScrollableOverflowRectRelativeToParent());</span>
<span class="lineNum">    1003 </span>            :       }
<span class="lineNum">    1004 </span>            :     }
<span class="lineNum">    1005 </span>            :   }
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            : void
<span class="lineNum">    1009 </span><span class="lineCov">         42 : nsHTMLScrollFrame::AdjustForPerspective(nsRect&amp; aScrollableOverflow)</span>
<span class="lineNum">    1010 </span>            : {
<span class="lineNum">    1011 </span>            :   // If we have perspective that is being applied to our children, then
<span class="lineNum">    1012 </span>            :   // the effective transform on the child depends on the relative position
<span class="lineNum">    1013 </span>            :   // of the child to us and changes during scrolling.
<span class="lineNum">    1014 </span><span class="lineCov">         42 :   if (!ChildrenHavePerspective()) {</span>
<span class="lineNum">    1015 </span>            :     return;
<span class="lineNum">    1016 </span>            :   }
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   aScrollableOverflow.SetEmpty();</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :   GetScrollableOverflowForPerspective(mHelper.mScrolledFrame,</span>
<span class="lineNum">    1019 </span>            :                                       mHelper.mScrolledFrame,
<span class="lineNum">    1020 </span>            :                                       mHelper.mScrollPort,
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :                                       nsPoint(), aScrollableOverflow);</span>
<span class="lineNum">    1022 </span>            : }
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            : void
<span class="lineNum">    1025 </span><span class="lineCov">         42 : nsHTMLScrollFrame::Reflow(nsPresContext*           aPresContext,</span>
<span class="lineNum">    1026 </span>            :                           ReflowOutput&amp;     aDesiredSize,
<span class="lineNum">    1027 </span>            :                           const ReflowInput&amp; aReflowInput,
<span class="lineNum">    1028 </span>            :                           nsReflowStatus&amp;          aStatus)
<span class="lineNum">    1029 </span>            : {
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   MarkInReflow();</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   DO_GLOBAL_REFLOW_COUNT(&quot;nsHTMLScrollFrame&quot;);</span>
<span class="lineNum">    1032 </span><span class="lineCov">         84 :   DISPLAY_REFLOW(aPresContext, this, aReflowInput, aDesiredSize, aStatus);</span>
<span class="lineNum">    1033 </span><span class="lineCov">         42 :   MOZ_ASSERT(aStatus.IsEmpty(), &quot;Caller should pass a fresh reflow status!&quot;);</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span><span class="lineCov">         42 :   mHelper.HandleScrollbarStyleSwitching();</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   ScrollReflowInput state(this, aReflowInput);</span>
<span class="lineNum">    1038 </span>            :   // sanity check: ensure that if we have no scrollbar, we treat it
<span class="lineNum">    1039 </span>            :   // as hidden.
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   if (!mHelper.mVScrollbarBox || mHelper.mNeverHasVerticalScrollbar)</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :     state.mStyles.mVertical = NS_STYLE_OVERFLOW_HIDDEN;</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   if (!mHelper.mHScrollbarBox || mHelper.mNeverHasHorizontalScrollbar)</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :     state.mStyles.mHorizontal = NS_STYLE_OVERFLOW_HIDDEN;</span>
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :   //------------ Handle Incremental Reflow -----------------
<span class="lineNum">    1046 </span><span class="lineCov">         42 :   bool reflowHScrollbar = true;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :   bool reflowVScrollbar = true;</span>
<span class="lineNum">    1048 </span><span class="lineCov">         42 :   bool reflowScrollCorner = true;</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   if (!aReflowInput.ShouldReflowAllKids()) {</span>
<span class="lineNum">    1050 </span>            :     #define NEEDS_REFLOW(frame_) \
<span class="lineNum">    1051 </span>            :       ((frame_) &amp;&amp; NS_SUBTREE_DIRTY(frame_))
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span><span class="lineCov">          9 :     reflowHScrollbar = NEEDS_REFLOW(mHelper.mHScrollbarBox);</span>
<span class="lineNum">    1054 </span><span class="lineCov">          9 :     reflowVScrollbar = NEEDS_REFLOW(mHelper.mVScrollbarBox);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :     reflowScrollCorner = NEEDS_REFLOW(mHelper.mScrollCornerBox) ||</span>
<span class="lineNum">    1056 </span><span class="lineCov">          6 :                          NEEDS_REFLOW(mHelper.mResizerBox);</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :     #undef NEEDS_REFLOW
<span class="lineNum">    1059 </span>            :   }
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineCov">         42 :   if (mHelper.mIsRoot) {</span>
<span class="lineNum">    1062 </span><span class="lineCov">         32 :     mHelper.mCollapsedResizer = true;</span>
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :     Element* browserRoot = GetBrowserRoot(mContent);</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     if (browserRoot) {</span>
<span class="lineNum">    1066 </span><span class="lineCov">          3 :       bool showResizer = browserRoot-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::showresizer);</span>
<span class="lineNum">    1067 </span><span class="lineCov">          3 :       reflowScrollCorner = showResizer == mHelper.mCollapsedResizer;</span>
<span class="lineNum">    1068 </span><span class="lineCov">          3 :       mHelper.mCollapsedResizer = !showResizer;</span>
<span class="lineNum">    1069 </span>            :     }
<span class="lineNum">    1070 </span>            :   }
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineCov">         84 :   nsRect oldScrollAreaBounds = mHelper.mScrollPort;</span>
<span class="lineNum">    1073 </span>            :   nsRect oldScrolledAreaBounds =
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     mHelper.mScrolledFrame-&gt;GetScrollableOverflowRectRelativeToParent();</span>
<span class="lineNum">    1075 </span><span class="lineCov">         42 :   nsPoint oldScrollPosition = mHelper.GetScrollPosition();</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   state.mComputedBorder = aReflowInput.ComputedPhysicalBorderPadding() -</span>
<span class="lineNum">    1078 </span>            :     aReflowInput.ComputedPhysicalPadding();
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :   ReflowContents(&amp;state, aDesiredSize);</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineCov">         84 :   aDesiredSize.Width() = state.mInsideBorderSize.width +</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :     state.mComputedBorder.LeftRight();</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :   aDesiredSize.Height() = state.mInsideBorderSize.height +</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     state.mComputedBorder.TopBottom();</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :   // Set the size of the frame now since computing the perspective-correct
<span class="lineNum">    1088 </span>            :   // overflow (within PlaceScrollArea) can rely on it.
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :   SetSize(aDesiredSize.GetWritingMode(),</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :           aDesiredSize.Size(aDesiredSize.GetWritingMode()));</span>
<span class="lineNum">    1091 </span>            : 
<span class="lineNum">    1092 </span>            :   // Restore the old scroll position, for now, even if that's not valid anymore
<span class="lineNum">    1093 </span>            :   // because we changed size. We'll fix it up in a post-reflow callback, because
<span class="lineNum">    1094 </span>            :   // our current size may only be temporary (e.g. we're compute XUL desired sizes).
<span class="lineNum">    1095 </span><span class="lineCov">         42 :   PlaceScrollArea(state, oldScrollPosition);</span>
<span class="lineNum">    1096 </span><span class="lineCov">         42 :   if (!mHelper.mPostedReflowCallback) {</span>
<span class="lineNum">    1097 </span>            :     // Make sure we'll try scrolling to restored position
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :     PresShell()-&gt;PostReflowCallback(&amp;mHelper);</span>
<span class="lineNum">    1099 </span><span class="lineCov">         40 :     mHelper.mPostedReflowCallback = true;</span>
<span class="lineNum">    1100 </span>            :   }
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :   bool didHaveHScrollbar = mHelper.mHasHorizontalScrollbar;</span>
<span class="lineNum">    1103 </span><span class="lineCov">         42 :   bool didHaveVScrollbar = mHelper.mHasVerticalScrollbar;</span>
<span class="lineNum">    1104 </span><span class="lineCov">         42 :   mHelper.mHasHorizontalScrollbar = state.mShowHScrollbar;</span>
<span class="lineNum">    1105 </span><span class="lineCov">         42 :   mHelper.mHasVerticalScrollbar = state.mShowVScrollbar;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   nsRect newScrollAreaBounds = mHelper.mScrollPort;</span>
<span class="lineNum">    1107 </span>            :   nsRect newScrolledAreaBounds =
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     mHelper.mScrolledFrame-&gt;GetScrollableOverflowRectRelativeToParent();</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :   if (mHelper.mSkippedScrollbarLayout ||</span>
<span class="lineNum">    1110 </span><span class="lineCov">         48 :       reflowHScrollbar || reflowVScrollbar || reflowScrollCorner ||</span>
<span class="lineNum">    1111 </span><span class="lineCov">         18 :       (GetStateBits() &amp; NS_FRAME_IS_DIRTY) ||</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :       didHaveHScrollbar != state.mShowHScrollbar ||</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       didHaveVScrollbar != state.mShowVScrollbar ||</span>
<span class="lineNum">    1114 </span><span class="lineCov">         54 :       !oldScrollAreaBounds.IsEqualEdges(newScrollAreaBounds) ||</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :       !oldScrolledAreaBounds.IsEqualEdges(newScrolledAreaBounds)) {</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     if (!mHelper.mSuppressScrollbarUpdate) {</span>
<span class="lineNum">    1117 </span><span class="lineCov">         36 :       mHelper.mSkippedScrollbarLayout = false;</span>
<span class="lineNum">    1118 </span><span class="lineCov">         36 :       ScrollFrameHelper::SetScrollbarVisibility(mHelper.mHScrollbarBox, state.mShowHScrollbar);</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :       ScrollFrameHelper::SetScrollbarVisibility(mHelper.mVScrollbarBox, state.mShowVScrollbar);</span>
<span class="lineNum">    1120 </span>            :       // place and reflow scrollbars
<span class="lineNum">    1121 </span>            :       nsRect insideBorderArea =
<span class="lineNum">    1122 </span><span class="lineCov">        108 :         nsRect(nsPoint(state.mComputedBorder.left, state.mComputedBorder.top),</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                state.mInsideBorderSize);</span>
<span class="lineNum">    1124 </span>            :       mHelper.LayoutScrollbars(state.mBoxState, insideBorderArea,
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                               oldScrollAreaBounds);</span>
<span class="lineNum">    1126 </span>            :     } else {
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :       mHelper.mSkippedScrollbarLayout = true;</span>
<span class="lineNum">    1128 </span>            :     }
<span class="lineNum">    1129 </span>            :   }
<span class="lineNum">    1130 </span>            : 
<span class="lineNum">    1131 </span><span class="lineCov">         42 :   aDesiredSize.SetOverflowAreasToDesiredBounds();</span>
<span class="lineNum">    1132 </span><span class="lineCov">         42 :   if (mHelper.IsIgnoringViewportClipping()) {</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     aDesiredSize.mOverflowAreas.UnionWith(</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       state.mContentsOverflowAreas + mHelper.mScrolledFrame-&gt;GetPosition());</span>
<span class="lineNum">    1135 </span>            :   }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :   mHelper.UpdateSticky();</span>
<span class="lineNum">    1138 </span><span class="lineCov">         42 :   FinishReflowWithAbsoluteFrames(aPresContext, aDesiredSize, aReflowInput, aStatus);</span>
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineCov">         42 :   if (!InInitialReflow() &amp;&amp; !mHelper.mHadNonInitialReflow) {</span>
<span class="lineNum">    1141 </span><span class="lineCov">         21 :     mHelper.mHadNonInitialReflow = true;</span>
<span class="lineNum">    1142 </span>            :   }
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span><span class="lineCov">         42 :   if (mHelper.mIsRoot &amp;&amp; !oldScrolledAreaBounds.IsEqualEdges(newScrolledAreaBounds)) {</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :     mHelper.PostScrolledAreaEvent();</span>
<span class="lineNum">    1146 </span>            :   }
<span class="lineNum">    1147 </span>            : 
<span class="lineNum">    1148 </span><span class="lineCov">         42 :   mHelper.UpdatePrevScrolledRect();</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineCov">         42 :   aStatus.Reset(); // This type of frame can't be split.</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :   NS_FRAME_SET_TRUNCATION(aStatus, aReflowInput, aDesiredSize);</span>
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :   mHelper.PostOverflowEvent();</span>
<span class="lineNum">    1153 </span><span class="lineCov">         42 : }</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : #ifdef DEBUG_FRAME_DUMP
<span class="lineNum">    1159 </span>            : nsresult
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::GetFrameName(nsAString&amp; aResult) const</span>
<span class="lineNum">    1161 </span>            : {
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :   return MakeFrameName(NS_LITERAL_STRING(&quot;HTMLScroll&quot;), aResult);</span>
<span class="lineNum">    1163 </span>            : }
<span class="lineNum">    1164 </span>            : #endif
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            : #ifdef ACCESSIBILITY
<span class="lineNum">    1167 </span>            : a11y::AccType
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 : nsHTMLScrollFrame::AccessibleType()</span>
<span class="lineNum">    1169 </span>            : {
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :   if (IsTableCaption()) {</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :     return GetRect().IsEmpty() ? a11y::eNoType : a11y::eHTMLCaptionType;</span>
<span class="lineNum">    1172 </span>            :   }
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :   // Create an accessible regardless of focusable state because the state can be
<span class="lineNum">    1175 </span>            :   // changed during frame life cycle without any notifications to accessibility.
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :   if (mContent-&gt;IsRootOfNativeAnonymousSubtree() ||</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :       GetScrollbarStyles().IsHiddenInBothDirections()) {</span>
<span class="lineNum">    1178 </span>            :     return a11y::eNoType;
<span class="lineNum">    1179 </span>            :   }
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :   return a11y::eHyperTextType;</span>
<span class="lineNum">    1182 </span>            : }
<span class="lineNum">    1183 </span>            : #endif
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 : NS_QUERYFRAME_HEAD(nsHTMLScrollFrame)</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(nsIScrollableFrame)</span>
<span class="lineNum">    1188 </span><span class="lineCov">          5 :   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)</span>
<span class="lineNum">    1189 </span><span class="lineCov">         13 :   NS_QUERYFRAME_ENTRY(nsIScrollbarMediator)</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 : NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            : //----------nsXULScrollFrame-------------------------------------------
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            : nsXULScrollFrame*
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 : NS_NewXULScrollFrame(nsIPresShell* aPresShell, ComputedStyle* aStyle,</span>
<span class="lineNum">    1196 </span>            :                      bool aIsRoot, bool aClipAllDescendants)
<span class="lineNum">    1197 </span>            : {
<span class="lineNum">    1198 </span>            :   return new (aPresShell) nsXULScrollFrame(aStyle, aIsRoot,
<span class="lineNum">    1199 </span><span class="lineCov">          9 :                                            aClipAllDescendants);</span>
<span class="lineNum">    1200 </span>            : }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineCov">          9 : NS_IMPL_FRAMEARENA_HELPERS(nsXULScrollFrame)</span>
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span><span class="lineCov">          9 : nsXULScrollFrame::nsXULScrollFrame(ComputedStyle* aStyle,</span>
<span class="lineNum">    1205 </span>            :                                    bool aIsRoot,
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :                                    bool aClipAllDescendants)</span>
<span class="lineNum">    1207 </span>            :   : nsBoxFrame(aStyle, kClassID, aIsRoot)
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   , mHelper(ALLOW_THIS_IN_INITIALIZER_LIST(this), aIsRoot)</span>
<span class="lineNum">    1209 </span>            : {
<span class="lineNum">    1210 </span><span class="lineCov">         18 :   SetXULLayoutManager(nullptr);</span>
<span class="lineNum">    1211 </span><span class="lineCov">          9 :   mHelper.mClipAllDescendants = aClipAllDescendants;</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            : void
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 : nsXULScrollFrame::ScrollbarActivityStarted() const</span>
<span class="lineNum">    1216 </span>            : {
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   if (mHelper.mScrollbarActivity) {</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     mHelper.mScrollbarActivity-&gt;ActivityStarted();</span>
<span class="lineNum">    1219 </span>            :   }
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : void
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 : nsXULScrollFrame::ScrollbarActivityStopped() const</span>
<span class="lineNum">    1224 </span>            : {
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   if (mHelper.mScrollbarActivity) {</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     mHelper.mScrollbarActivity-&gt;ActivityStopped();</span>
<span class="lineNum">    1227 </span>            :   }
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span>            : nsMargin
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetDesiredScrollbarSizes(nsBoxLayoutState* aState)</span>
<span class="lineNum">    1232 </span>            : {
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aState &amp;&amp; aState-&gt;GetRenderingContext(),</span>
<span class="lineNum">    1234 </span>            :                &quot;Must have rendering context in layout state for size &quot;
<span class="lineNum">    1235 </span>            :                &quot;computations&quot;);
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   nsMargin result(0, 0, 0, 0);</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :   if (mVScrollbarBox) {</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :     nsSize size = mVScrollbarBox-&gt;GetXULPrefSize(*aState);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :     nsBox::AddMargin(mVScrollbarBox, size);</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :     if (IsScrollbarOnRight())</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :       result.left = size.width;</span>
<span class="lineNum">    1244 </span>            :     else
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       result.right = size.width;</span>
<span class="lineNum">    1246 </span>            :   }
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :   if (mHScrollbarBox) {</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :     nsSize size = mHScrollbarBox-&gt;GetXULPrefSize(*aState);</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :     nsBox::AddMargin(mHScrollbarBox, size);</span>
<span class="lineNum">    1251 </span>            :     // We don't currently support any scripts that would require a scrollbar
<span class="lineNum">    1252 </span>            :     // at the top. (Are there any?)
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :     result.bottom = size.height;</span>
<span class="lineNum">    1254 </span>            :   }
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    1257 </span>            : }
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            : nscoord
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetNondisappearingScrollbarWidth(nsBoxLayoutState* aState,</span>
<span class="lineNum">    1261 </span>            :                                                     WritingMode aWM)
<span class="lineNum">    1262 </span>            : {
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aState &amp;&amp; aState-&gt;GetRenderingContext(),</span>
<span class="lineNum">    1264 </span>            :                &quot;Must have rendering context in layout state for size &quot;
<span class="lineNum">    1265 </span>            :                &quot;computations&quot;);
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :   bool verticalWM = aWM.IsVertical();</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   if (LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {</span>
<span class="lineNum">    1269 </span>            :     // We're using overlay scrollbars, so we need to get the width that
<span class="lineNum">    1270 </span>            :     // non-disappearing scrollbars would have.
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :     nsITheme* theme = aState-&gt;PresContext()-&gt;GetTheme();</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :     if (theme &amp;&amp;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :         theme-&gt;ThemeSupportsWidget(aState-&gt;PresContext(),</span>
<span class="lineNum">    1274 </span>            :                                    verticalWM ? mHScrollbarBox
<span class="lineNum">    1275 </span>            :                                               : mVScrollbarBox,
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :                                    NS_THEME_SCROLLBAR_NON_DISAPPEARING)) {</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :       LayoutDeviceIntSize size;</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :       bool canOverride = true;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :       theme-&gt;GetMinimumWidgetSize(aState-&gt;PresContext(),</span>
<span class="lineNum">    1280 </span>            :                                   verticalWM ? mHScrollbarBox
<span class="lineNum">    1281 </span>            :                                              : mVScrollbarBox,
<span class="lineNum">    1282 </span>            :                                   NS_THEME_SCROLLBAR_NON_DISAPPEARING,
<span class="lineNum">    1283 </span>            :                                   &amp;size,
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :                                   &amp;canOverride);</span>
<span class="lineNum">    1285 </span>            :       return aState-&gt;PresContext()-&gt;
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :              DevPixelsToAppUnits(verticalWM ? size.height : size.width);</span>
<span class="lineNum">    1287 </span>            :     }
<span class="lineNum">    1288 </span>            :   }
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   nsMargin sizes(GetDesiredScrollbarSizes(aState));</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :   return verticalWM ? sizes.TopBottom() : sizes.LeftRight();</span>
<span class="lineNum">    1292 </span>            : }
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span>            : void
<span class="lineNum">    1295 </span><span class="lineCov">         42 : ScrollFrameHelper::HandleScrollbarStyleSwitching()</span>
<span class="lineNum">    1296 </span>            : {
<span class="lineNum">    1297 </span>            :   // Check if we switched between scrollbar styles.
<span class="lineNum">    1298 </span><span class="lineCov">         42 :   if (mScrollbarActivity &amp;&amp;</span>
<span class="lineNum">    1299 </span><span class="lineCov">         84 :       LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) == 0) {</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :     mScrollbarActivity-&gt;Destroy();</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :     mScrollbarActivity = nullptr;</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :     mOuter-&gt;PresContext()-&gt;ThemeChanged();</span>
<span class="lineNum">    1303 </span>            :   }
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :   else if (!mScrollbarActivity &amp;&amp;</span>
<span class="lineNum">    1305 </span><span class="lineCov">          1 :            LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     mScrollbarActivity = new ScrollbarActivity(do_QueryFrame(mOuter));</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     mOuter-&gt;PresContext()-&gt;ThemeChanged();</span>
<span class="lineNum">    1308 </span>            :   }
<span class="lineNum">    1309 </span><span class="lineCov">         42 : }</span>
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1312 </span>            : static bool IsFocused(nsIContent* aContent)
<span class="lineNum">    1313 </span>            : {
<span class="lineNum">    1314 </span>            :   // Some content elements, like the GetContent() of a scroll frame
<span class="lineNum">    1315 </span>            :   // for a text input field, are inside anonymous subtrees, but the focus
<span class="lineNum">    1316 </span>            :   // manager always reports a non-anonymous element as the focused one, so
<span class="lineNum">    1317 </span>            :   // walk up the tree until we reach a non-anonymous element.
<span class="lineNum">    1318 </span>            :   while (aContent &amp;&amp; aContent-&gt;IsInAnonymousSubtree()) {
<span class="lineNum">    1319 </span>            :     aContent = aContent-&gt;GetParent();
<span class="lineNum">    1320 </span>            :   }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span>            :   return aContent ? nsContentUtils::IsFocusedContent(aContent) : false;
<span class="lineNum">    1323 </span>            : }
<span class="lineNum">    1324 </span>            : #endif
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            : void
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 : ScrollFrameHelper::SetScrollableByAPZ(bool aScrollable)</span>
<span class="lineNum">    1328 </span>            : {
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   mScrollableByAPZ = aScrollable;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            : void
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 : ScrollFrameHelper::SetZoomableByAPZ(bool aZoomable)</span>
<span class="lineNum">    1334 </span>            : {
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   if (mZoomableByAPZ != aZoomable) {</span>
<span class="lineNum">    1336 </span>            :     // We might be changing the result of WantAsyncScroll() so schedule a
<span class="lineNum">    1337 </span>            :     // paint to make sure we pick up the result of that change.
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :     mZoomableByAPZ = aZoomable;</span>
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :     mOuter-&gt;SchedulePaint();</span>
<span class="lineNum">    1340 </span>            :   }
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            : void
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 : ScrollFrameHelper::SetHasOutOfFlowContentInsideFilter()</span>
<span class="lineNum">    1345 </span>            : {
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :   mHasOutOfFlowContentInsideFilter = true;</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            : bool
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 : ScrollFrameHelper::WantAsyncScroll() const</span>
<span class="lineNum">    1351 </span>            : {
<span class="lineNum">    1352 </span>            :   // If zooming is allowed, and this is a frame that's allowed to zoom, then
<span class="lineNum">    1353 </span>            :   // we want it to be async-scrollable or zooming will not be permitted.
<span class="lineNum">    1354 </span><span class="lineCov">        148 :   if (mZoomableByAPZ) {</span>
<span class="lineNum">    1355 </span>            :     return true;
<span class="lineNum">    1356 </span>            :   }
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :   ScrollbarStyles styles = GetScrollbarStylesFromFrame();</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :   nscoord oneDevPixel = GetScrolledFrame()-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :   nsRect scrollRange = GetScrollRange();</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :   bool isVScrollable = (scrollRange.height &gt;= oneDevPixel) &amp;&amp;</span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :                        (styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN);</span>
<span class="lineNum">    1363 </span><span class="lineCov">        166 :   bool isHScrollable = (scrollRange.width &gt;= oneDevPixel) &amp;&amp;</span>
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :                        (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN);</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            : #if defined(MOZ_WIDGET_ANDROID)
<span class="lineNum">    1367 </span>            :   // Mobile platforms need focus to scroll.
<span class="lineNum">    1368 </span>            :   bool canScrollWithoutScrollbars = IsFocused(mOuter-&gt;GetContent());
<span class="lineNum">    1369 </span>            : #else
<span class="lineNum">    1370 </span><span class="lineCov">        148 :   bool canScrollWithoutScrollbars = true;</span>
<span class="lineNum">    1371 </span>            : #endif
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :   // The check for scroll bars was added in bug 825692 to prevent layerization
<span class="lineNum">    1374 </span>            :   // of text inputs for performance reasons.
<span class="lineNum">    1375 </span><span class="lineCov">          1 :   bool isVAsyncScrollable = isVScrollable &amp;&amp; (mVScrollbarBox || canScrollWithoutScrollbars);</span>
<span class="lineNum">    1376 </span><span class="lineCov">          1 :   bool isHAsyncScrollable = isHScrollable &amp;&amp; (mHScrollbarBox || canScrollWithoutScrollbars);</span>
<span class="lineNum">    1377 </span><span class="lineCov">        148 :   return isVAsyncScrollable || isHAsyncScrollable;</span>
<span class="lineNum">    1378 </span>            : }
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : static nsRect
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 : GetOnePixelRangeAroundPoint(const nsPoint&amp; aPoint, bool aIsHorizontal)</span>
<span class="lineNum">    1382 </span>            : {
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :   nsRect allowedRange(aPoint, nsSize());</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   nscoord halfPixel = nsPresContext::CSSPixelsToAppUnits(0.5f);</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   if (aIsHorizontal) {</span>
<span class="lineNum">    1386 </span><span class="lineNoCov">          0 :     allowedRange.x = aPoint.x - halfPixel;</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     allowedRange.width = halfPixel*2 - 1;</span>
<span class="lineNum">    1388 </span>            :   } else {
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :     allowedRange.y = aPoint.y - halfPixel;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :     allowedRange.height = halfPixel*2 - 1;</span>
<span class="lineNum">    1391 </span>            :   }
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   return allowedRange;</span>
<span class="lineNum">    1393 </span>            : }
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            : void
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollByPage(nsScrollbarFrame* aScrollbar, int32_t aDirection,</span>
<span class="lineNum">    1397 </span>            :                                 nsIScrollbarMediator::ScrollSnapMode aSnap)
<span class="lineNum">    1398 </span>            : {
<span class="lineNum">    1399 </span>            :   ScrollByUnit(aScrollbar, nsIScrollableFrame::SMOOTH, aDirection,
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :                nsIScrollableFrame::PAGES, aSnap);</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            : void
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollByWhole(nsScrollbarFrame* aScrollbar, int32_t aDirection,</span>
<span class="lineNum">    1405 </span>            :                                  nsIScrollbarMediator::ScrollSnapMode aSnap)
<span class="lineNum">    1406 </span>            : {
<span class="lineNum">    1407 </span>            :   ScrollByUnit(aScrollbar, nsIScrollableFrame::INSTANT, aDirection,
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :                nsIScrollableFrame::WHOLE, aSnap);</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            : void
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollByLine(nsScrollbarFrame* aScrollbar, int32_t aDirection,</span>
<span class="lineNum">    1413 </span>            :                                 nsIScrollbarMediator::ScrollSnapMode aSnap)
<span class="lineNum">    1414 </span>            : {
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :   bool isHorizontal = aScrollbar-&gt;IsXULHorizontal();</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   nsIntPoint delta;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :   if (isHorizontal) {</span>
<span class="lineNum">    1418 </span>            :     const double kScrollMultiplier =
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       Preferences::GetInt(&quot;toolkit.scrollbox.horizontalScrollDistance&quot;,</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :                           NS_DEFAULT_HORIZONTAL_SCROLL_DISTANCE);</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :     delta.x = aDirection * kScrollMultiplier;</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :     if (GetLineScrollAmount().width * delta.x &gt; GetPageScrollAmount().width) {</span>
<span class="lineNum">    1423 </span>            :       // The scroll frame is so small that the delta would be more
<span class="lineNum">    1424 </span>            :       // than an entire page.  Scroll by one page instead to maintain
<span class="lineNum">    1425 </span>            :       // context.
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :       ScrollByPage(aScrollbar, aDirection);</span>
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1428 </span>            :     }
<span class="lineNum">    1429 </span>            :   } else {
<span class="lineNum">    1430 </span>            :     const double kScrollMultiplier =
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :       Preferences::GetInt(&quot;toolkit.scrollbox.verticalScrollDistance&quot;,</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :                           NS_DEFAULT_VERTICAL_SCROLL_DISTANCE);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     delta.y = aDirection * kScrollMultiplier;</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     if (GetLineScrollAmount().height * delta.y &gt; GetPageScrollAmount().height) {</span>
<span class="lineNum">    1435 </span>            :       // The scroll frame is so small that the delta would be more
<span class="lineNum">    1436 </span>            :       // than an entire page.  Scroll by one page instead to maintain
<span class="lineNum">    1437 </span>            :       // context.
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :       ScrollByPage(aScrollbar, aDirection);</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1440 </span>            :     }
<span class="lineNum">    1441 </span>            :   }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :   nsIntPoint overflow;</span>
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :   ScrollBy(delta, nsIScrollableFrame::LINES, nsIScrollableFrame::SMOOTH,</span>
<span class="lineNum">    1445 </span>            :            &amp;overflow, nsGkAtoms::other, nsIScrollableFrame::NOT_MOMENTUM,
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :            aSnap);</span>
<span class="lineNum">    1447 </span>            : }
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            : void
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 : ScrollFrameHelper::RepeatButtonScroll(nsScrollbarFrame* aScrollbar)</span>
<span class="lineNum">    1451 </span>            : {
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :   aScrollbar-&gt;MoveToNewPosition();</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            : void
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ThumbMoved(nsScrollbarFrame* aScrollbar,</span>
<span class="lineNum">    1457 </span>            :                               nscoord aOldPos,
<span class="lineNum">    1458 </span>            :                               nscoord aNewPos)
<span class="lineNum">    1459 </span>            : {
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aScrollbar != nullptr);</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   bool isHorizontal = aScrollbar-&gt;IsXULHorizontal();</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   nsPoint current = GetScrollPosition();</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   nsPoint dest = current;</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   if (isHorizontal) {</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :     dest.x = IsPhysicalLTR() ? aNewPos : aNewPos - GetScrollRange().width;</span>
<span class="lineNum">    1466 </span>            :   } else {
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :     dest.y = aNewPos;</span>
<span class="lineNum">    1468 </span>            :   }
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :   nsRect allowedRange = GetOnePixelRangeAroundPoint(dest, isHorizontal);</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :   // Don't try to scroll if we're already at an acceptable place.
<span class="lineNum">    1472 </span>            :   // Don't call Contains here since Contains returns false when the point is
<span class="lineNum">    1473 </span>            :   // on the bottom or right edge of the rectangle.
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   if (allowedRange.ClampPoint(current) == current) {</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1476 </span>            :   }
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   ScrollTo(dest, nsIScrollableFrame::INSTANT, &amp;allowedRange);</span>
<span class="lineNum">    1479 </span>            : }
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : void
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollbarReleased(nsScrollbarFrame* aScrollbar)</span>
<span class="lineNum">    1483 </span>            : {
<span class="lineNum">    1484 </span>            :   // Scrollbar scrolling does not result in fling gestures, clear any
<span class="lineNum">    1485 </span>            :   // accumulated velocity
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :   mVelocityQueue.Reset();</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            :   // Perform scroll snapping, if needed.  Scrollbar movement uses the same
<span class="lineNum">    1489 </span>            :   // smooth scrolling animation as keyboard scrolling.
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :   ScrollSnap(mDestination, nsIScrollableFrame::SMOOTH);</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span>            : void
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollByUnit(nsScrollbarFrame* aScrollbar,</span>
<span class="lineNum">    1495 </span>            :                                 nsIScrollableFrame::ScrollMode aMode,
<span class="lineNum">    1496 </span>            :                                 int32_t aDirection,
<span class="lineNum">    1497 </span>            :                                 nsIScrollableFrame::ScrollUnit aUnit,
<span class="lineNum">    1498 </span>            :                                 nsIScrollbarMediator::ScrollSnapMode aSnap)
<span class="lineNum">    1499 </span>            : {
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aScrollbar != nullptr);</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :   bool isHorizontal = aScrollbar-&gt;IsXULHorizontal();</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :   nsIntPoint delta;</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :   if (isHorizontal) {</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     delta.x = aDirection;</span>
<span class="lineNum">    1505 </span>            :   } else {
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :     delta.y = aDirection;</span>
<span class="lineNum">    1507 </span>            :   }
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   nsIntPoint overflow;</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   ScrollBy(delta, aUnit, aMode, &amp;overflow, nsGkAtoms::other,</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :            nsIScrollableFrame::NOT_MOMENTUM, aSnap);</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span>            : nsresult
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 : nsXULScrollFrame::CreateAnonymousContent(nsTArray&lt;ContentInfo&gt;&amp; aElements)</span>
<span class="lineNum">    1515 </span>            : {
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :   return mHelper.CreateAnonymousContent(aElements);</span>
<span class="lineNum">    1517 </span>            : }
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            : void
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 : nsXULScrollFrame::AppendAnonymousContentTo(nsTArray&lt;nsIContent*&gt;&amp; aElements,</span>
<span class="lineNum">    1521 </span>            :                                            uint32_t aFilter)
<span class="lineNum">    1522 </span>            : {
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :   mHelper.AppendAnonymousContentTo(aElements, aFilter);</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            : void
<span class="lineNum">    1527 </span><span class="lineCov">          2 : nsXULScrollFrame::DestroyFrom(nsIFrame* aDestructRoot, PostDestroyData&amp; aPostDestroyData)</span>
<span class="lineNum">    1528 </span>            : {
<span class="lineNum">    1529 </span><span class="lineCov">          2 :   mHelper.Destroy(aPostDestroyData);</span>
<span class="lineNum">    1530 </span><span class="lineCov">          2 :   nsBoxFrame::DestroyFrom(aDestructRoot, aPostDestroyData);</span>
<span class="lineNum">    1531 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            : void
<span class="lineNum">    1534 </span><span class="lineCov">          1 : nsXULScrollFrame::SetInitialChildList(ChildListID     aListID,</span>
<span class="lineNum">    1535 </span>            :                                       nsFrameList&amp;    aChildList)
<span class="lineNum">    1536 </span>            : {
<span class="lineNum">    1537 </span><span class="lineCov">          1 :   nsBoxFrame::SetInitialChildList(aListID, aChildList);</span>
<span class="lineNum">    1538 </span><span class="lineCov">          9 :   if (aListID == kPrincipalList) {</span>
<span class="lineNum">    1539 </span><span class="lineCov">          9 :     mHelper.ReloadChildFrames();</span>
<span class="lineNum">    1540 </span>            :   }
<span class="lineNum">    1541 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span>            : void
<span class="lineNum">    1545 </span><span class="lineCov">          1 : nsXULScrollFrame::AppendFrames(ChildListID     aListID,</span>
<span class="lineNum">    1546 </span>            :                                nsFrameList&amp;    aFrameList)
<span class="lineNum">    1547 </span>            : {
<span class="lineNum">    1548 </span><span class="lineCov">          9 :   nsBoxFrame::AppendFrames(aListID, aFrameList);</span>
<span class="lineNum">    1549 </span><span class="lineCov">          9 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">    1550 </span><span class="lineCov">          9 : }</span>
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            : void
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 : nsXULScrollFrame::InsertFrames(ChildListID     aListID,</span>
<span class="lineNum">    1554 </span>            :                                nsIFrame*       aPrevFrame,
<span class="lineNum">    1555 </span>            :                                nsFrameList&amp;    aFrameList)
<span class="lineNum">    1556 </span>            : {
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :   nsBoxFrame::InsertFrames(aListID, aPrevFrame, aFrameList);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            : void
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 : nsXULScrollFrame::RemoveFrame(ChildListID     aListID,</span>
<span class="lineNum">    1563 </span>            :                               nsIFrame*       aOldFrame)
<span class="lineNum">    1564 </span>            : {
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   nsBoxFrame::RemoveFrame(aListID, aOldFrame);</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :   mHelper.ReloadChildFrames();</span>
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            : nsSplittableType
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 : nsXULScrollFrame::GetSplittableType() const</span>
<span class="lineNum">    1571 </span>            : {
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   return NS_FRAME_NOT_SPLITTABLE;</span>
<span class="lineNum">    1573 </span>            : }
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            : nsresult
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 : nsXULScrollFrame::GetXULPadding(nsMargin&amp; aMargin)</span>
<span class="lineNum">    1577 </span>            : {
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :   aMargin.SizeTo(0,0,0,0);</span>
<span class="lineNum">    1579 </span><span class="lineCov">        211 :   return NS_OK;</span>
<span class="lineNum">    1580 </span>            : }
<span class="lineNum">    1581 </span>            : 
<span class="lineNum">    1582 </span>            : nscoord
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 : nsXULScrollFrame::GetXULBoxAscent(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">    1584 </span>            : {
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   if (!mHelper.mScrolledFrame)</span>
<span class="lineNum">    1586 </span>            :     return 0;
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span><span class="lineCov">         48 :   nscoord ascent = mHelper.mScrolledFrame-&gt;GetXULBoxAscent(aState);</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   nsMargin m(0,0,0,0);</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   GetXULBorderAndPadding(m);</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :   ascent += m.top;</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :   GetXULMargin(m);</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   ascent += m.top;</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineCov">         48 :   return ascent;</span>
<span class="lineNum">    1596 </span>            : }
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span>            : nsSize
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 : nsXULScrollFrame::GetXULPrefSize(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">    1600 </span>            : {
<span class="lineNum">    1601 </span><span class="lineCov">         44 :   nsSize pref = mHelper.mScrolledFrame-&gt;GetXULPrefSize(aState);</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 :   ScrollbarStyles styles = GetScrollbarStyles();</span>
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span>            :   // scrolled frames don't have their own margins
<span class="lineNum">    1606 </span>            : 
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :   if (mHelper.mVScrollbarBox &amp;&amp;</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :     nsSize vSize = mHelper.mVScrollbarBox-&gt;GetXULPrefSize(aState);</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :     nsBox::AddMargin(mHelper.mVScrollbarBox, vSize);</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :     pref.width += vSize.width;</span>
<span class="lineNum">    1612 </span>            :   }
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :   if (mHelper.mHScrollbarBox &amp;&amp;</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :     nsSize hSize = mHelper.mHScrollbarBox-&gt;GetXULPrefSize(aState);</span>
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :     nsBox::AddMargin(mHelper.mHScrollbarBox, hSize);</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :     pref.height += hSize.height;</span>
<span class="lineNum">    1619 </span>            :   }
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :   AddBorderAndPadding(pref);</span>
<span class="lineNum">    1622 </span>            :   bool widthSet, heightSet;
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :   nsIFrame::AddXULPrefSize(this, pref, widthSet, heightSet);</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :   return pref;</span>
<span class="lineNum">    1625 </span>            : }
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span>            : nsSize
<span class="lineNum">    1628 </span><span class="lineCov">         56 : nsXULScrollFrame::GetXULMinSize(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">    1629 </span>            : {
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :   nsSize min = mHelper.mScrolledFrame-&gt;GetXULMinSizeForScrollArea(aState);</span>
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span><span class="lineCov">        112 :   ScrollbarStyles styles = GetScrollbarStyles();</span>
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :   if (mHelper.mVScrollbarBox &amp;&amp;</span>
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :       styles.mVertical == NS_STYLE_OVERFLOW_SCROLL) {</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :      nsSize vSize = mHelper.mVScrollbarBox-&gt;GetXULMinSize(aState);</span>
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :      AddMargin(mHelper.mVScrollbarBox, vSize);</span>
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :      min.width += vSize.width;</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :      if (min.height &lt; vSize.height)</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :         min.height = vSize.height;</span>
<span class="lineNum">    1641 </span>            :   }
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span><span class="lineCov">         56 :   if (mHelper.mHScrollbarBox &amp;&amp;</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :       styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL) {</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :      nsSize hSize = mHelper.mHScrollbarBox-&gt;GetXULMinSize(aState);</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :      AddMargin(mHelper.mHScrollbarBox, hSize);</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :      min.height += hSize.height;</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :      if (min.width &lt; hSize.width)</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         min.width = hSize.width;</span>
<span class="lineNum">    1650 </span>            :   }
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span><span class="lineCov">         56 :   AddBorderAndPadding(min);</span>
<span class="lineNum">    1653 </span>            :   bool widthSet, heightSet;
<span class="lineNum">    1654 </span><span class="lineCov">         56 :   nsIFrame::AddXULMinSize(aState, this, min, widthSet, heightSet);</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :   return min;</span>
<span class="lineNum">    1656 </span>            : }
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span>            : nsSize
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 : nsXULScrollFrame::GetXULMaxSize(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">    1660 </span>            : {
<span class="lineNum">    1661 </span><span class="lineCov">         46 :   nsSize maxSize(NS_INTRINSICSIZE, NS_INTRINSICSIZE);</span>
<span class="lineNum">    1662 </span>            : 
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :   AddBorderAndPadding(maxSize);</span>
<span class="lineNum">    1664 </span>            :   bool widthSet, heightSet;
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :   nsIFrame::AddXULMaxSize(this, maxSize, widthSet, heightSet);</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :   return maxSize;</span>
<span class="lineNum">    1667 </span>            : }
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span>            : #ifdef DEBUG_FRAME_DUMP
<span class="lineNum">    1670 </span>            : nsresult
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 : nsXULScrollFrame::GetFrameName(nsAString&amp; aResult) const</span>
<span class="lineNum">    1672 </span>            : {
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :   return MakeFrameName(NS_LITERAL_STRING(&quot;XULScroll&quot;), aResult);</span>
<span class="lineNum">    1674 </span>            : }
<span class="lineNum">    1675 </span>            : #endif
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span>            : NS_IMETHODIMP
<span class="lineNum">    1678 </span><span class="lineCov">         17 : nsXULScrollFrame::DoXULLayout(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">    1679 </span>            : {
<span class="lineNum">    1680 </span><span class="lineCov">         17 :   uint32_t flags = aState.LayoutFlags();</span>
<span class="lineNum">    1681 </span><span class="lineCov">         17 :   nsresult rv = XULLayout(aState);</span>
<span class="lineNum">    1682 </span><span class="lineCov">         34 :   aState.SetLayoutFlags(flags);</span>
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :   nsBox::DoXULLayout(aState);</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :   return rv;</span>
<span class="lineNum">    1686 </span>            : }
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 : NS_QUERYFRAME_HEAD(nsXULScrollFrame)</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(nsIScrollableFrame)</span>
<span class="lineNum">    1691 </span><span class="lineCov">          5 :   NS_QUERYFRAME_ENTRY(nsIStatefulFrame)</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :   NS_QUERYFRAME_ENTRY(nsIScrollbarMediator)</span>
<span class="lineNum">    1693 </span><span class="lineCov">         53 : NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)</span>
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span>            : //-------------------- Helper ----------------------
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span>            : #define SMOOTH_SCROLL_PREF_NAME &quot;general.smoothScroll&quot;
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : // AsyncSmoothMSDScroll has ref counting.
<span class="lineNum">    1700 </span>            : class ScrollFrameHelper::AsyncSmoothMSDScroll final : public nsARefreshObserver {
<span class="lineNum">    1701 </span>            : public:
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :   AsyncSmoothMSDScroll(const nsPoint &amp;aInitialPosition,</span>
<span class="lineNum">    1703 </span>            :                        const nsPoint &amp;aInitialDestination,
<span class="lineNum">    1704 </span>            :                        const nsSize &amp;aInitialVelocity,
<span class="lineNum">    1705 </span>            :                        const nsRect &amp;aRange,
<span class="lineNum">    1706 </span>            :                        const mozilla::TimeStamp &amp;aStartTime,
<span class="lineNum">    1707 </span>            :                        nsPresContext* aPresContext)
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :     : mXAxisModel(aInitialPosition.x, aInitialDestination.x,</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                   aInitialVelocity.width,</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :                   gfxPrefs::ScrollBehaviorSpringConstant(),</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :                   gfxPrefs::ScrollBehaviorDampingRatio())</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :     , mYAxisModel(aInitialPosition.y, aInitialDestination.y,</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :                   aInitialVelocity.height,</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                   gfxPrefs::ScrollBehaviorSpringConstant(),</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :                   gfxPrefs::ScrollBehaviorDampingRatio())</span>
<span class="lineNum">    1716 </span>            :     , mRange(aRange)
<span class="lineNum">    1717 </span>            :     , mLastRefreshTime(aStartTime)
<span class="lineNum">    1718 </span>            :     , mCallee(nullptr)
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :     , mOneDevicePixelInAppUnits(aPresContext-&gt;DevPixelsToAppUnits(1))</span>
<span class="lineNum">    1720 </span>            :   {
<span class="lineNum">    1721 </span>            :     Telemetry::SetHistogramRecordingEnabled(
<span class="lineNum">    1722 </span><span class="lineNoCov">          0 :       Telemetry::FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS, true);</span>
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :   NS_INLINE_DECL_REFCOUNTING(AsyncSmoothMSDScroll, override)</span>
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :   nsSize GetVelocity() {</span>
<span class="lineNum">    1728 </span>            :     // In nscoords per second
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     return nsSize(mXAxisModel.GetVelocity(), mYAxisModel.GetVelocity());</span>
<span class="lineNum">    1730 </span>            :   }
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :   nsPoint GetPosition() {</span>
<span class="lineNum">    1733 </span>            :     // In nscoords
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     return nsPoint(NSToCoordRound(mXAxisModel.GetPosition()), NSToCoordRound(mYAxisModel.GetPosition()));</span>
<span class="lineNum">    1735 </span>            :   }
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :   void SetDestination(const nsPoint &amp;aDestination) {</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :     mXAxisModel.SetDestination(static_cast&lt;int32_t&gt;(aDestination.x));</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :     mYAxisModel.SetDestination(static_cast&lt;int32_t&gt;(aDestination.y));</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            :   void SetRange(const nsRect &amp;aRange)
<span class="lineNum">    1743 </span>            :   {
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     mRange = aRange;</span>
<span class="lineNum">    1745 </span>            :   }
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :   nsRect GetRange()
<span class="lineNum">    1748 </span>            :   {
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :     return mRange;</span>
<span class="lineNum">    1750 </span>            :   }
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :   void Simulate(const TimeDuration&amp; aDeltaTime)</span>
<span class="lineNum">    1753 </span>            :   {
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :     mXAxisModel.Simulate(aDeltaTime);</span>
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :     mYAxisModel.Simulate(aDeltaTime);</span>
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :     nsPoint desired = GetPosition();</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     nsPoint clamped = mRange.ClampPoint(desired);</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :     if(desired.x != clamped.x) {</span>
<span class="lineNum">    1760 </span>            :       // The scroll has hit the &quot;wall&quot; at the left or right edge of the allowed
<span class="lineNum">    1761 </span>            :       // scroll range.
<span class="lineNum">    1762 </span>            :       // Absorb the impact to avoid bounceback effect.
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :       mXAxisModel.SetVelocity(0.0);</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :       mXAxisModel.SetPosition(clamped.x);</span>
<span class="lineNum">    1765 </span>            :     }
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     if(desired.y != clamped.y) {</span>
<span class="lineNum">    1768 </span>            :       // The scroll has hit the &quot;wall&quot; at the left or right edge of the allowed
<span class="lineNum">    1769 </span>            :       // scroll range.
<span class="lineNum">    1770 </span>            :       // Absorb the impact to avoid bounceback effect.
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :       mYAxisModel.SetVelocity(0.0);</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :       mYAxisModel.SetPosition(clamped.y);</span>
<span class="lineNum">    1773 </span>            :     }
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :   bool IsFinished()</span>
<span class="lineNum">    1777 </span>            :   {
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :     return mXAxisModel.IsFinished(mOneDevicePixelInAppUnits) &amp;&amp;</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :            mYAxisModel.IsFinished(mOneDevicePixelInAppUnits);</span>
<span class="lineNum">    1780 </span>            :   }
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :   virtual void WillRefresh(mozilla::TimeStamp aTime) override {</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :     mozilla::TimeDuration deltaTime = aTime - mLastRefreshTime;</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     mLastRefreshTime = aTime;</span>
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :     // The callback may release &quot;this&quot;.
<span class="lineNum">    1787 </span>            :     // We don't access members after returning, so no need for KungFuDeathGrip.
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :     ScrollFrameHelper::AsyncSmoothMSDScrollCallback(mCallee, deltaTime);</span>
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :   /*
<span class="lineNum">    1792 </span>            :    * Set a refresh observer for smooth scroll iterations (and start observing).
<span class="lineNum">    1793 </span>            :    * Should be used at most once during the lifetime of this object.
<span class="lineNum">    1794 </span>            :    * Return value: true on success, false otherwise.
<span class="lineNum">    1795 </span>            :    */
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :   bool SetRefreshObserver(ScrollFrameHelper *aCallee) {</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :     NS_ASSERTION(aCallee &amp;&amp; !mCallee, &quot;AsyncSmoothMSDScroll::SetRefreshObserver - Invalid usage.&quot;);</span>
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :     if (!RefreshDriver(aCallee)-&gt;AddRefreshObserver(this, FlushType::Style)) {</span>
<span class="lineNum">    1800 </span>            :       return false;
<span class="lineNum">    1801 </span>            :     }
<span class="lineNum">    1802 </span>            : 
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :     mCallee = aCallee;</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1805 </span>            :   }
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            : private:
<span class="lineNum">    1808 </span>            :   // Private destructor, to discourage deletion outside of Release():
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :   ~AsyncSmoothMSDScroll() {</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :     RemoveObserver();</span>
<span class="lineNum">    1811 </span>            :     Telemetry::SetHistogramRecordingEnabled(
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :       Telemetry::FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS, false);</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            :   nsRefreshDriver* RefreshDriver(ScrollFrameHelper* aCallee) {
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :     return aCallee-&gt;mOuter-&gt;PresContext()-&gt;RefreshDriver();</span>
<span class="lineNum">    1817 </span>            :   }
<span class="lineNum">    1818 </span>            : 
<span class="lineNum">    1819 </span>            :   /*
<span class="lineNum">    1820 </span>            :    * The refresh driver doesn't hold a reference to its observers,
<span class="lineNum">    1821 </span>            :    *   so releasing this object can (and is) used to remove the observer on DTOR.
<span class="lineNum">    1822 </span>            :    * Currently, this object is released once the scrolling ends.
<span class="lineNum">    1823 </span>            :    */
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :   void RemoveObserver() {</span>
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :     if (mCallee) {</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :       RefreshDriver(mCallee)-&gt;RemoveRefreshObserver(this, FlushType::Style);</span>
<span class="lineNum">    1827 </span>            :     }
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            :   mozilla::layers::AxisPhysicsMSDModel mXAxisModel, mYAxisModel;
<span class="lineNum">    1831 </span>            :   nsRect mRange;
<span class="lineNum">    1832 </span>            :   mozilla::TimeStamp mLastRefreshTime;
<span class="lineNum">    1833 </span>            :   ScrollFrameHelper *mCallee;
<span class="lineNum">    1834 </span>            :   nscoord mOneDevicePixelInAppUnits;
<span class="lineNum">    1835 </span>            : };
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            : // AsyncScroll has ref counting.
<span class="lineNum">    1838 </span>            : class ScrollFrameHelper::AsyncScroll final
<span class="lineNum">    1839 </span>            :   : public nsARefreshObserver
<span class="lineNum">    1840 </span>            : {
<span class="lineNum">    1841 </span>            : public:
<span class="lineNum">    1842 </span>            :   typedef mozilla::TimeStamp TimeStamp;
<span class="lineNum">    1843 </span>            :   typedef mozilla::TimeDuration TimeDuration;
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :   explicit AsyncScroll()</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     : mCallee(nullptr)</span>
<span class="lineNum">    1847 </span>            :   {
<span class="lineNum">    1848 </span>            :     Telemetry::SetHistogramRecordingEnabled(
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :       Telemetry::FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS, true);</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            : private:
<span class="lineNum">    1853 </span>            :   // Private destructor, to discourage deletion outside of Release():
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :   ~AsyncScroll() {</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :     RemoveObserver();</span>
<span class="lineNum">    1856 </span>            :     Telemetry::SetHistogramRecordingEnabled(
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :       Telemetry::FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS, false);</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1859 </span>            : 
<span class="lineNum">    1860 </span>            : public:
<span class="lineNum">    1861 </span>            :   void InitSmoothScroll(TimeStamp aTime,
<span class="lineNum">    1862 </span>            :                         nsPoint aInitialPosition, nsPoint aDestination,
<span class="lineNum">    1863 </span>            :                         nsAtom *aOrigin, const nsRect&amp; aRange,
<span class="lineNum">    1864 </span>            :                         const nsSize&amp; aCurrentVelocity);
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :   void Init(const nsRect&amp; aRange) {</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     mAnimationPhysics = nullptr;</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :     mRange = aRange;</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :   bool IsSmoothScroll() { return mAnimationPhysics != nullptr; }</span>
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :   bool IsFinished(const TimeStamp&amp; aTime) const {</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(mAnimationPhysics);</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :     return mAnimationPhysics-&gt;IsFinished(aTime);</span>
<span class="lineNum">    1875 </span>            :   }
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :   nsPoint PositionAt(const TimeStamp&amp; aTime) const {</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(mAnimationPhysics);</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     return mAnimationPhysics-&gt;PositionAt(aTime);</span>
<span class="lineNum">    1880 </span>            :   }
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :   nsSize VelocityAt(const TimeStamp&amp; aTime) const {</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     MOZ_RELEASE_ASSERT(mAnimationPhysics);</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     return mAnimationPhysics-&gt;VelocityAt(aTime);</span>
<span class="lineNum">    1885 </span>            :   }
<span class="lineNum">    1886 </span>            : 
<span class="lineNum">    1887 </span>            :   // Most recent scroll origin.
<span class="lineNum">    1888 </span>            :   RefPtr&lt;nsAtom&gt; mOrigin;
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span>            :   // Allowed destination positions around mDestination
<span class="lineNum">    1891 </span>            :   nsRect mRange;
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            : private:
<span class="lineNum">    1894 </span>            :   void InitPreferences(TimeStamp aTime, nsAtom *aOrigin);
<span class="lineNum">    1895 </span>            : 
<span class="lineNum">    1896 </span>            :   UniquePtr&lt;ScrollAnimationPhysics&gt; mAnimationPhysics;
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            : // The next section is observer/callback management
<span class="lineNum">    1899 </span>            : // Bodies of WillRefresh and RefreshDriver contain ScrollFrameHelper specific code.
<span class="lineNum">    1900 </span>            : public:
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :   NS_INLINE_DECL_REFCOUNTING(AsyncScroll, override)</span>
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span>            :   /*
<span class="lineNum">    1904 </span>            :    * Set a refresh observer for smooth scroll iterations (and start observing).
<span class="lineNum">    1905 </span>            :    * Should be used at most once during the lifetime of this object.
<span class="lineNum">    1906 </span>            :    * Return value: true on success, false otherwise.
<span class="lineNum">    1907 </span>            :    */
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :   bool SetRefreshObserver(ScrollFrameHelper *aCallee) {</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :     NS_ASSERTION(aCallee &amp;&amp; !mCallee, &quot;AsyncScroll::SetRefreshObserver - Invalid usage.&quot;);</span>
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :     if (!RefreshDriver(aCallee)-&gt;AddRefreshObserver(this, FlushType::Style)) {</span>
<span class="lineNum">    1912 </span>            :       return false;
<span class="lineNum">    1913 </span>            :     }
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     mCallee = aCallee;</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     APZCCallbackHelper::SuppressDisplayport(true, mCallee-&gt;mOuter-&gt;PresShell());</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1918 </span>            :   }
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :   virtual void WillRefresh(mozilla::TimeStamp aTime) override {</span>
<span class="lineNum">    1921 </span>            :     // The callback may release &quot;this&quot;.
<span class="lineNum">    1922 </span>            :     // We don't access members after returning, so no need for KungFuDeathGrip.
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :     ScrollFrameHelper::AsyncScrollCallback(mCallee, aTime);</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span>            : private:
<span class="lineNum">    1927 </span>            :   ScrollFrameHelper *mCallee;
<span class="lineNum">    1928 </span>            : 
<span class="lineNum">    1929 </span>            :   nsRefreshDriver* RefreshDriver(ScrollFrameHelper* aCallee) {
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :     return aCallee-&gt;mOuter-&gt;PresContext()-&gt;RefreshDriver();</span>
<span class="lineNum">    1931 </span>            :   }
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span>            :   /*
<span class="lineNum">    1934 </span>            :    * The refresh driver doesn't hold a reference to its observers,
<span class="lineNum">    1935 </span>            :    *   so releasing this object can (and is) used to remove the observer on DTOR.
<span class="lineNum">    1936 </span>            :    * Currently, this object is released once the scrolling ends.
<span class="lineNum">    1937 </span>            :    */
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :   void RemoveObserver() {</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :     if (mCallee) {</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :       RefreshDriver(mCallee)-&gt;RemoveRefreshObserver(this, FlushType::Style);</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :       APZCCallbackHelper::SuppressDisplayport(false, mCallee-&gt;mOuter-&gt;PresShell());</span>
<span class="lineNum">    1942 </span>            :     }
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    1944 </span>            : };
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span>            : /*
<span class="lineNum">    1947 </span>            :  * Calculate duration, possibly dynamically according to events rate and event origin.
<span class="lineNum">    1948 </span>            :  * (also maintain previous timestamps - which are only used here).
<span class="lineNum">    1949 </span>            :  */
<span class="lineNum">    1950 </span>            : static ScrollAnimationBezierPhysicsSettings
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 : ComputeBezierAnimationSettingsForOrigin(nsAtom *aOrigin)</span>
<span class="lineNum">    1952 </span>            : {
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :   int32_t minMS = 0;</span>
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :   int32_t maxMS = 0;</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :   bool isOriginSmoothnessEnabled = false;</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :   double intervalRatio = 1;</span>
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span>            :   // Default values for all preferences are defined in all.js
<span class="lineNum">    1959 </span>            :   static const int32_t kDefaultMinMS = 150, kDefaultMaxMS = 150;
<span class="lineNum">    1960 </span>            :   static const bool kDefaultIsSmoothEnabled = true;
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :   nsAutoCString originName;</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :   aOrigin-&gt;ToUTF8String(originName);</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :   nsAutoCString prefBase = NS_LITERAL_CSTRING(&quot;general.smoothScroll.&quot;) + originName;</span>
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :   isOriginSmoothnessEnabled = Preferences::GetBool(prefBase.get(), kDefaultIsSmoothEnabled);</span>
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :   if (isOriginSmoothnessEnabled) {</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :     nsAutoCString prefMin = prefBase + NS_LITERAL_CSTRING(&quot;.durationMinMS&quot;);</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :     nsAutoCString prefMax = prefBase + NS_LITERAL_CSTRING(&quot;.durationMaxMS&quot;);</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :     minMS = Preferences::GetInt(prefMin.get(), kDefaultMinMS);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     maxMS = Preferences::GetInt(prefMax.get(), kDefaultMaxMS);</span>
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span>            :     static const int32_t kSmoothScrollMaxAllowedAnimationDurationMS = 10000;
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :     maxMS = clamped(maxMS, 0, kSmoothScrollMaxAllowedAnimationDurationMS);</span>
<span class="lineNum">    1975 </span><span class="lineNoCov">          0 :     minMS = clamped(minMS, 0, maxMS);</span>
<span class="lineNum">    1976 </span>            :   }
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span>            :   // Keep the animation duration longer than the average event intervals
<span class="lineNum">    1979 </span>            :   //   (to &quot;connect&quot; consecutive scroll animations before the scroll comes to a stop).
<span class="lineNum">    1980 </span>            :   static const double kDefaultDurationToIntervalRatio = 2; // Duplicated at all.js
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :   intervalRatio = Preferences::GetInt(&quot;general.smoothScroll.durationToIntervalRatio&quot;,</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :                                                       kDefaultDurationToIntervalRatio * 100) / 100.0;</span>
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span>            :   // Duration should be at least as long as the intervals -&gt; ratio is at least 1
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :   intervalRatio = std::max(1.0, intervalRatio);</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :   return ScrollAnimationBezierPhysicsSettings { minMS, maxMS, intervalRatio };</span>
<span class="lineNum">    1988 </span>            : }
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            : void
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 : ScrollFrameHelper::AsyncScroll::InitSmoothScroll(TimeStamp aTime,</span>
<span class="lineNum">    1992 </span>            :                                                  nsPoint aInitialPosition,
<span class="lineNum">    1993 </span>            :                                                  nsPoint aDestination,
<span class="lineNum">    1994 </span>            :                                                  nsAtom *aOrigin,
<span class="lineNum">    1995 </span>            :                                                  const nsRect&amp; aRange,
<span class="lineNum">    1996 </span>            :                                                  const nsSize&amp; aCurrentVelocity)
<span class="lineNum">    1997 </span>            : {
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :   if (!aOrigin || aOrigin == nsGkAtoms::restore) {</span>
<span class="lineNum">    1999 </span>            :     // We don't have special prefs for &quot;restore&quot;, just treat it as &quot;other&quot;.
<span class="lineNum">    2000 </span>            :     // &quot;restore&quot; scrolls are (for now) always instant anyway so unless something
<span class="lineNum">    2001 </span>            :     // changes we should never have aOrigin == nsGkAtoms::restore here.
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :     aOrigin = nsGkAtoms::other;</span>
<span class="lineNum">    2003 </span>            :   }
<span class="lineNum">    2004 </span>            :   // Likewise we should never get APZ-triggered scrolls here, and if that changes
<span class="lineNum">    2005 </span>            :   // something is likely broken somewhere.
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aOrigin != nsGkAtoms::apz);</span>
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span>            :   // Read preferences only on first iteration or for a different event origin.
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :   if (!mAnimationPhysics || aOrigin != mOrigin) {</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :     mOrigin = aOrigin;</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :     if (gfxPrefs::SmoothScrollMSDPhysicsEnabled()) {</span>
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :       mAnimationPhysics = MakeUnique&lt;ScrollAnimationMSDPhysics&gt;(aInitialPosition);</span>
<span class="lineNum">    2013 </span>            :     } else {
<span class="lineNum">    2014 </span>            :       ScrollAnimationBezierPhysicsSettings settings =
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :         ComputeBezierAnimationSettingsForOrigin(mOrigin);</span>
<span class="lineNum">    2016 </span>            :       mAnimationPhysics =
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :         MakeUnique&lt;ScrollAnimationBezierPhysics&gt;(aInitialPosition, settings);</span>
<span class="lineNum">    2018 </span>            :     }
<span class="lineNum">    2019 </span>            :   }
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :   mRange = aRange;</span>
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :   mAnimationPhysics-&gt;Update(aTime, aDestination, aCurrentVelocity);</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span>            : bool
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 : ScrollFrameHelper::IsSmoothScrollingEnabled()</span>
<span class="lineNum">    2028 </span>            : {
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :   return Preferences::GetBool(SMOOTH_SCROLL_PREF_NAME, false);</span>
<span class="lineNum">    2030 </span>            : }
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span>            : class ScrollFrameActivityTracker final : public nsExpirationTracker&lt;ScrollFrameHelper,4&gt; {
<span class="lineNum">    2033 </span>            : public:
<span class="lineNum">    2034 </span>            :   // Wait for 3-4s between scrolls before we remove our layers.
<span class="lineNum">    2035 </span>            :   // That's 4 generations of 1s each.
<span class="lineNum">    2036 </span>            :   enum { TIMEOUT_MS = 1000 };
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :   explicit ScrollFrameActivityTracker(nsIEventTarget* aEventTarget)</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :     : nsExpirationTracker&lt;ScrollFrameHelper,4&gt;(TIMEOUT_MS,</span>
<span class="lineNum">    2039 </span>            :                                                &quot;ScrollFrameActivityTracker&quot;,
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :                                                aEventTarget)</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :   {}</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :   ~ScrollFrameActivityTracker() {</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :     AgeAllGenerations();</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :   virtual void NotifyExpired(ScrollFrameHelper *aObject) override {</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :     RemoveObject(aObject);</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :     aObject-&gt;MarkNotRecentlyScrolled();</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">    2050 </span>            : };
<span class="lineNum">    2051 </span>            : 
<span class="lineNum">    2052 </span>            : static ScrollFrameActivityTracker *gScrollFrameActivityTracker = nullptr;
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span>            : // There are situations when a scroll frame is destroyed and then re-created
<span class="lineNum">    2055 </span>            : // for the same content element. In this case we want to increment the scroll
<span class="lineNum">    2056 </span>            : // generation between the old and new scrollframes. If the new one knew about
<span class="lineNum">    2057 </span>            : // the old one then it could steal the old generation counter and increment it
<span class="lineNum">    2058 </span>            : // but it doesn't have that reference so instead we use a static global to
<span class="lineNum">    2059 </span>            : // ensure the new one gets a fresh value.
<span class="lineNum">    2060 </span>            : static uint32_t sScrollGenerationCounter = 0;
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span><span class="lineCov">         30 : ScrollFrameHelper::ScrollFrameHelper(nsContainerFrame* aOuter,</span>
<span class="lineNum">    2063 </span><span class="lineCov">         30 :                                              bool aIsRoot)</span>
<span class="lineNum">    2064 </span>            :   : mHScrollbarBox(nullptr)
<span class="lineNum">    2065 </span>            :   , mVScrollbarBox(nullptr)
<span class="lineNum">    2066 </span>            :   , mScrolledFrame(nullptr)
<span class="lineNum">    2067 </span>            :   , mScrollCornerBox(nullptr)
<span class="lineNum">    2068 </span>            :   , mResizerBox(nullptr)
<span class="lineNum">    2069 </span>            :   , mOuter(aOuter)
<span class="lineNum">    2070 </span>            :   , mReferenceFrameDuringPainting(nullptr)
<span class="lineNum">    2071 </span>            :   , mAsyncScroll(nullptr)
<span class="lineNum">    2072 </span>            :   , mAsyncSmoothMSDScroll(nullptr)
<span class="lineNum">    2073 </span>            :   , mLastScrollOrigin(nsGkAtoms::other)
<span class="lineNum">    2074 </span>            :   , mAllowScrollOriginDowngrade(false)
<span class="lineNum">    2075 </span>            :   , mLastSmoothScrollOrigin(nullptr)
<span class="lineNum">    2076 </span><span class="lineCov">         30 :   , mScrollGeneration(++sScrollGenerationCounter)</span>
<span class="lineNum">    2077 </span>            :   , mDestination(0, 0)
<span class="lineNum">    2078 </span>            :   , mScrollPosAtLastPaint(0, 0)
<span class="lineNum">    2079 </span>            :   , mRestorePos(-1, -1)
<span class="lineNum">    2080 </span>            :   , mLastPos(-1, -1)
<span class="lineNum">    2081 </span>            :   , mScrollPosForLayerPixelAlignment(-1, -1)
<span class="lineNum">    2082 </span>            :   , mLastUpdateFramesPos(-1, -1)
<span class="lineNum">    2083 </span>            :   , mHadDisplayPortAtLastFrameUpdate(false)
<span class="lineNum">    2084 </span>            :   , mDisplayPortAtLastFrameUpdate()
<span class="lineNum">    2085 </span>            :   , mNeverHasVerticalScrollbar(false)
<span class="lineNum">    2086 </span>            :   , mNeverHasHorizontalScrollbar(false)
<span class="lineNum">    2087 </span>            :   , mHasVerticalScrollbar(false)
<span class="lineNum">    2088 </span>            :   , mHasHorizontalScrollbar(false)
<span class="lineNum">    2089 </span>            :   , mFrameIsUpdatingScrollbar(false)
<span class="lineNum">    2090 </span>            :   , mDidHistoryRestore(false)
<span class="lineNum">    2091 </span>            :   , mIsRoot(aIsRoot)
<span class="lineNum">    2092 </span>            :   , mClipAllDescendants(aIsRoot)
<span class="lineNum">    2093 </span>            :   , mSuppressScrollbarUpdate(false)
<span class="lineNum">    2094 </span>            :   , mSkippedScrollbarLayout(false)
<span class="lineNum">    2095 </span>            :   , mHadNonInitialReflow(false)
<span class="lineNum">    2096 </span>            :   , mHorizontalOverflow(false)
<span class="lineNum">    2097 </span>            :   , mVerticalOverflow(false)
<span class="lineNum">    2098 </span>            :   , mPostedReflowCallback(false)
<span class="lineNum">    2099 </span>            :   , mMayHaveDirtyFixedChildren(false)
<span class="lineNum">    2100 </span>            :   , mUpdateScrollbarAttributes(false)
<span class="lineNum">    2101 </span>            :   , mHasBeenScrolledRecently(false)
<span class="lineNum">    2102 </span>            :   , mCollapsedResizer(false)
<span class="lineNum">    2103 </span>            :   , mWillBuildScrollableLayer(false)
<span class="lineNum">    2104 </span>            :   , mIsScrollParent(false)
<span class="lineNum">    2105 </span>            :   , mIsScrollableLayerInRootContainer(false)
<span class="lineNum">    2106 </span>            :   , mHasBeenScrolled(false)
<span class="lineNum">    2107 </span>            :   , mIgnoreMomentumScroll(false)
<span class="lineNum">    2108 </span>            :   , mTransformingByAPZ(false)
<span class="lineNum">    2109 </span>            :   , mScrollableByAPZ(false)
<span class="lineNum">    2110 </span>            :   , mZoomableByAPZ(false)
<span class="lineNum">    2111 </span>            :   , mHasOutOfFlowContentInsideFilter(false)
<span class="lineNum">    2112 </span>            :   , mSuppressScrollbarRepaints(false)
<span class="lineNum">    2113 </span><span class="lineCov">        750 :   , mVelocityQueue(aOuter-&gt;PresContext())</span>
<span class="lineNum">    2114 </span>            : {
<span class="lineNum">    2115 </span><span class="lineCov">         30 :   if (LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0) {</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     mScrollbarActivity = new ScrollbarActivity(do_QueryFrame(aOuter));</span>
<span class="lineNum">    2117 </span>            :   }
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :   EnsureFrameVisPrefsCached();</span>
<span class="lineNum">    2120 </span>            : 
<span class="lineNum">    2121 </span><span class="lineCov">         62 :   if (IsAlwaysActive() &amp;&amp;</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :       gfxPrefs::LayersTilesEnabled() &amp;&amp;</span>
<span class="lineNum">    2123 </span><span class="lineCov">         30 :       !nsLayoutUtils::UsesAsyncScrolling(mOuter) &amp;&amp;</span>
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :       mOuter-&gt;GetContent()) {</span>
<span class="lineNum">    2125 </span>            :     // If we have tiling but no APZ, then set a 0-margin display port on
<span class="lineNum">    2126 </span>            :     // active scroll containers so that we paint by whole tile increments
<span class="lineNum">    2127 </span>            :     // when scrolling.
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :     nsLayoutUtils::SetDisplayPortMargins(mOuter-&gt;GetContent(),</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :                                          mOuter-&gt;PresShell(),</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :                                          ScreenMargin(),</span>
<span class="lineNum">    2131 </span>            :                                          0,
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :                                          nsLayoutUtils::RepaintMode::DoNotRepaint);</span>
<span class="lineNum">    2133 </span>            :     nsLayoutUtils::SetZeroMarginDisplayPortOnAsyncScrollableAncestors(
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :         mOuter, nsLayoutUtils::RepaintMode::DoNotRepaint);</span>
<span class="lineNum">    2135 </span>            :   }
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span><span class="lineCov">         30 : }</span>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 : ScrollFrameHelper::~ScrollFrameHelper()</span>
<span class="lineNum">    2140 </span>            : {
<span class="lineNum">    2141 </span><span class="lineCov">          4 :   if (mScrollEvent) {</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :     mScrollEvent-&gt;Revoke();</span>
<span class="lineNum">    2143 </span>            :   }
<span class="lineNum">    2144 </span><span class="lineCov">          4 :   if (mScrollEndEvent) {</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :     mScrollEndEvent-&gt;Revoke();</span>
<span class="lineNum">    2146 </span>            :   }
<span class="lineNum">    2147 </span><span class="lineCov">          2 : }</span>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span>            : /*
<span class="lineNum">    2150 </span>            :  * Callback function from AsyncSmoothMSDScroll, used in ScrollFrameHelper::ScrollTo
<span class="lineNum">    2151 </span>            :  */
<span class="lineNum">    2152 </span>            : void
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 : ScrollFrameHelper::AsyncSmoothMSDScrollCallback(ScrollFrameHelper* aInstance,</span>
<span class="lineNum">    2154 </span>            :                                                 mozilla::TimeDuration aDeltaTime)
<span class="lineNum">    2155 </span>            : {
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aInstance != nullptr, &quot;aInstance must not be null&quot;);</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :   NS_ASSERTION(aInstance-&gt;mAsyncSmoothMSDScroll,</span>
<span class="lineNum">    2158 </span>            :     &quot;Did not expect AsyncSmoothMSDScrollCallback without an active MSD scroll.&quot;);
<span class="lineNum">    2159 </span>            : 
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :   nsRect range = aInstance-&gt;mAsyncSmoothMSDScroll-&gt;GetRange();</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :   aInstance-&gt;mAsyncSmoothMSDScroll-&gt;Simulate(aDeltaTime);</span>
<span class="lineNum">    2162 </span>            : 
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :   if (!aInstance-&gt;mAsyncSmoothMSDScroll-&gt;IsFinished()) {</span>
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :     nsPoint destination = aInstance-&gt;mAsyncSmoothMSDScroll-&gt;GetPosition();</span>
<span class="lineNum">    2165 </span>            :     // Allow this scroll operation to land on any pixel boundary within the
<span class="lineNum">    2166 </span>            :     // allowed scroll range for this frame.
<span class="lineNum">    2167 </span>            :     // If the MSD is under-dampened or the destination is changed rapidly,
<span class="lineNum">    2168 </span>            :     // it is expected (and desired) that the scrolling may overshoot.
<span class="lineNum">    2169 </span>            :     nsRect intermediateRange =
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :       nsRect(destination, nsSize()).UnionEdges(range);</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :     aInstance-&gt;ScrollToImpl(destination, intermediateRange);</span>
<span class="lineNum">    2172 </span>            :     // 'aInstance' might be destroyed here
<span class="lineNum">    2173 </span>            :     return;
<span class="lineNum">    2174 </span>            :   }
<span class="lineNum">    2175 </span>            : 
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :   aInstance-&gt;CompleteAsyncScroll(range);</span>
<span class="lineNum">    2177 </span>            : }
<span class="lineNum">    2178 </span>            : 
<span class="lineNum">    2179 </span>            : /*
<span class="lineNum">    2180 </span>            :  * Callback function from AsyncScroll, used in ScrollFrameHelper::ScrollTo
<span class="lineNum">    2181 </span>            :  */
<span class="lineNum">    2182 </span>            : void
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 : ScrollFrameHelper::AsyncScrollCallback(ScrollFrameHelper* aInstance,</span>
<span class="lineNum">    2184 </span>            :                                        mozilla::TimeStamp aTime)
<span class="lineNum">    2185 </span>            : {
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aInstance != nullptr, &quot;aInstance must not be null&quot;);</span>
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aInstance-&gt;mAsyncScroll,</span>
<span class="lineNum">    2188 </span>            :     &quot;Did not expect AsyncScrollCallback without an active async scroll.&quot;);
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :   if (!aInstance || !aInstance-&gt;mAsyncScroll) {</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :     return;  // XXX wallpaper bug 1107353 for now.</span>
<span class="lineNum">    2192 </span>            :   }
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :   nsRect range = aInstance-&gt;mAsyncScroll-&gt;mRange;</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :   if (aInstance-&gt;mAsyncScroll-&gt;IsSmoothScroll()) {</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :     if (!aInstance-&gt;mAsyncScroll-&gt;IsFinished(aTime)) {</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :       nsPoint destination = aInstance-&gt;mAsyncScroll-&gt;PositionAt(aTime);</span>
<span class="lineNum">    2198 </span>            :       // Allow this scroll operation to land on any pixel boundary between the
<span class="lineNum">    2199 </span>            :       // current position and the final allowed range.  (We don't want
<span class="lineNum">    2200 </span>            :       // intermediate steps to be more constrained than the final step!)
<span class="lineNum">    2201 </span>            :       nsRect intermediateRange =
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :         nsRect(aInstance-&gt;GetScrollPosition(), nsSize()).UnionEdges(range);</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :       aInstance-&gt;ScrollToImpl(destination, intermediateRange);</span>
<span class="lineNum">    2204 </span>            :       // 'aInstance' might be destroyed here
<span class="lineNum">    2205 </span>            :       return;
<span class="lineNum">    2206 </span>            :     }
<span class="lineNum">    2207 </span>            :   }
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :   aInstance-&gt;CompleteAsyncScroll(range);</span>
<span class="lineNum">    2210 </span>            : }
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span>            : void
<span class="lineNum">    2213 </span><span class="lineNoCov">          0 : ScrollFrameHelper::CompleteAsyncScroll(const nsRect &amp;aRange, nsAtom* aOrigin)</span>
<span class="lineNum">    2214 </span>            : {
<span class="lineNum">    2215 </span>            :   // Apply desired destination range since this is the last step of scrolling.
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :   mAsyncSmoothMSDScroll = nullptr;</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :   mAsyncScroll = nullptr;</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :   AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :   ScrollToImpl(mDestination, aRange, aOrigin);</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :   if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2222 </span>            :   }
<span class="lineNum">    2223 </span>            :   // We are done scrolling, set our destination to wherever we actually ended
<span class="lineNum">    2224 </span>            :   // up scrolling to.
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :   mDestination = GetScrollPosition();</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :   PostScrollEndEvent();</span>
<span class="lineNum">    2227 </span>            : }
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            : bool
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 : ScrollFrameHelper::HasPluginFrames()</span>
<span class="lineNum">    2231 </span>            : {
<span class="lineNum">    2232 </span>            : #if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :   if (XRE_IsContentProcess()) {</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :     nsPresContext* presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :     nsRootPresContext* rootPresContext = presContext-&gt;GetRootPresContext();</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :     if (!rootPresContext || rootPresContext-&gt;NeedToComputePluginGeometryUpdates()) {</span>
<span class="lineNum">    2237 </span>            :       return true;
<span class="lineNum">    2238 </span>            :     }
<span class="lineNum">    2239 </span>            :   }
<span class="lineNum">    2240 </span>            : #endif
<span class="lineNum">    2241 </span>            :   return false;
<span class="lineNum">    2242 </span>            : }
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            : bool
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 : ScrollFrameHelper::HasBgAttachmentLocal() const</span>
<span class="lineNum">    2246 </span>            : {
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :   const nsStyleBackground* bg = mOuter-&gt;StyleBackground();</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :   return bg-&gt;HasLocalBackground();</span>
<span class="lineNum">    2249 </span>            : }
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            : void
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollToCSSPixels(const CSSIntPoint&amp; aScrollPosition,</span>
<span class="lineNum">    2253 </span>            :                                      nsIScrollableFrame::ScrollMode aMode)
<span class="lineNum">    2254 </span>            : {
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :   nsPoint current = GetScrollPosition();</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :   CSSIntPoint currentCSSPixels = GetScrollPositionCSSPixels();</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :   nsPoint pt = CSSPoint::ToAppUnits(aScrollPosition);</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :   nscoord halfPixel = nsPresContext::CSSPixelsToAppUnits(0.5f);</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :   nsRect range(pt.x - halfPixel, pt.y - halfPixel, 2*halfPixel - 1, 2*halfPixel - 1);</span>
<span class="lineNum">    2260 </span>            :   // XXX I don't think the following blocks are needed anymore, now that
<span class="lineNum">    2261 </span>            :   // ScrollToImpl simply tries to scroll an integer number of layer
<span class="lineNum">    2262 </span>            :   // pixels from the current position
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :   if (currentCSSPixels.x == aScrollPosition.x) {</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :     pt.x = current.x;</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :     range.x = pt.x;</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :     range.width = 0;</span>
<span class="lineNum">    2267 </span>            :   }
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :   if (currentCSSPixels.y == aScrollPosition.y) {</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :     pt.y = current.y;</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :     range.y = pt.y;</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :     range.height = 0;</span>
<span class="lineNum">    2272 </span>            :   }
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :   ScrollTo(pt, aMode, &amp;range);</span>
<span class="lineNum">    2274 </span>            :   // 'this' might be destroyed here
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            : void
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollToCSSPixelsApproximate(const CSSPoint&amp; aScrollPosition,</span>
<span class="lineNum">    2279 </span>            :                                                 nsAtom *aOrigin)
<span class="lineNum">    2280 </span>            : {
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :   nsPoint pt = CSSPoint::ToAppUnits(aScrollPosition);</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :   nscoord halfRange = nsPresContext::CSSPixelsToAppUnits(1000);</span>
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :   nsRect range(pt.x - halfRange, pt.y - halfRange, 2*halfRange - 1, 2*halfRange - 1);</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :   ScrollToWithOrigin(pt, nsIScrollableFrame::INSTANT, aOrigin, &amp;range);</span>
<span class="lineNum">    2285 </span>            :   // 'this' might be destroyed here
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span>            : CSSIntPoint
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetScrollPositionCSSPixels()</span>
<span class="lineNum">    2290 </span>            : {
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :   return CSSIntPoint::FromAppUnitsRounded(GetScrollPosition());</span>
<span class="lineNum">    2292 </span>            : }
<span class="lineNum">    2293 </span>            : 
<span class="lineNum">    2294 </span>            : /*
<span class="lineNum">    2295 </span>            :  * this method wraps calls to ScrollToImpl(), either in one shot or incrementally,
<span class="lineNum">    2296 </span>            :  *  based on the setting of the smoothness scroll pref
<span class="lineNum">    2297 </span>            :  */
<span class="lineNum">    2298 </span>            : void
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollToWithOrigin(nsPoint aScrollPosition,</span>
<span class="lineNum">    2300 </span>            :                                           nsIScrollableFrame::ScrollMode aMode,
<span class="lineNum">    2301 </span>            :                                           nsAtom *aOrigin,
<span class="lineNum">    2302 </span>            :                                           const nsRect* aRange,
<span class="lineNum">    2303 </span>            :                                           nsIScrollbarMediator::ScrollSnapMode aSnap)
<span class="lineNum">    2304 </span>            : {
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :   if (aOrigin != nsGkAtoms::restore) {</span>
<span class="lineNum">    2306 </span>            :     // If we're doing a non-restore scroll, we don't want to later
<span class="lineNum">    2307 </span>            :     // override it by restoring our saved scroll position.
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :     mRestorePos.x = mRestorePos.y = -1;</span>
<span class="lineNum">    2309 </span>            :   }
<span class="lineNum">    2310 </span>            : 
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :   if (aSnap == nsIScrollableFrame::ENABLE_SNAP) {</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :     GetSnapPointForDestination(nsIScrollableFrame::DEVICE_PIXELS,</span>
<span class="lineNum">    2313 </span>            :                                mDestination,
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :                                aScrollPosition);</span>
<span class="lineNum">    2315 </span>            :   }
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :   nsRect scrollRange = GetScrollRangeForClamping();</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :   mDestination = scrollRange.ClampPoint(aScrollPosition);</span>
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :   if (mDestination != aScrollPosition &amp;&amp; aOrigin == nsGkAtoms::restore &amp;&amp;</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :       GetPageLoadingState() != LoadingState::Loading) {</span>
<span class="lineNum">    2321 </span>            :     // If we're doing a restore but the scroll position is clamped, promote
<span class="lineNum">    2322 </span>            :     // the origin from one that APZ can clobber to one that it can't clobber.
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :     aOrigin = nsGkAtoms::other;</span>
<span class="lineNum">    2324 </span>            :   }
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :   nsRect range = aRange ? *aRange : nsRect(aScrollPosition, nsSize(0, 0));</span>
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :   if (aMode != nsIScrollableFrame::SMOOTH_MSD) {</span>
<span class="lineNum">    2329 </span>            :     // If we get a non-smooth-scroll, reset the cached APZ scroll destination,
<span class="lineNum">    2330 </span>            :     // so that we know to process the next smooth-scroll destined for APZ.
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :     mApzSmoothScrollDestination = Nothing();</span>
<span class="lineNum">    2332 </span>            :   }
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :   if (aMode == nsIScrollableFrame::INSTANT) {</span>
<span class="lineNum">    2335 </span>            :     // Asynchronous scrolling is not allowed, so we'll kill any existing
<span class="lineNum">    2336 </span>            :     // async-scrolling process and do an instant scroll.
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :     CompleteAsyncScroll(range, aOrigin);</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2339 </span>            :   }
<span class="lineNum">    2340 </span>            : 
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :   TimeStamp now = presContext-&gt;RefreshDriver()-&gt;IsTestControllingRefreshesEnabled()</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :                 ? presContext-&gt;RefreshDriver()-&gt;MostRecentRefresh()</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :                 : TimeStamp::Now();</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :   bool isSmoothScroll = (aMode == nsIScrollableFrame::SMOOTH) &amp;&amp;</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :                           IsSmoothScrollingEnabled();</span>
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :   nsSize currentVelocity(0, 0);</span>
<span class="lineNum">    2349 </span>            : 
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :   if (gfxPrefs::ScrollBehaviorEnabled()) {</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :     if (aMode == nsIScrollableFrame::SMOOTH_MSD) {</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :       mIgnoreMomentumScroll = true;</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :       if (!mAsyncSmoothMSDScroll) {</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :         nsPoint sv = mVelocityQueue.GetVelocity();</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :         currentVelocity.width = sv.x;</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :         currentVelocity.height = sv.y;</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :         if (mAsyncScroll) {</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :           if (mAsyncScroll-&gt;IsSmoothScroll()) {</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :             currentVelocity = mAsyncScroll-&gt;VelocityAt(now);</span>
<span class="lineNum">    2360 </span>            :           }
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :           mAsyncScroll = nullptr;</span>
<span class="lineNum">    2362 </span>            :         }
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :         if (nsLayoutUtils::AsyncPanZoomEnabled(mOuter) &amp;&amp; WantAsyncScroll()) {</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :           if (mApzSmoothScrollDestination == Some(mDestination) &amp;&amp;</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :               mScrollGeneration == sScrollGenerationCounter) {</span>
<span class="lineNum">    2367 </span>            :             // If we already sent APZ a smooth-scroll request to this
<span class="lineNum">    2368 </span>            :             // destination with this generation (i.e. it was the last request
<span class="lineNum">    2369 </span>            :             // we sent), then don't send another one because it is redundant.
<span class="lineNum">    2370 </span>            :             // This is to avoid a scenario where pages do repeated scrollBy
<span class="lineNum">    2371 </span>            :             // calls, incrementing the generation counter, and blocking APZ from
<span class="lineNum">    2372 </span>            :             // syncing the scroll offset back to the main thread.
<span class="lineNum">    2373 </span>            :             // Note that if we get two smooth-scroll requests to the same
<span class="lineNum">    2374 </span>            :             // destination with some other scroll in between,
<span class="lineNum">    2375 </span>            :             // mApzSmoothScrollDestination will get reset to Nothing() and so
<span class="lineNum">    2376 </span>            :             // we shouldn't have the problem where this check discards a
<span class="lineNum">    2377 </span>            :             // legitimate smooth-scroll.
<span class="lineNum">    2378 </span>            :             // Note: if there are two separate scrollframes both getting smooth
<span class="lineNum">    2379 </span>            :             // scrolled at the same time, sScrollGenerationCounter can get
<span class="lineNum">    2380 </span>            :             // incremented and this early-exit won't get taken. Bug 1231177 is
<span class="lineNum">    2381 </span>            :             // on file for this.
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2383 </span>            :           }
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            :           // The animation will be handled in the compositor, pass the
<span class="lineNum">    2386 </span>            :           // information needed to start the animation and skip the main-thread
<span class="lineNum">    2387 </span>            :           // animation for this scroll.
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :           mLastSmoothScrollOrigin = aOrigin;</span>
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :           mApzSmoothScrollDestination = Some(mDestination);</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :           mScrollGeneration = ++sScrollGenerationCounter;</span>
<span class="lineNum">    2391 </span>            : 
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :           if (!nsLayoutUtils::HasDisplayPort(mOuter-&gt;GetContent())) {</span>
<span class="lineNum">    2393 </span>            :             // If this frame doesn't have a displayport then there won't be an
<span class="lineNum">    2394 </span>            :             // APZC instance for it and so there won't be anything to process
<span class="lineNum">    2395 </span>            :             // this smooth scroll request. We should set a displayport on this
<span class="lineNum">    2396 </span>            :             // frame to force an APZC which can handle the request.
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :             nsLayoutUtils::CalculateAndSetDisplayPortMargins(</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :               mOuter-&gt;GetScrollTargetFrame(),</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :               nsLayoutUtils::RepaintMode::DoNotRepaint);</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :             nsIFrame* frame = do_QueryFrame(mOuter-&gt;GetScrollTargetFrame());</span>
<span class="lineNum">    2401 </span>            :             nsLayoutUtils::SetZeroMarginDisplayPortOnAsyncScrollableAncestors(
<span class="lineNum">    2402 </span>            :               frame,
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :               nsLayoutUtils::RepaintMode::DoNotRepaint);</span>
<span class="lineNum">    2404 </span>            :           }
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span>            :           // Schedule a paint to ensure that the frame metrics get updated on
<span class="lineNum">    2407 </span>            :           // the compositor thread.
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :           mOuter-&gt;SchedulePaint();</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    2410 </span>            :         }
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            :         mAsyncSmoothMSDScroll =
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :           new AsyncSmoothMSDScroll(GetScrollPosition(), mDestination,</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :                                    currentVelocity, GetScrollRangeForClamping(),</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :                                    now, presContext);</span>
<span class="lineNum">    2416 </span>            : 
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :         if (!mAsyncSmoothMSDScroll-&gt;SetRefreshObserver(this)) {</span>
<span class="lineNum">    2418 </span>            :           // Observer setup failed. Scroll the normal way.
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :           CompleteAsyncScroll(range, aOrigin);</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    2421 </span>            :         }
<span class="lineNum">    2422 </span>            :       } else {
<span class="lineNum">    2423 </span>            :         // A previous smooth MSD scroll is still in progress, so we just need to
<span class="lineNum">    2424 </span>            :         // update its range and destination.
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :         mAsyncSmoothMSDScroll-&gt;SetRange(GetScrollRangeForClamping());</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :         mAsyncSmoothMSDScroll-&gt;SetDestination(mDestination);</span>
<span class="lineNum">    2427 </span>            :       }
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span>            :       return;
<span class="lineNum">    2430 </span>            :     } else {
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :       if (mAsyncSmoothMSDScroll) {</span>
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :         currentVelocity = mAsyncSmoothMSDScroll-&gt;GetVelocity();</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :         mAsyncSmoothMSDScroll = nullptr;</span>
<span class="lineNum">    2434 </span>            :       }
<span class="lineNum">    2435 </span>            :     }
<span class="lineNum">    2436 </span>            :   }
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :   if (!mAsyncScroll) {</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :     mAsyncScroll = new AsyncScroll();</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :     if (!mAsyncScroll-&gt;SetRefreshObserver(this)) {</span>
<span class="lineNum">    2441 </span>            :       // Observer setup failed. Scroll the normal way.
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :       CompleteAsyncScroll(range, aOrigin);</span>
<span class="lineNum">    2443 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    2444 </span>            :     }
<span class="lineNum">    2445 </span>            :   }
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :   if (isSmoothScroll) {</span>
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :     mAsyncScroll-&gt;InitSmoothScroll(now, GetScrollPosition(), mDestination,</span>
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :                                    aOrigin, range, currentVelocity);</span>
<span class="lineNum">    2450 </span>            :   } else {
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :     mAsyncScroll-&gt;Init(range);</span>
<span class="lineNum">    2452 </span>            :   }
<span class="lineNum">    2453 </span>            : }
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span>            : // We can't use nsContainerFrame::PositionChildViews here because
<span class="lineNum">    2456 </span>            : // we don't want to invalidate views that have moved.
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 : static void AdjustViews(nsIFrame* aFrame)</span>
<span class="lineNum">    2458 </span>            : {
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :   nsView* view = aFrame-&gt;GetView();</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :   if (view) {</span>
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :     nsPoint pt;</span>
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :     aFrame-&gt;GetParent()-&gt;GetClosestView(&amp;pt);</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :     pt += aFrame-&gt;GetPosition();</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :     view-&gt;SetPosition(pt.x, pt.y);</span>
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span>            :     return;
<span class="lineNum">    2467 </span>            :   }
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :   if (!(aFrame-&gt;GetStateBits() &amp; NS_FRAME_HAS_CHILD_WITH_VIEW)) {</span>
<span class="lineNum">    2470 </span>            :     return;
<span class="lineNum">    2471 </span>            :   }
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span>            :   // Call AdjustViews recursively for all child frames except the popup list as
<span class="lineNum">    2474 </span>            :   // the views for popups are not scrolled.
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :   nsIFrame::ChildListIterator lists(aFrame);</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :   for (; !lists.IsDone(); lists.Next()) {</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :     if (lists.CurrentID() == nsIFrame::kPopupList) {</span>
<span class="lineNum">    2478 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    2479 </span>            :     }
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :     nsFrameList::Enumerator childFrames(lists.CurrentList());</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :     for (; !childFrames.AtEnd(); childFrames.Next()) {</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :       AdjustViews(childFrames.get());</span>
<span class="lineNum">    2483 </span>            :     }
<span class="lineNum">    2484 </span>            :   }
<span class="lineNum">    2485 </span>            : }
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 : bool ScrollFrameHelper::IsIgnoringViewportClipping() const</span>
<span class="lineNum">    2488 </span>            : {
<span class="lineNum">    2489 </span><span class="lineCov">        107 :   if (!mIsRoot)</span>
<span class="lineNum">    2490 </span>            :     return false;
<span class="lineNum">    2491 </span>            :   nsSubDocumentFrame* subdocFrame = static_cast&lt;nsSubDocumentFrame*&gt;
<span class="lineNum">    2492 </span><span class="lineCov">         64 :     (nsLayoutUtils::GetCrossDocParentFrame(mOuter-&gt;PresShell()-&gt;GetRootFrame()));</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :   return subdocFrame &amp;&amp; !subdocFrame-&gt;ShouldClipSubdocument();</span>
<span class="lineNum">    2494 </span>            : }
<span class="lineNum">    2495 </span>            : 
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::MarkScrollbarsDirtyForReflow() const</span>
<span class="lineNum">    2497 </span>            : {
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :   nsIPresShell* presShell = mOuter-&gt;PresShell();</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :   if (mVScrollbarBox) {</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :     presShell-&gt;FrameNeedsReflow(mVScrollbarBox, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    2501 </span>            :   }
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :   if (mHScrollbarBox) {</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :     presShell-&gt;FrameNeedsReflow(mHScrollbarBox, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);</span>
<span class="lineNum">    2504 </span>            :   }
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2506 </span>            : 
<span class="lineNum">    2507 </span><span class="lineCov">         56 : bool ScrollFrameHelper::ShouldClampScrollPosition() const</span>
<span class="lineNum">    2508 </span>            : {
<span class="lineNum">    2509 </span><span class="lineCov">         56 :   if (!mIsRoot)</span>
<span class="lineNum">    2510 </span>            :     return true;
<span class="lineNum">    2511 </span>            :   nsSubDocumentFrame* subdocFrame = static_cast&lt;nsSubDocumentFrame*&gt;
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :     (nsLayoutUtils::GetCrossDocParentFrame(mOuter-&gt;PresShell()-&gt;GetRootFrame()));</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :   return !subdocFrame || subdocFrame-&gt;ShouldClampScrollPosition();</span>
<span class="lineNum">    2514 </span>            : }
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span><span class="lineCov">        160 : bool ScrollFrameHelper::IsAlwaysActive() const</span>
<span class="lineNum">    2517 </span>            : {
<span class="lineNum">    2518 </span><span class="lineCov">        160 :   if (nsDisplayItem::ForceActiveLayers()) {</span>
<span class="lineNum">    2519 </span>            :     return true;
<span class="lineNum">    2520 </span>            :   }
<span class="lineNum">    2521 </span>            : 
<span class="lineNum">    2522 </span>            :   // Unless this is the root scrollframe for a non-chrome document
<span class="lineNum">    2523 </span>            :   // which is the direct child of a chrome document, we default to not
<span class="lineNum">    2524 </span>            :   // being &quot;active&quot;.
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :   if (!(mIsRoot &amp;&amp; mOuter-&gt;PresContext()-&gt;IsRootContentDocument())) {</span>
<span class="lineNum">    2526 </span>            :      return false;
<span class="lineNum">    2527 </span>            :   }
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span>            :   // If we have scrolled before, then we should stay active.
<span class="lineNum">    2530 </span><span class="lineCov">          2 :   if (mHasBeenScrolled) {</span>
<span class="lineNum">    2531 </span>            :     return true;
<span class="lineNum">    2532 </span>            :   }
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span>            :   // If we're overflow:hidden, then start as inactive until
<span class="lineNum">    2535 </span>            :   // we get scrolled manually.
<span class="lineNum">    2536 </span><span class="lineCov">          4 :   ScrollbarStyles styles = GetScrollbarStylesFromFrame();</span>
<span class="lineNum">    2537 </span><span class="lineCov">          4 :   return (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN &amp;&amp;</span>
<span class="lineNum">    2538 </span><span class="lineCov">          2 :           styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN);</span>
<span class="lineNum">    2539 </span>            : }
<span class="lineNum">    2540 </span>            : 
<span class="lineNum">    2541 </span>            : static void
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 : RemoveDisplayPortCallback(nsITimer* aTimer, void* aClosure)</span>
<span class="lineNum">    2543 </span>            : {
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :   ScrollFrameHelper* helper = static_cast&lt;ScrollFrameHelper*&gt;(aClosure);</span>
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span>            :   // This function only ever gets called from the expiry timer, so it must
<span class="lineNum">    2547 </span>            :   // be non-null here. Set it to null here so that we don't keep resetting
<span class="lineNum">    2548 </span>            :   // it unnecessarily in MarkRecentlyScrolled().
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(helper-&gt;mDisplayPortExpiryTimer);</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :   helper-&gt;mDisplayPortExpiryTimer = nullptr;</span>
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :   if (!helper-&gt;AllowDisplayPortExpiration() || helper-&gt;mIsScrollParent) {</span>
<span class="lineNum">    2553 </span>            :     // If this is a scroll parent for some other scrollable frame, don't
<span class="lineNum">    2554 </span>            :     // expire the displayport because it would break scroll handoff. Once the
<span class="lineNum">    2555 </span>            :     // descendant scrollframes have their displayports expired, they will
<span class="lineNum">    2556 </span>            :     // trigger the displayport expiration on this scrollframe as well, and
<span class="lineNum">    2557 </span>            :     // mIsScrollParent will presumably be false when that kicks in.
<span class="lineNum">    2558 </span>            :     return;
<span class="lineNum">    2559 </span>            :   }
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span>            :   // Remove the displayport from this scrollframe if it's been a while
<span class="lineNum">    2562 </span>            :   // since it's scrolled, except if it needs to be always active. Note that
<span class="lineNum">    2563 </span>            :   // there is one scrollframe that doesn't fall under this general rule, and
<span class="lineNum">    2564 </span>            :   // that is the one that nsLayoutUtils::MaybeCreateDisplayPort decides to put
<span class="lineNum">    2565 </span>            :   // a displayport on (i.e. the first scrollframe that WantAsyncScroll()s).
<span class="lineNum">    2566 </span>            :   // If that scrollframe is this one, we remove the displayport anyway, and
<span class="lineNum">    2567 </span>            :   // as part of the next paint MaybeCreateDisplayPort will put another
<span class="lineNum">    2568 </span>            :   // displayport back on it. Although the displayport will &quot;flicker&quot; off and
<span class="lineNum">    2569 </span>            :   // back on, the layer itself should never disappear, because this all
<span class="lineNum">    2570 </span>            :   // happens between actual painting. If the displayport is reset to a
<span class="lineNum">    2571 </span>            :   // different position that's ok; this scrollframe hasn't been scrolled
<span class="lineNum">    2572 </span>            :   // recently and so the reset should be correct.
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :   nsLayoutUtils::RemoveDisplayPort(helper-&gt;mOuter-&gt;GetContent());</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :   nsLayoutUtils::ExpireDisplayPortOnAsyncScrollableAncestor(helper-&gt;mOuter);</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :   helper-&gt;mOuter-&gt;SchedulePaint();</span>
<span class="lineNum">    2576 </span>            :   // Be conservative and unflag this this scrollframe as being scrollable by
<span class="lineNum">    2577 </span>            :   // APZ. If it is still scrollable this will get flipped back soon enough.
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :   helper-&gt;mScrollableByAPZ = false;</span>
<span class="lineNum">    2579 </span>            : }
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::MarkNotRecentlyScrolled()</span>
<span class="lineNum">    2582 </span>            : {
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :   if (!mHasBeenScrolledRecently)</span>
<span class="lineNum">    2584 </span>            :     return;
<span class="lineNum">    2585 </span>            : 
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :   mHasBeenScrolledRecently = false;</span>
<span class="lineNum">    2587 </span><span class="lineNoCov">          0 :   mOuter-&gt;SchedulePaint();</span>
<span class="lineNum">    2588 </span>            : }
<span class="lineNum">    2589 </span>            : 
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::MarkRecentlyScrolled()</span>
<span class="lineNum">    2591 </span>            : {
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :   mHasBeenScrolledRecently = true;</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :   if (IsAlwaysActive()) {</span>
<span class="lineNum">    2594 </span>            :     return;
<span class="lineNum">    2595 </span>            :   }
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :   if (mActivityExpirationState.IsTracked()) {</span>
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :     gScrollFrameActivityTracker-&gt;MarkUsed(this);</span>
<span class="lineNum">    2599 </span>            :   } else {
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :     if (!gScrollFrameActivityTracker) {</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :       gScrollFrameActivityTracker = new ScrollFrameActivityTracker(</span>
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :         SystemGroup::EventTargetFor(TaskCategory::Other));</span>
<span class="lineNum">    2603 </span>            :     }
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :     gScrollFrameActivityTracker-&gt;AddObject(this);</span>
<span class="lineNum">    2605 </span>            :   }
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span>            :   // If we just scrolled and there's a displayport expiry timer in place,
<span class="lineNum">    2608 </span>            :   // reset the timer.
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :   ResetDisplayPortExpiryTimer();</span>
<span class="lineNum">    2610 </span>            : }
<span class="lineNum">    2611 </span>            : 
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::ResetDisplayPortExpiryTimer()</span>
<span class="lineNum">    2613 </span>            : {
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :   if (mDisplayPortExpiryTimer) {</span>
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :     mDisplayPortExpiryTimer-&gt;InitWithNamedFuncCallback(</span>
<span class="lineNum">    2616 </span>            :       RemoveDisplayPortCallback,
<span class="lineNum">    2617 </span>            :       this,
<span class="lineNum">    2618 </span>            :       gfxPrefs::APZDisplayPortExpiryTime(),
<span class="lineNum">    2619 </span>            :       nsITimer::TYPE_ONE_SHOT,
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 :       &quot;ScrollFrameHelper::ResetDisplayPortExpiryTimer&quot;);</span>
<span class="lineNum">    2621 </span>            :   }
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 : bool ScrollFrameHelper::AllowDisplayPortExpiration()</span>
<span class="lineNum">    2625 </span>            : {
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 :   if (IsAlwaysActive()) {</span>
<span class="lineNum">    2627 </span>            :     return false;
<span class="lineNum">    2628 </span>            :   }
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 :   if (mIsRoot &amp;&amp; mOuter-&gt;PresContext()-&gt;IsRoot()) {</span>
<span class="lineNum">    2630 </span>            :     return false;
<span class="lineNum">    2631 </span>            :   }
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">    2633 </span>            : }
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::TriggerDisplayPortExpiration()</span>
<span class="lineNum">    2636 </span>            : {
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :   if (!AllowDisplayPortExpiration()) {</span>
<span class="lineNum">    2638 </span>            :     return;
<span class="lineNum">    2639 </span>            :   }
<span class="lineNum">    2640 </span>            : 
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :   if (!gfxPrefs::APZDisplayPortExpiryTime()) {</span>
<span class="lineNum">    2642 </span>            :     // a zero time disables the expiry
<span class="lineNum">    2643 </span>            :     return;
<span class="lineNum">    2644 </span>            :   }
<span class="lineNum">    2645 </span>            : 
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :   if (!mDisplayPortExpiryTimer) {</span>
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :     mDisplayPortExpiryTimer = NS_NewTimer();</span>
<span class="lineNum">    2648 </span>            :   }
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :   ResetDisplayPortExpiryTimer();</span>
<span class="lineNum">    2650 </span>            : }
<span class="lineNum">    2651 </span>            : 
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::ScrollVisual()</span>
<span class="lineNum">    2653 </span>            : {
<span class="lineNum">    2654 </span>            :   // Mark this frame as having been scrolled. If this is the root
<span class="lineNum">    2655 </span>            :   // scroll frame of a content document, then IsAlwaysActive()
<span class="lineNum">    2656 </span>            :   // will return true from now on and MarkNotRecentlyScrolled() won't
<span class="lineNum">    2657 </span>            :   // have any effect.
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :   mHasBeenScrolled = true;</span>
<span class="lineNum">    2659 </span>            : 
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :   AdjustViews(mScrolledFrame);</span>
<span class="lineNum">    2661 </span>            :   // We need to call this after fixing up the view positions
<span class="lineNum">    2662 </span>            :   // to be consistent with the frame hierarchy.
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :   MarkRecentlyScrolled();</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2665 </span>            : 
<span class="lineNum">    2666 </span>            : /**
<span class="lineNum">    2667 </span>            :  * Clamp desired scroll position aDesired and range [aDestLower, aDestUpper]
<span class="lineNum">    2668 </span>            :  * to [aBoundLower, aBoundUpper] and then select the appunit value from among
<span class="lineNum">    2669 </span>            :  * aBoundLower, aBoundUpper and those such that (aDesired - aCurrent) *
<span class="lineNum">    2670 </span>            :  * aRes/aAppUnitsPerPixel is an integer (or as close as we can get
<span class="lineNum">    2671 </span>            :  * modulo rounding to appunits) that is in [aDestLower, aDestUpper] and
<span class="lineNum">    2672 </span>            :  * closest to aDesired.  If no such value exists, return the nearest in
<span class="lineNum">    2673 </span>            :  * [aDestLower, aDestUpper].
<span class="lineNum">    2674 </span>            :  */
<span class="lineNum">    2675 </span>            : static nscoord
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 : ClampAndAlignWithPixels(nscoord aDesired,</span>
<span class="lineNum">    2677 </span>            :                         nscoord aBoundLower, nscoord aBoundUpper,
<span class="lineNum">    2678 </span>            :                         nscoord aDestLower, nscoord aDestUpper,
<span class="lineNum">    2679 </span>            :                         nscoord aAppUnitsPerPixel, double aRes,
<span class="lineNum">    2680 </span>            :                         nscoord aCurrent)
<span class="lineNum">    2681 </span>            : {
<span class="lineNum">    2682 </span>            :   // Intersect scroll range with allowed range, by clamping the ends
<span class="lineNum">    2683 </span>            :   // of aRange to be within bounds
<span class="lineNum">    2684 </span><span class="lineCov">        112 :   nscoord destLower = clamped(aDestLower, aBoundLower, aBoundUpper);</span>
<span class="lineNum">    2685 </span><span class="lineCov">        112 :   nscoord destUpper = clamped(aDestUpper, aBoundLower, aBoundUpper);</span>
<span class="lineNum">    2686 </span>            : 
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :   nscoord desired = clamped(aDesired, destLower, destUpper);</span>
<span class="lineNum">    2688 </span>            : 
<span class="lineNum">    2689 </span><span class="lineCov">        112 :   double currentLayerVal = (aRes*aCurrent)/aAppUnitsPerPixel;</span>
<span class="lineNum">    2690 </span><span class="lineCov">        112 :   double desiredLayerVal = (aRes*desired)/aAppUnitsPerPixel;</span>
<span class="lineNum">    2691 </span><span class="lineCov">        112 :   double delta = desiredLayerVal - currentLayerVal;</span>
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :   double nearestLayerVal = NS_round(delta) + currentLayerVal;</span>
<span class="lineNum">    2693 </span>            : 
<span class="lineNum">    2694 </span>            :   // Convert back from PaintedLayer space to appunits relative to the top-left
<span class="lineNum">    2695 </span>            :   // of the scrolled frame.
<span class="lineNum">    2696 </span>            :   nscoord aligned =
<span class="lineNum">    2697 </span><span class="lineCov">        112 :     NSToCoordRoundWithClamp(nearestLayerVal*aAppUnitsPerPixel/aRes);</span>
<span class="lineNum">    2698 </span>            : 
<span class="lineNum">    2699 </span>            :   // Use a bound if it is within the allowed range and closer to desired than
<span class="lineNum">    2700 </span>            :   // the nearest pixel-aligned value.
<span class="lineNum">    2701 </span><span class="lineCov">        220 :   if (aBoundUpper == destUpper &amp;&amp;</span>
<span class="lineNum">    2702 </span><span class="lineCov">        108 :       static_cast&lt;decltype(Abs(desired))&gt;(aBoundUpper - desired) &lt;</span>
<span class="lineNum">    2703 </span><span class="lineCov">        216 :       Abs(desired - aligned))</span>
<span class="lineNum">    2704 </span>            :     return aBoundUpper;
<span class="lineNum">    2705 </span>            : 
<span class="lineNum">    2706 </span><span class="lineCov">        224 :   if (aBoundLower == destLower &amp;&amp;</span>
<span class="lineNum">    2707 </span><span class="lineCov">        112 :       static_cast&lt;decltype(Abs(desired))&gt;(desired - aBoundLower) &lt;</span>
<span class="lineNum">    2708 </span><span class="lineCov">        224 :       Abs(aligned - desired))</span>
<span class="lineNum">    2709 </span>            :     return aBoundLower;
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            :   // Accept the nearest pixel-aligned value if it is within the allowed range.
<span class="lineNum">    2712 </span><span class="lineCov">        112 :   if (aligned &gt;= destLower &amp;&amp; aligned &lt;= destUpper)</span>
<span class="lineNum">    2713 </span>            :     return aligned;
<span class="lineNum">    2714 </span>            : 
<span class="lineNum">    2715 </span>            :   // Check if opposite pixel boundary fits into allowed range.
<span class="lineNum">    2716 </span>            :   double oppositeLayerVal =
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :     nearestLayerVal + ((nearestLayerVal &lt; desiredLayerVal) ? 1.0 : -1.0);</span>
<span class="lineNum">    2718 </span>            :   nscoord opposite =
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :     NSToCoordRoundWithClamp(oppositeLayerVal*aAppUnitsPerPixel/aRes);</span>
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :   if (opposite &gt;= destLower &amp;&amp; opposite &lt;= destUpper) {</span>
<span class="lineNum">    2721 </span>            :     return opposite;
<span class="lineNum">    2722 </span>            :   }
<span class="lineNum">    2723 </span>            : 
<span class="lineNum">    2724 </span>            :   // No alignment available.
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :   return desired;</span>
<span class="lineNum">    2726 </span>            : }
<span class="lineNum">    2727 </span>            : 
<span class="lineNum">    2728 </span>            : /**
<span class="lineNum">    2729 </span>            :  * Clamp desired scroll position aPt to aBounds and then snap
<span class="lineNum">    2730 </span>            :  * it to the same layer pixel edges as aCurrent, keeping it within aRange
<span class="lineNum">    2731 </span>            :  * during snapping. aCurrent is the current scroll position.
<span class="lineNum">    2732 </span>            :  */
<span class="lineNum">    2733 </span>            : static nsPoint
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 : ClampAndAlignWithLayerPixels(const nsPoint&amp; aPt,</span>
<span class="lineNum">    2735 </span>            :                              const nsRect&amp; aBounds,
<span class="lineNum">    2736 </span>            :                              const nsRect&amp; aRange,
<span class="lineNum">    2737 </span>            :                              const nsPoint&amp; aCurrent,
<span class="lineNum">    2738 </span>            :                              nscoord aAppUnitsPerPixel,
<span class="lineNum">    2739 </span>            :                              const gfxSize&amp; aScale)
<span class="lineNum">    2740 </span>            : {
<span class="lineNum">    2741 </span><span class="lineNoCov">          0 :   return nsPoint(ClampAndAlignWithPixels(aPt.x, aBounds.x, aBounds.XMost(),</span>
<span class="lineNum">    2742 </span>            :                                          aRange.x, aRange.XMost(),
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :                                          aAppUnitsPerPixel, aScale.width,</span>
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :                                          aCurrent.x),</span>
<span class="lineNum">    2745 </span><span class="lineCov">         56 :                  ClampAndAlignWithPixels(aPt.y, aBounds.y, aBounds.YMost(),</span>
<span class="lineNum">    2746 </span>            :                                          aRange.y, aRange.YMost(),
<span class="lineNum">    2747 </span><span class="lineCov">         56 :                                          aAppUnitsPerPixel, aScale.height,</span>
<span class="lineNum">    2748 </span><span class="lineCov">        448 :                                          aCurrent.y));</span>
<span class="lineNum">    2749 </span>            : }
<span class="lineNum">    2750 </span>            : 
<span class="lineNum">    2751 </span>            : /* static */ void
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollActivityCallback(nsITimer *aTimer, void* anInstance)</span>
<span class="lineNum">    2753 </span>            : {
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :   ScrollFrameHelper* self = static_cast&lt;ScrollFrameHelper*&gt;(anInstance);</span>
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span>            :   // Fire the synth mouse move.
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 :   self-&gt;mScrollActivityTimer-&gt;Cancel();</span>
<span class="lineNum">    2758 </span><span class="lineNoCov">          0 :   self-&gt;mScrollActivityTimer = nullptr;</span>
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :   self-&gt;mOuter-&gt;PresShell()-&gt;SynthesizeMouseMove(true);</span>
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2761 </span>            : 
<span class="lineNum">    2762 </span>            : 
<span class="lineNum">    2763 </span>            : void
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScheduleSyntheticMouseMove()</span>
<span class="lineNum">    2765 </span>            : {
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :   if (!mScrollActivityTimer) {</span>
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :     mScrollActivityTimer = NS_NewTimer(</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :       mOuter-&gt;PresContext()-&gt;Document()-&gt;EventTargetFor(TaskCategory::Other));</span>
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :     if (!mScrollActivityTimer) {</span>
<span class="lineNum">    2770 </span>            :       return;
<span class="lineNum">    2771 </span>            :     }
<span class="lineNum">    2772 </span>            :   }
<span class="lineNum">    2773 </span>            : 
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :   mScrollActivityTimer-&gt;InitWithNamedFuncCallback(</span>
<span class="lineNum">    2775 </span>            :     ScrollActivityCallback,
<span class="lineNum">    2776 </span>            :     this,
<span class="lineNum">    2777 </span>            :     100,
<span class="lineNum">    2778 </span>            :     nsITimer::TYPE_ONE_SHOT,
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :     &quot;ScrollFrameHelper::ScheduleSyntheticMouseMove&quot;);</span>
<span class="lineNum">    2780 </span>            : }
<span class="lineNum">    2781 </span>            : 
<span class="lineNum">    2782 </span>            : void
<span class="lineNum">    2783 </span><span class="lineNoCov">          0 : ScrollFrameHelper::NotifyApproximateFrameVisibilityUpdate(bool aIgnoreDisplayPort)</span>
<span class="lineNum">    2784 </span>            : {
<span class="lineNum">    2785 </span><span class="lineNoCov">          0 :   mLastUpdateFramesPos = GetScrollPosition();</span>
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :   if (aIgnoreDisplayPort) {</span>
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :     mHadDisplayPortAtLastFrameUpdate = false;</span>
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :     mDisplayPortAtLastFrameUpdate = nsRect();</span>
<span class="lineNum">    2789 </span>            :   } else {
<span class="lineNum">    2790 </span><span class="lineNoCov">          0 :     mHadDisplayPortAtLastFrameUpdate =</span>
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :       nsLayoutUtils::GetDisplayPort(mOuter-&gt;GetContent(),</span>
<span class="lineNum">    2792 </span>            :                                     &amp;mDisplayPortAtLastFrameUpdate);
<span class="lineNum">    2793 </span>            :   }
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2795 </span>            : 
<span class="lineNum">    2796 </span>            : bool
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetDisplayPortAtLastApproximateFrameVisibilityUpdate(nsRect* aDisplayPort)</span>
<span class="lineNum">    2798 </span>            : {
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :   if (mHadDisplayPortAtLastFrameUpdate) {</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     *aDisplayPort = mDisplayPortAtLastFrameUpdate;</span>
<span class="lineNum">    2801 </span>            :   }
<span class="lineNum">    2802 </span><span class="lineNoCov">          0 :   return mHadDisplayPortAtLastFrameUpdate;</span>
<span class="lineNum">    2803 </span>            : }
<span class="lineNum">    2804 </span>            : 
<span class="lineNum">    2805 </span>            : void
<span class="lineNum">    2806 </span><span class="lineCov">         56 : ScrollFrameHelper::ScrollToImpl(nsPoint aPt, const nsRect&amp; aRange, nsAtom* aOrigin)</span>
<span class="lineNum">    2807 </span>            : {
<span class="lineNum">    2808 </span><span class="lineCov">         56 :   if (aOrigin == nullptr) {</span>
<span class="lineNum">    2809 </span>            :     // If no origin was specified, we still want to set it to something that's
<span class="lineNum">    2810 </span>            :     // non-null, so that we can use nullness to distinguish if the frame was scrolled
<span class="lineNum">    2811 </span>            :     // at all. Default it to some generic placeholder.
<span class="lineNum">    2812 </span><span class="lineCov">         56 :     aOrigin = nsGkAtoms::other;</span>
<span class="lineNum">    2813 </span>            :   }
<span class="lineNum">    2814 </span>            : 
<span class="lineNum">    2815 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :   nscoord appUnitsPerDevPixel = presContext-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    2817 </span>            :   // 'scale' is our estimate of the scale factor that will be applied
<span class="lineNum">    2818 </span>            :   // when rendering the scrolled content to its own PaintedLayer.
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 :   gfxSize scale = FrameLayerBuilder::GetPaintedLayerScaleForFrame(mScrolledFrame);</span>
<span class="lineNum">    2820 </span><span class="lineCov">         56 :   nsPoint curPos = GetScrollPosition();</span>
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 :   nsPoint alignWithPos = mScrollPosForLayerPixelAlignment == nsPoint(-1,-1)</span>
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :                          ? curPos : mScrollPosForLayerPixelAlignment;</span>
<span class="lineNum">    2823 </span>            :   // Try to align aPt with curPos so they have an integer number of layer
<span class="lineNum">    2824 </span>            :   // pixels between them. This gives us the best chance of scrolling without
<span class="lineNum">    2825 </span>            :   // having to invalidate due to changes in subpixel rendering.
<span class="lineNum">    2826 </span>            :   // Note that when we actually draw into a PaintedLayer, the coordinates
<span class="lineNum">    2827 </span>            :   // that get mapped onto the layer buffer pixels are from the display list,
<span class="lineNum">    2828 </span>            :   // which are relative to the display root frame's top-left increasing down,
<span class="lineNum">    2829 </span>            :   // whereas here our coordinates are scroll positions which increase upward
<span class="lineNum">    2830 </span>            :   // and are relative to the scrollport top-left. This difference doesn't actually
<span class="lineNum">    2831 </span>            :   // matter since all we are about is that there be an integer number of
<span class="lineNum">    2832 </span>            :   // layer pixels between pt and curPos.
<span class="lineNum">    2833 </span>            :   nsPoint pt =
<span class="lineNum">    2834 </span>            :     ClampAndAlignWithLayerPixels(aPt,
<span class="lineNum">    2835 </span><span class="lineCov">        112 :                                  GetScrollRangeForClamping(),</span>
<span class="lineNum">    2836 </span>            :                                  aRange,
<span class="lineNum">    2837 </span>            :                                  alignWithPos,
<span class="lineNum">    2838 </span>            :                                  appUnitsPerDevPixel,
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :                                  scale);</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :   if (pt == curPos) {</span>
<span class="lineNum">    2841 </span><span class="lineCov">         56 :     return;</span>
<span class="lineNum">    2842 </span>            :   }
<span class="lineNum">    2843 </span>            : 
<span class="lineNum">    2844 </span><span class="lineNoCov">          0 :   bool needFrameVisibilityUpdate = mLastUpdateFramesPos == nsPoint(-1,-1);</span>
<span class="lineNum">    2845 </span>            : 
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 :   nsPoint dist(std::abs(pt.x - mLastUpdateFramesPos.x),</span>
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :                std::abs(pt.y - mLastUpdateFramesPos.y));</span>
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 :   nsSize scrollPortSize = GetScrollPositionClampingScrollPortSize();</span>
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :   nscoord horzAllowance = std::max(scrollPortSize.width / std::max(sHorzScrollFraction, 1),</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :                                    nsPresContext::AppUnitsPerCSSPixel());</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :   nscoord vertAllowance = std::max(scrollPortSize.height / std::max(sVertScrollFraction, 1),</span>
<span class="lineNum">    2852 </span><span class="lineNoCov">          0 :                                    nsPresContext::AppUnitsPerCSSPixel());</span>
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 :   if (dist.x &gt;= horzAllowance || dist.y &gt;= vertAllowance) {</span>
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :     needFrameVisibilityUpdate = true;</span>
<span class="lineNum">    2855 </span>            :   }
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span>            :   // notify the listeners.
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mListeners.Length(); i++) {</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :     mListeners[i]-&gt;ScrollPositionWillChange(pt.x, pt.y);</span>
<span class="lineNum">    2860 </span>            :   }
<span class="lineNum">    2861 </span>            : 
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :   nsRect oldDisplayPort;</span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   nsIContent* content = mOuter-&gt;GetContent();</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :   nsLayoutUtils::GetHighResolutionDisplayPort(content, &amp;oldDisplayPort);</span>
<span class="lineNum">    2865 </span><span class="lineNoCov">          0 :   oldDisplayPort.MoveBy(-mScrolledFrame-&gt;GetPosition());</span>
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span>            :   // Update frame position for scrolling
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :   mScrolledFrame-&gt;SetPosition(mScrollPort.TopLeft() - pt);</span>
<span class="lineNum">    2869 </span>            : 
<span class="lineNum">    2870 </span>            :   // If |mLastScrollOrigin| is already set to something that can clobber APZ's
<span class="lineNum">    2871 </span>            :   // scroll offset, then we don't want to change it to something that can't.
<span class="lineNum">    2872 </span>            :   // If we allowed this, then we could end up in a state where APZ ignores
<span class="lineNum">    2873 </span>            :   // legitimate scroll offset updates because the origin has been masked by
<span class="lineNum">    2874 </span>            :   // a later change within the same refresh driver tick.
<span class="lineNum">    2875 </span>            :   bool isScrollOriginDowngrade =
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :     nsLayoutUtils::CanScrollOriginClobberApz(mLastScrollOrigin) &amp;&amp;</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :     !nsLayoutUtils::CanScrollOriginClobberApz(aOrigin);</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :   bool allowScrollOriginChange = mAllowScrollOriginDowngrade ||</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :     !isScrollOriginDowngrade;</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :   if (allowScrollOriginChange) {</span>
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :     mLastScrollOrigin = aOrigin;</span>
<span class="lineNum">    2882 </span><span class="lineNoCov">          0 :     mAllowScrollOriginDowngrade = false;</span>
<span class="lineNum">    2883 </span>            :   }
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :   mLastSmoothScrollOrigin = nullptr;</span>
<span class="lineNum">    2885 </span><span class="lineNoCov">          0 :   mScrollGeneration = ++sScrollGenerationCounter;</span>
<span class="lineNum">    2886 </span>            : 
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :   ScrollVisual();</span>
<span class="lineNum">    2888 </span>            : 
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :   bool schedulePaint = true;</span>
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :   if (nsLayoutUtils::AsyncPanZoomEnabled(mOuter) &amp;&amp;</span>
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :       !nsLayoutUtils::ShouldDisableApzForElement(content) &amp;&amp;</span>
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :       gfxPrefs::APZPaintSkipping()) {</span>
<span class="lineNum">    2893 </span>            :     // If APZ is enabled with paint-skipping, there are certain conditions in
<span class="lineNum">    2894 </span>            :     // which we can skip paints:
<span class="lineNum">    2895 </span>            :     // 1) If APZ triggered this scroll, and the tile-aligned displayport is
<span class="lineNum">    2896 </span>            :     //    unchanged.
<span class="lineNum">    2897 </span>            :     // 2) If non-APZ triggered this scroll, but we can handle it by just asking
<span class="lineNum">    2898 </span>            :     //    APZ to update the scroll position. Again we make this conditional on
<span class="lineNum">    2899 </span>            :     //    the tile-aligned displayport being unchanged.
<span class="lineNum">    2900 </span>            :     // We do the displayport check first since it's common to all scenarios,
<span class="lineNum">    2901 </span>            :     // and then if the displayport is unchanged, we check if APZ triggered,
<span class="lineNum">    2902 </span>            :     // or can handle, this scroll. If so, we set schedulePaint to false and
<span class="lineNum">    2903 </span>            :     // skip the paint.
<span class="lineNum">    2904 </span>            :     // Because of bug 1264297, we also don't do paint-skipping for elements with
<span class="lineNum">    2905 </span>            :     // perspective, because the displayport may not have captured everything
<span class="lineNum">    2906 </span>            :     // that needs to be painted. So even if the final tile-aligned displayport
<span class="lineNum">    2907 </span>            :     // is the same, we force a repaint for these elements. Bug 1254260 tracks
<span class="lineNum">    2908 </span>            :     // fixing this properly.
<span class="lineNum">    2909 </span><span class="lineNoCov">          0 :     nsRect displayPort;</span>
<span class="lineNum">    2910 </span>            :     bool usingDisplayPort =
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :       nsLayoutUtils::GetHighResolutionDisplayPort(content, &amp;displayPort);</span>
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :     displayPort.MoveBy(-mScrolledFrame-&gt;GetPosition());</span>
<span class="lineNum">    2913 </span>            : 
<span class="lineNum">    2914 </span>            :     PAINT_SKIP_LOG(&quot;New scrollpos %s usingDP %d dpEqual %d scrollableByApz %d plugins&quot;
<span class="lineNum">    2915 </span>            :         &quot;%d perspective %d bglocal %d filter %d\n&quot;,
<span class="lineNum">    2916 </span>            :         Stringify(CSSPoint::FromAppUnits(GetScrollPosition())).c_str(),
<span class="lineNum">    2917 </span>            :         usingDisplayPort, displayPort.IsEqualEdges(oldDisplayPort),
<span class="lineNum">    2918 </span>            :         mScrollableByAPZ, HasPluginFrames(), HasPerspective(),
<span class="lineNum">    2919 </span>            :         HasBgAttachmentLocal(), mHasOutOfFlowContentInsideFilter);
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :     if (usingDisplayPort &amp;&amp; displayPort.IsEqualEdges(oldDisplayPort) &amp;&amp;</span>
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :         !HasPerspective() &amp;&amp; !HasBgAttachmentLocal() &amp;&amp;</span>
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :         !mHasOutOfFlowContentInsideFilter) {</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 :       bool haveScrollLinkedEffects = content-&gt;GetComposedDoc()-&gt;HasScrollLinkedEffect();</span>
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :       bool apzDisabled = haveScrollLinkedEffects &amp;&amp; gfxPrefs::APZDisableForScrollLinkedEffects();</span>
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 :       if (!apzDisabled &amp;&amp; !HasPluginFrames()) {</span>
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :         if (LastScrollOrigin() == nsGkAtoms::apz) {</span>
<span class="lineNum">    2927 </span>            :           schedulePaint = false;
<span class="lineNum">    2928 </span>            :           PAINT_SKIP_LOG(&quot;Skipping due to APZ scroll\n&quot;);
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :         } else if (mScrollableByAPZ) {</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 :           nsIWidget* widget = presContext-&gt;GetNearestWidget();</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :           LayerManager* manager = widget ? widget-&gt;GetLayerManager() : nullptr;</span>
<span class="lineNum">    2932 </span><span class="lineNoCov">          0 :           if (manager) {</span>
<span class="lineNum">    2933 </span>            :             mozilla::layers::FrameMetrics::ViewID id;
<span class="lineNum">    2934 </span><span class="lineNoCov">          0 :             bool success = nsLayoutUtils::FindIDFor(content, &amp;id);</span>
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 :             MOZ_ASSERT(success); // we have a displayport, we better have an ID</span>
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span>            :             // Schedule an empty transaction to carry over the scroll offset update,
<span class="lineNum">    2938 </span>            :             // instead of a full transaction. This empty transaction might still get
<span class="lineNum">    2939 </span>            :             // squashed into a full transaction if something happens to trigger one.
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :             success = manager-&gt;SetPendingScrollUpdateForNextTransaction(id,</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :                 { mScrollGeneration, CSSPoint::FromAppUnits(GetScrollPosition()) });</span>
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :             if (success) {</span>
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :               schedulePaint = false;</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :               mOuter-&gt;SchedulePaint(nsIFrame::PAINT_COMPOSITE_ONLY);</span>
<span class="lineNum">    2945 </span>            :               PAINT_SKIP_LOG(&quot;Skipping due to APZ-forwarded main-thread scroll\n&quot;);
<span class="lineNum">    2946 </span>            :             } else {
<span class="lineNum">    2947 </span>            :               PAINT_SKIP_LOG(&quot;Failed to set pending scroll update on layer manager\n&quot;);
<span class="lineNum">    2948 </span>            :             }
<span class="lineNum">    2949 </span>            :           }
<span class="lineNum">    2950 </span>            :         }
<span class="lineNum">    2951 </span>            :       }
<span class="lineNum">    2952 </span>            :     }
<span class="lineNum">    2953 </span>            :   }
<span class="lineNum">    2954 </span>            : 
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :   if (schedulePaint) {</span>
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :     mOuter-&gt;SchedulePaint();</span>
<span class="lineNum">    2957 </span>            : 
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :     if (needFrameVisibilityUpdate) {</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :       presContext-&gt;PresShell()-&gt;ScheduleApproximateFrameVisibilityUpdateNow();</span>
<span class="lineNum">    2960 </span>            :     }
<span class="lineNum">    2961 </span>            :   }
<span class="lineNum">    2962 </span>            : 
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :   if (mOuter-&gt;ChildrenHavePerspective()) {</span>
<span class="lineNum">    2964 </span>            :     // The overflow areas of descendants may depend on the scroll position,
<span class="lineNum">    2965 </span>            :     // so ensure they get updated.
<span class="lineNum">    2966 </span>            : 
<span class="lineNum">    2967 </span>            :     // First we recompute the overflow areas of the transformed children
<span class="lineNum">    2968 </span>            :     // that use the perspective. FinishAndStoreOverflow only calls this
<span class="lineNum">    2969 </span>            :     // if the size changes, so we need to do it manually.
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :     mOuter-&gt;RecomputePerspectiveChildrenOverflow(mOuter);</span>
<span class="lineNum">    2971 </span>            : 
<span class="lineNum">    2972 </span>            :     // Update the overflow for the scrolled frame to take any changes from the
<span class="lineNum">    2973 </span>            :     // children into account.
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :     mScrolledFrame-&gt;UpdateOverflow();</span>
<span class="lineNum">    2975 </span>            : 
<span class="lineNum">    2976 </span>            :     // Update the overflow for the outer so that we recompute scrollbars.
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :     mOuter-&gt;UpdateOverflow();</span>
<span class="lineNum">    2978 </span>            :   }
<span class="lineNum">    2979 </span>            : 
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :   ScheduleSyntheticMouseMove();</span>
<span class="lineNum">    2981 </span>            : 
<span class="lineNum">    2982 </span>            :   { // scope the AutoScrollbarRepaintSuppression
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :     AutoScrollbarRepaintSuppression repaintSuppression(this, !schedulePaint);</span>
<span class="lineNum">    2984 </span><span class="lineNoCov">          0 :     AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :     UpdateScrollbarPosition();</span>
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :     if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    2988 </span>            :     }
<span class="lineNum">    2989 </span>            :   }
<span class="lineNum">    2990 </span>            : 
<span class="lineNum">    2991 </span>            :   presContext-&gt;RecordInteractionTime(
<span class="lineNum">    2992 </span>            :     nsPresContext::InteractionType::eScrollInteraction,
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :     TimeStamp::Now());</span>
<span class="lineNum">    2994 </span>            : 
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :   PostScrollEvent();</span>
<span class="lineNum">    2996 </span>            : 
<span class="lineNum">    2997 </span>            :   // notify the listeners.
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; mListeners.Length(); i++) {</span>
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :     mListeners[i]-&gt;ScrollPositionDidChange(pt.x, pt.y);</span>
<span class="lineNum">    3000 </span>            :   }
<span class="lineNum">    3001 </span>            : 
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIDocShell&gt; docShell = presContext-&gt;GetDocShell();</span>
<span class="lineNum">    3003 </span><span class="lineNoCov">          0 :   if (docShell) {</span>
<span class="lineNum">    3004 </span><span class="lineNoCov">          0 :     docShell-&gt;NotifyScrollObservers();</span>
<span class="lineNum">    3005 </span>            :   }
<span class="lineNum">    3006 </span>            : }
<span class="lineNum">    3007 </span>            : 
<span class="lineNum">    3008 </span>            : static Maybe&lt;int32_t&gt;
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 : MaxZIndexInList(nsDisplayList* aList, nsDisplayListBuilder* aBuilder)</span>
<span class="lineNum">    3010 </span>            : {
<span class="lineNum">    3011 </span><span class="lineNoCov">          0 :   Maybe&lt;int32_t&gt; maxZIndex = Nothing();</span>
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :   for (nsDisplayItem* item = aList-&gt;GetBottom(); item; item = item-&gt;GetAbove()) {</span>
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :     if (!maxZIndex) {</span>
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 :       maxZIndex = Some(item-&gt;ZIndex());</span>
<span class="lineNum">    3015 </span>            :     } else {
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :       maxZIndex = Some(std::max(maxZIndex.value(), item-&gt;ZIndex()));</span>
<span class="lineNum">    3017 </span>            :     }
<span class="lineNum">    3018 </span>            :   }
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :   return maxZIndex;</span>
<span class="lineNum">    3020 </span>            : }
<span class="lineNum">    3021 </span>            : 
<span class="lineNum">    3022 </span>            : template&lt;class T&gt;
<span class="lineNum">    3023 </span>            : static void
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 : AppendInternalItemToTop(const nsDisplayListSet&amp; aLists,</span>
<span class="lineNum">    3025 </span>            :                         T* aItem,
<span class="lineNum">    3026 </span>            :                         const Maybe&lt;int32_t&gt;&amp; aZIndex)
<span class="lineNum">    3027 </span>            : {
<span class="lineNum">    3028 </span><span class="lineNoCov">          0 :   if (aZIndex) {</span>
<span class="lineNum">    3029 </span><span class="lineNoCov">          0 :     aItem-&gt;SetOverrideZIndex(aZIndex.value());</span>
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :     aLists.PositionedDescendants()-&gt;AppendToTop(aItem);</span>
<span class="lineNum">    3031 </span>            :   } else {
<span class="lineNum">    3032 </span><span class="lineNoCov">          0 :     aLists.Content()-&gt;AppendToTop(aItem);</span>
<span class="lineNum">    3033 </span>            :   }
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span>            : static const uint32_t APPEND_OWN_LAYER = 0x1;
<span class="lineNum">    3037 </span>            : static const uint32_t APPEND_POSITIONED = 0x2;
<span class="lineNum">    3038 </span>            : static const uint32_t APPEND_SCROLLBAR_CONTAINER = 0x4;
<span class="lineNum">    3039 </span>            : static const uint32_t APPEND_OVERLAY = 0x8;
<span class="lineNum">    3040 </span>            : static const uint32_t APPEND_TOP = 0x10;
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span>            : static void
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 : AppendToTop(nsDisplayListBuilder* aBuilder, const nsDisplayListSet&amp; aLists,</span>
<span class="lineNum">    3044 </span>            :             nsDisplayList* aSource, nsIFrame* aSourceFrame, uint32_t aFlags)
<span class="lineNum">    3045 </span>            : {
<span class="lineNum">    3046 </span><span class="lineNoCov">          0 :   if (aSource-&gt;IsEmpty())</span>
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3048 </span>            : 
<span class="lineNum">    3049 </span>            :   nsDisplayWrapList* newItem;
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :   const ActiveScrolledRoot* asr = aBuilder-&gt;CurrentActiveScrolledRoot();</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :   if (aFlags &amp; APPEND_OWN_LAYER) {</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :     ScrollbarData scrollbarData;</span>
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :     if (aFlags &amp; APPEND_SCROLLBAR_CONTAINER) {</span>
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :       scrollbarData = ScrollbarData::CreateForScrollbarContainer(aBuilder-&gt;GetCurrentScrollbarDirection(),</span>
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :                                                                  aBuilder-&gt;GetCurrentScrollbarTarget());</span>
<span class="lineNum">    3056 </span>            :       // Direction should be set
<span class="lineNum">    3057 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(scrollbarData.mDirection.isSome());</span>
<span class="lineNum">    3058 </span>            :     }
<span class="lineNum">    3059 </span>            : 
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 :     newItem = MakeDisplayItem&lt;nsDisplayOwnLayer&gt;(aBuilder, aSourceFrame, aSource, asr, nsDisplayOwnLayerFlags::eNone, scrollbarData);</span>
<span class="lineNum">    3061 </span>            :   } else {
<span class="lineNum">    3062 </span>            :     // Build the wrap list with an index of 1, since the scrollbar frame itself might have already
<span class="lineNum">    3063 </span>            :     // built an nsDisplayWrapList.
<span class="lineNum">    3064 </span><span class="lineNoCov">          0 :     newItem = MakeDisplayItem&lt;nsDisplayWrapList&gt;(aBuilder, aSourceFrame, aSource, asr, false, 1);</span>
<span class="lineNum">    3065 </span>            :   }
<span class="lineNum">    3066 </span>            : 
<span class="lineNum">    3067 </span><span class="lineNoCov">          0 :   if (aFlags &amp; APPEND_POSITIONED) {</span>
<span class="lineNum">    3068 </span>            :     // We want overlay scrollbars to always be on top of the scrolled content,
<span class="lineNum">    3069 </span>            :     // but we don't want them to unnecessarily cover overlapping elements from
<span class="lineNum">    3070 </span>            :     // outside our scroll frame.
<span class="lineNum">    3071 </span><span class="lineNoCov">          0 :     Maybe&lt;int32_t&gt; zIndex = Nothing();</span>
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 :     if (aFlags &amp; APPEND_TOP) {</span>
<span class="lineNum">    3073 </span><span class="lineNoCov">          0 :       zIndex = Some(INT32_MAX);</span>
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :     } else if (aFlags &amp; APPEND_OVERLAY) {</span>
<span class="lineNum">    3075 </span><span class="lineNoCov">          0 :       zIndex = MaxZIndexInList(aLists.PositionedDescendants(), aBuilder);</span>
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :     } else if (aSourceFrame-&gt;StylePosition()-&gt;mZIndex.GetUnit() == eStyleUnit_Integer) {</span>
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :       zIndex = Some(aSourceFrame-&gt;StylePosition()-&gt;mZIndex.GetIntValue());</span>
<span class="lineNum">    3078 </span>            : 
<span class="lineNum">    3079 </span>            :     }
<span class="lineNum">    3080 </span><span class="lineNoCov">          0 :     AppendInternalItemToTop(aLists, newItem, zIndex);</span>
<span class="lineNum">    3081 </span>            :   } else {
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :     aLists.BorderBackground()-&gt;AppendToTop(newItem);</span>
<span class="lineNum">    3083 </span>            :   }
<span class="lineNum">    3084 </span>            : }
<span class="lineNum">    3085 </span>            : 
<span class="lineNum">    3086 </span>            : struct HoveredStateComparator
<span class="lineNum">    3087 </span>            : {
<span class="lineNum">    3088 </span><span class="lineNoCov">          0 :   static bool Hovered(const nsIFrame* aFrame)</span>
<span class="lineNum">    3089 </span>            :   {
<span class="lineNum">    3090 </span><span class="lineNoCov">          0 :       return aFrame-&gt;GetContent()-&gt;IsElement() &amp;&amp;</span>
<span class="lineNum">    3091 </span><span class="lineNoCov">          0 :              aFrame-&gt;GetContent()-&gt;AsElement()-&gt;HasAttr(kNameSpaceID_None,</span>
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 :                                                         nsGkAtoms::hover);</span>
<span class="lineNum">    3093 </span>            :   }
<span class="lineNum">    3094 </span>            : 
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 :   bool Equals(nsIFrame* A, nsIFrame* B) const {</span>
<span class="lineNum">    3096 </span><span class="lineNoCov">          0 :     return Hovered(A) == Hovered(B);</span>
<span class="lineNum">    3097 </span>            :   }
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :   bool LessThan(nsIFrame* A, nsIFrame* B) const {</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :     return !Hovered(A) &amp;&amp; Hovered(B);</span>
<span class="lineNum">    3101 </span>            :   }
<span class="lineNum">    3102 </span>            : };
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span>            : void
<span class="lineNum">    3105 </span><span class="lineNoCov">          0 : ScrollFrameHelper::AppendScrollPartsTo(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    3106 </span>            :                                        const nsDisplayListSet&amp; aLists,
<span class="lineNum">    3107 </span>            :                                        bool                    aCreateLayer,
<span class="lineNum">    3108 </span>            :                                        bool                    aPositioned)
<span class="lineNum">    3109 </span>            : {
<span class="lineNum">    3110 </span>            :   const bool overlayScrollbars =
<span class="lineNum">    3111 </span><span class="lineCov">        130 :     LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) != 0;</span>
<span class="lineNum">    3112 </span>            : 
<span class="lineNum">    3113 </span><span class="lineCov">        130 :   AutoTArray&lt;nsIFrame*, 3&gt; scrollParts;</span>
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :   for (nsIFrame* kid : mOuter-&gt;PrincipalChildList()) {</span>
<span class="lineNum">    3115 </span><span class="lineCov">        130 :     if (kid == mScrolledFrame ||</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :         (kid-&gt;IsAbsPosContainingBlock() || overlayScrollbars) != aPositioned) {</span>
<span class="lineNum">    3117 </span>            :       continue;
<span class="lineNum">    3118 </span>            :     }
<span class="lineNum">    3119 </span>            : 
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :     scrollParts.AppendElement(kid);</span>
<span class="lineNum">    3121 </span>            :   }
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :   if (scrollParts.IsEmpty()) {</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3124 </span>            :   }
<span class="lineNum">    3125 </span>            : 
<span class="lineNum">    3126 </span>            :   // We can't check will-change budget during display list building phase.
<span class="lineNum">    3127 </span>            :   // This means that we will build scroll bar layers for out of budget
<span class="lineNum">    3128 </span>            :   // will-change: scroll position.
<span class="lineNum">    3129 </span><span class="lineNoCov">          0 :   const mozilla::layers::FrameMetrics::ViewID scrollTargetId = IsMaybeScrollingActive()</span>
<span class="lineNum">    3130 </span><span class="lineNoCov">          0 :     ? nsLayoutUtils::FindOrCreateIDFor(mScrolledFrame-&gt;GetContent())</span>
<span class="lineNum">    3131 </span><span class="lineNoCov">          0 :     : mozilla::layers::FrameMetrics::NULL_SCROLL_ID;</span>
<span class="lineNum">    3132 </span>            : 
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :   scrollParts.Sort(HoveredStateComparator());</span>
<span class="lineNum">    3134 </span>            : 
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :   DisplayListClipState::AutoSaveRestore clipState(aBuilder);</span>
<span class="lineNum">    3136 </span>            :   // Don't let scrollparts extent outside our frame's border-box, if these are
<span class="lineNum">    3137 </span>            :   // viewport scrollbars. They would create layerization problems. This wouldn't
<span class="lineNum">    3138 </span>            :   // normally be an issue but themes can add overflow areas to scrollbar parts.
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :   if (mIsRoot) {</span>
<span class="lineNum">    3140 </span>            :     clipState.ClipContentDescendants(
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :         mOuter-&gt;GetRectRelativeToSelf() + aBuilder-&gt;ToReferenceFrame(mOuter));</span>
<span class="lineNum">    3142 </span>            :   }
<span class="lineNum">    3143 </span>            : 
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; scrollParts.Length(); ++i) {</span>
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :     Maybe&lt;ScrollDirection&gt; scrollDirection;</span>
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :     uint32_t appendToTopFlags = 0;</span>
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 :     if (scrollParts[i] == mVScrollbarBox) {</span>
<span class="lineNum">    3148 </span><span class="lineNoCov">          0 :       scrollDirection.emplace(ScrollDirection::eVertical);</span>
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :       appendToTopFlags |= APPEND_SCROLLBAR_CONTAINER;</span>
<span class="lineNum">    3150 </span>            :     }
<span class="lineNum">    3151 </span><span class="lineNoCov">          0 :     if (scrollParts[i] == mHScrollbarBox) {</span>
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(!scrollDirection.isSome());</span>
<span class="lineNum">    3153 </span><span class="lineNoCov">          0 :       scrollDirection.emplace(ScrollDirection::eHorizontal);</span>
<span class="lineNum">    3154 </span><span class="lineNoCov">          0 :       appendToTopFlags |= APPEND_SCROLLBAR_CONTAINER;</span>
<span class="lineNum">    3155 </span>            :     }
<span class="lineNum">    3156 </span><span class="lineNoCov">          0 :     if (scrollParts[i] == mResizerBox &amp;&amp;</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :         !HasResizer()) {</span>
<span class="lineNum">    3158 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    3159 </span>            :     }
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span>            :     // The display port doesn't necessarily include the scrollbars, so just
<span class="lineNum">    3162 </span>            :     // include all of the scrollbars if we are in a RCD-RSF. We only do
<span class="lineNum">    3163 </span>            :     // this for the root scrollframe of the root content document, which is
<span class="lineNum">    3164 </span>            :     // zoomable, and where the scrollbar sizes are bounded by the widget.
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :     const nsRect visible = mIsRoot &amp;&amp; mOuter-&gt;PresContext()-&gt;IsRootContentDocument()</span>
<span class="lineNum">    3166 </span><span class="lineNoCov">          0 :                      ? scrollParts[i]-&gt;GetVisualOverflowRectRelativeToParent()</span>
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :                      : aBuilder-&gt;GetVisibleRect();</span>
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :     if (visible.IsEmpty()) {</span>
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :       continue;</span>
<span class="lineNum">    3170 </span>            :     }
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 :     const nsRect dirty = mIsRoot &amp;&amp; mOuter-&gt;PresContext()-&gt;IsRootContentDocument()</span>
<span class="lineNum">    3172 </span><span class="lineNoCov">          0 :                      ? scrollParts[i]-&gt;GetVisualOverflowRectRelativeToParent()</span>
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :                      : aBuilder-&gt;GetDirtyRect();</span>
<span class="lineNum">    3174 </span>            : 
<span class="lineNum">    3175 </span>            :     // Always create layers for overlay scrollbars so that we don't create a
<span class="lineNum">    3176 </span>            :     // giant layer covering the whole scrollport if both scrollbars are visible.
<span class="lineNum">    3177 </span><span class="lineNoCov">          0 :     const bool isOverlayScrollbar = scrollDirection.isSome() &amp;&amp; overlayScrollbars;</span>
<span class="lineNum">    3178 </span><span class="lineNoCov">          0 :     const bool createLayer = aCreateLayer || isOverlayScrollbar ||</span>
<span class="lineNum">    3179 </span><span class="lineNoCov">          0 :                        gfxPrefs::AlwaysLayerizeScrollbarTrackTestOnly();</span>
<span class="lineNum">    3180 </span>            : 
<span class="lineNum">    3181 </span><span class="lineNoCov">          0 :     nsDisplayListCollection partList(aBuilder);</span>
<span class="lineNum">    3182 </span>            :     {
<span class="lineNum">    3183 </span>            :       nsDisplayListBuilder::AutoBuildingDisplayList
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :         buildingForChild(aBuilder, mOuter,</span>
<span class="lineNum">    3185 </span><span class="lineNoCov">          0 :                          visible, dirty, true);</span>
<span class="lineNum">    3186 </span>            : 
<span class="lineNum">    3187 </span>            :       nsDisplayListBuilder::AutoCurrentScrollbarInfoSetter
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 :         infoSetter(aBuilder, scrollTargetId, scrollDirection, createLayer);</span>
<span class="lineNum">    3189 </span><span class="lineNoCov">          0 :       mOuter-&gt;BuildDisplayListForChild(</span>
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :         aBuilder, scrollParts[i], partList,</span>
<span class="lineNum">    3191 </span><span class="lineNoCov">          0 :         nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT);</span>
<span class="lineNum">    3192 </span>            :     }
<span class="lineNum">    3193 </span>            : 
<span class="lineNum">    3194 </span><span class="lineNoCov">          0 :     if (createLayer) {</span>
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :       appendToTopFlags |= APPEND_OWN_LAYER;</span>
<span class="lineNum">    3196 </span>            :     }
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 :     if (aPositioned) {</span>
<span class="lineNum">    3198 </span><span class="lineNoCov">          0 :       appendToTopFlags |= APPEND_POSITIONED;</span>
<span class="lineNum">    3199 </span>            :     }
<span class="lineNum">    3200 </span>            : 
<span class="lineNum">    3201 </span><span class="lineNoCov">          0 :     if (isOverlayScrollbar ||</span>
<span class="lineNum">    3202 </span><span class="lineNoCov">          0 :         scrollParts[i] == mResizerBox) {</span>
<span class="lineNum">    3203 </span><span class="lineNoCov">          0 :       if (isOverlayScrollbar &amp;&amp; mIsRoot) {</span>
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 :         appendToTopFlags |= APPEND_TOP;</span>
<span class="lineNum">    3205 </span>            :       } else {
<span class="lineNum">    3206 </span><span class="lineNoCov">          0 :         appendToTopFlags |= APPEND_OVERLAY;</span>
<span class="lineNum">    3207 </span>            :         aBuilder-&gt;SetDisablePartialUpdates(true);
<span class="lineNum">    3208 </span>            :       }
<span class="lineNum">    3209 </span>            :     }
<span class="lineNum">    3210 </span>            : 
<span class="lineNum">    3211 </span>            :     {
<span class="lineNum">    3212 </span>            :       nsDisplayListBuilder::AutoBuildingDisplayList
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :         buildingForChild(aBuilder, scrollParts[i],</span>
<span class="lineNum">    3214 </span><span class="lineNoCov">          0 :                          visible + mOuter-&gt;GetOffsetTo(scrollParts[i]),</span>
<span class="lineNum">    3215 </span><span class="lineNoCov">          0 :                          dirty + mOuter-&gt;GetOffsetTo(scrollParts[i]), true);</span>
<span class="lineNum">    3216 </span>            :       nsDisplayListBuilder::AutoCurrentScrollbarInfoSetter
<span class="lineNum">    3217 </span><span class="lineNoCov">          0 :         infoSetter(aBuilder, scrollTargetId, scrollDirection, createLayer);</span>
<span class="lineNum">    3218 </span>            :       // DISPLAY_CHILD_FORCE_STACKING_CONTEXT put everything into
<span class="lineNum">    3219 </span>            :       // partList.PositionedDescendants().
<span class="lineNum">    3220 </span><span class="lineNoCov">          0 :       ::AppendToTop(aBuilder, aLists,</span>
<span class="lineNum">    3221 </span><span class="lineNoCov">          0 :                     partList.PositionedDescendants(), scrollParts[i],</span>
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :                     appendToTopFlags);</span>
<span class="lineNum">    3223 </span>            :     }
<span class="lineNum">    3224 </span>            :   }
<span class="lineNum">    3225 </span>            : }
<span class="lineNum">    3226 </span>            : 
<span class="lineNum">    3227 </span>            : /* static */ bool ScrollFrameHelper::sFrameVisPrefsCached = false;
<span class="lineNum">    3228 </span>            : /* static */ uint32_t ScrollFrameHelper::sHorzExpandScrollPort = 0;
<span class="lineNum">    3229 </span>            : /* static */ uint32_t ScrollFrameHelper::sVertExpandScrollPort = 1;
<span class="lineNum">    3230 </span>            : /* static */ int32_t ScrollFrameHelper::sHorzScrollFraction = 2;
<span class="lineNum">    3231 </span>            : /* static */ int32_t ScrollFrameHelper::sVertScrollFraction = 2;
<span class="lineNum">    3232 </span>            : 
<span class="lineNum">    3233 </span>            : /* static */ void
<span class="lineNum">    3234 </span><span class="lineCov">         30 : ScrollFrameHelper::EnsureFrameVisPrefsCached()</span>
<span class="lineNum">    3235 </span>            : {
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 :   if (!sFrameVisPrefsCached) {</span>
<span class="lineNum">    3237 </span>            :     Preferences::AddUintVarCache(&amp;sHorzExpandScrollPort,
<span class="lineNum">    3238 </span><span class="lineCov">          1 :       &quot;layout.framevisibility.numscrollportwidths&quot;, (uint32_t)0);</span>
<span class="lineNum">    3239 </span>            :     Preferences::AddUintVarCache(&amp;sVertExpandScrollPort,
<span class="lineNum">    3240 </span><span class="lineNoCov">          0 :       &quot;layout.framevisibility.numscrollportheights&quot;, 1);</span>
<span class="lineNum">    3241 </span>            : 
<span class="lineNum">    3242 </span>            :     Preferences::AddIntVarCache(&amp;sHorzScrollFraction,
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 :       &quot;layout.framevisibility.amountscrollbeforeupdatehorizontal&quot;, 2);</span>
<span class="lineNum">    3244 </span>            :     Preferences::AddIntVarCache(&amp;sVertScrollFraction,
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :       &quot;layout.framevisibility.amountscrollbeforeupdatevertical&quot;, 2);</span>
<span class="lineNum">    3246 </span>            : 
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 :     sFrameVisPrefsCached = true;</span>
<span class="lineNum">    3248 </span>            :   }
<span class="lineNum">    3249 </span><span class="lineCov">         30 : }</span>
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span>            : nsRect
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ExpandRectToNearlyVisible(const nsRect&amp; aRect) const</span>
<span class="lineNum">    3253 </span>            : {
<span class="lineNum">    3254 </span>            :   // We don't want to expand a rect in a direction that we can't scroll, so we
<span class="lineNum">    3255 </span>            :   // check the scroll range.
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :   nsRect scrollRange = GetScrollRangeForClamping();</span>
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :   nsPoint scrollPos = GetScrollPosition();</span>
<span class="lineNum">    3258 </span><span class="lineNoCov">          0 :   nsMargin expand(0, 0, 0, 0);</span>
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span><span class="lineNoCov">          0 :   nscoord vertShift = sVertExpandScrollPort * aRect.height;</span>
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :   if (scrollRange.y &lt; scrollPos.y) {</span>
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :     expand.top = vertShift;</span>
<span class="lineNum">    3263 </span>            :   }
<span class="lineNum">    3264 </span><span class="lineNoCov">          0 :   if (scrollPos.y &lt; scrollRange.YMost()) {</span>
<span class="lineNum">    3265 </span><span class="lineNoCov">          0 :     expand.bottom = vertShift;</span>
<span class="lineNum">    3266 </span>            :   }
<span class="lineNum">    3267 </span>            : 
<span class="lineNum">    3268 </span><span class="lineNoCov">          0 :   nscoord horzShift = sHorzExpandScrollPort * aRect.width;</span>
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :   if (scrollRange.x &lt; scrollPos.x) {</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :     expand.left = horzShift;</span>
<span class="lineNum">    3271 </span>            :   }
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :   if (scrollPos.x &lt; scrollRange.XMost()) {</span>
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 :     expand.right = horzShift;</span>
<span class="lineNum">    3274 </span>            :   }
<span class="lineNum">    3275 </span>            : 
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :   nsRect rect = aRect;</span>
<span class="lineNum">    3277 </span><span class="lineNoCov">          0 :   rect.Inflate(expand);</span>
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :   return rect;</span>
<span class="lineNum">    3279 </span>            : }
<span class="lineNum">    3280 </span>            : 
<span class="lineNum">    3281 </span>            : static bool
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 : ShouldBeClippedByFrame(nsIFrame* aClipFrame, nsIFrame* aClippedFrame)</span>
<span class="lineNum">    3283 </span>            : {
<span class="lineNum">    3284 </span><span class="lineNoCov">          0 :   return nsLayoutUtils::IsProperAncestorFrame(aClipFrame, aClippedFrame);</span>
<span class="lineNum">    3285 </span>            : }
<span class="lineNum">    3286 </span>            : 
<span class="lineNum">    3287 </span>            : static void
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 : ClipItemsExceptCaret(nsDisplayList* aList,</span>
<span class="lineNum">    3289 </span>            :                      nsDisplayListBuilder* aBuilder,
<span class="lineNum">    3290 </span>            :                      nsIFrame* aClipFrame,
<span class="lineNum">    3291 </span>            :                      const DisplayItemClipChain* aExtraClip,
<span class="lineNum">    3292 </span>            :                      nsDataHashtable&lt;nsPtrHashKey&lt;const DisplayItemClipChain&gt;, const DisplayItemClipChain*&gt;&amp; aCache)
<span class="lineNum">    3293 </span>            : {
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :   for (nsDisplayItem* i = aList-&gt;GetBottom(); i; i = i-&gt;GetAbove()) {</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 :     if (!ShouldBeClippedByFrame(aClipFrame, i-&gt;Frame())) {</span>
<span class="lineNum">    3296 </span>            :       continue;
<span class="lineNum">    3297 </span>            :     }
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span><span class="lineNoCov">          0 :     if (i-&gt;GetType() != DisplayItemType::TYPE_CARET) {</span>
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 :       const DisplayItemClipChain* clip = i-&gt;GetClipChain();</span>
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 :       const DisplayItemClipChain* intersection = nullptr;</span>
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 :       if (aCache.Get(clip, &amp;intersection)) {</span>
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :         i-&gt;SetClipChain(intersection, true);</span>
<span class="lineNum">    3304 </span>            :       } else {
<span class="lineNum">    3305 </span><span class="lineNoCov">          0 :         i-&gt;IntersectClip(aBuilder, aExtraClip, true);</span>
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :         aCache.Put(clip, i-&gt;GetClipChain());</span>
<span class="lineNum">    3307 </span>            :       }
<span class="lineNum">    3308 </span>            :     }
<span class="lineNum">    3309 </span><span class="lineNoCov">          0 :     nsDisplayList* children = i-&gt;GetSameCoordinateSystemChildren();</span>
<span class="lineNum">    3310 </span><span class="lineNoCov">          0 :     if (children) {</span>
<span class="lineNum">    3311 </span><span class="lineNoCov">          0 :       ClipItemsExceptCaret(children, aBuilder, aClipFrame, aExtraClip, aCache);</span>
<span class="lineNum">    3312 </span>            :     }
<span class="lineNum">    3313 </span>            :   }
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span>            : static void
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 : ClipListsExceptCaret(nsDisplayListCollection* aLists,</span>
<span class="lineNum">    3318 </span>            :                      nsDisplayListBuilder* aBuilder,
<span class="lineNum">    3319 </span>            :                      nsIFrame* aClipFrame,
<span class="lineNum">    3320 </span>            :                      const DisplayItemClipChain* aExtraClip)
<span class="lineNum">    3321 </span>            : {
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :   nsDataHashtable&lt;nsPtrHashKey&lt;const DisplayItemClipChain&gt;, const DisplayItemClipChain*&gt; cache;</span>
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :   ClipItemsExceptCaret(aLists-&gt;BorderBackground(), aBuilder, aClipFrame, aExtraClip, cache);</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :   ClipItemsExceptCaret(aLists-&gt;BlockBorderBackgrounds(), aBuilder, aClipFrame, aExtraClip, cache);</span>
<span class="lineNum">    3325 </span><span class="lineNoCov">          0 :   ClipItemsExceptCaret(aLists-&gt;Floats(), aBuilder, aClipFrame, aExtraClip, cache);</span>
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :   ClipItemsExceptCaret(aLists-&gt;PositionedDescendants(), aBuilder, aClipFrame, aExtraClip, cache);</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :   ClipItemsExceptCaret(aLists-&gt;Outlines(), aBuilder, aClipFrame, aExtraClip, cache);</span>
<span class="lineNum">    3328 </span><span class="lineNoCov">          0 :   ClipItemsExceptCaret(aLists-&gt;Content(), aBuilder, aClipFrame, aExtraClip, cache);</span>
<span class="lineNum">    3329 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3330 </span>            : 
<span class="lineNum">    3331 </span>            : void
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 : ScrollFrameHelper::BuildDisplayList(nsDisplayListBuilder*   aBuilder,</span>
<span class="lineNum">    3333 </span>            :                                     const nsDisplayListSet&amp; aLists)
<span class="lineNum">    3334 </span>            : {
<span class="lineNum">    3335 </span><span class="lineCov">        217 :   SetAndNullOnExit&lt;const nsIFrame&gt; tmpBuilder(mReferenceFrameDuringPainting, aBuilder-&gt;GetCurrentReferenceFrame());</span>
<span class="lineNum">    3336 </span><span class="lineCov">         76 :   if (aBuilder-&gt;IsForFrameVisibility()) {</span>
<span class="lineNum">    3337 </span><span class="lineNoCov">          0 :     NotifyApproximateFrameVisibilityUpdate(false);</span>
<span class="lineNum">    3338 </span>            :   }
<span class="lineNum">    3339 </span>            : 
<span class="lineNum">    3340 </span><span class="lineCov">         76 :   mOuter-&gt;DisplayBorderBackgroundOutline(aBuilder, aLists);</span>
<span class="lineNum">    3341 </span>            : 
<span class="lineNum">    3342 </span><span class="lineNoCov">          0 :   if (aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3343 </span><span class="lineNoCov">          0 :     mScrollPosAtLastPaint = GetScrollPosition();</span>
<span class="lineNum">    3344 </span><span class="lineNoCov">          0 :     if (IsMaybeScrollingActive()) {</span>
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :       if (mScrollPosForLayerPixelAlignment == nsPoint(-1,-1)) {</span>
<span class="lineNum">    3346 </span><span class="lineNoCov">          0 :         mScrollPosForLayerPixelAlignment = mScrollPosAtLastPaint;</span>
<span class="lineNum">    3347 </span>            :       }
<span class="lineNum">    3348 </span>            :     } else {
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :       mScrollPosForLayerPixelAlignment = nsPoint(-1,-1);</span>
<span class="lineNum">    3350 </span>            :     }
<span class="lineNum">    3351 </span>            :   }
<span class="lineNum">    3352 </span>            : 
<span class="lineNum">    3353 </span>            :   // It's safe to get this value before the DecideScrollableLayer call below
<span class="lineNum">    3354 </span>            :   // because that call cannot create a displayport for root scroll frames,
<span class="lineNum">    3355 </span>            :   // and hence it cannot create an ignore scroll frame.
<span class="lineNum">    3356 </span>            :   bool ignoringThisScrollFrame =
<span class="lineNum">    3357 </span><span class="lineCov">         76 :     aBuilder-&gt;GetIgnoreScrollFrame() == mOuter || IsIgnoringViewportClipping();</span>
<span class="lineNum">    3358 </span>            : 
<span class="lineNum">    3359 </span>            :   // Overflow clipping can never clip frames outside our subtree, so there
<span class="lineNum">    3360 </span>            :   // is no need to worry about whether we are a moving frame that might clip
<span class="lineNum">    3361 </span>            :   // non-moving frames.
<span class="lineNum">    3362 </span>            :   // Not all our descendants will be clipped by overflow clipping, but all
<span class="lineNum">    3363 </span>            :   // the ones that aren't clipped will be out of flow frames that have already
<span class="lineNum">    3364 </span>            :   // had dirty rects saved for them by their parent frames calling
<span class="lineNum">    3365 </span>            :   // MarkOutOfFlowChildrenForDisplayList, so it's safe to restrict our
<span class="lineNum">    3366 </span>            :   // dirty rect here.
<span class="lineNum">    3367 </span><span class="lineCov">        217 :   nsRect visibleRect = aBuilder-&gt;GetVisibleRect();</span>
<span class="lineNum">    3368 </span><span class="lineCov">        217 :   nsRect dirtyRect = aBuilder-&gt;GetDirtyRect();</span>
<span class="lineNum">    3369 </span><span class="lineCov">         76 :   if (!ignoringThisScrollFrame) {</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :     visibleRect = visibleRect.Intersect(mScrollPort);</span>
<span class="lineNum">    3371 </span><span class="lineNoCov">          0 :     dirtyRect = dirtyRect.Intersect(mScrollPort);</span>
<span class="lineNum">    3372 </span>            :   }
<span class="lineNum">    3373 </span>            : 
<span class="lineNum">    3374 </span><span class="lineNoCov">          0 :   bool dirtyRectHasBeenOverriden = false;</span>
<span class="lineNum">    3375 </span><span class="lineCov">         76 :   Unused &lt;&lt; DecideScrollableLayer(aBuilder, &amp;visibleRect, &amp;dirtyRect,</span>
<span class="lineNum">    3376 </span><span class="lineNoCov">          0 :               /* aSetBase = */ !mIsRoot, &amp;dirtyRectHasBeenOverriden);</span>
<span class="lineNum">    3377 </span>            : 
<span class="lineNum">    3378 </span><span class="lineCov">         76 :   if (aBuilder-&gt;IsForFrameVisibility()) {</span>
<span class="lineNum">    3379 </span>            :     // We expand the dirty rect to catch frames just outside of the scroll port.
<span class="lineNum">    3380 </span>            :     // We use the dirty rect instead of the whole scroll port to prevent
<span class="lineNum">    3381 </span>            :     // too much expansion in the presence of very large (bigger than the
<span class="lineNum">    3382 </span>            :     // viewport) scroll ports.
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :     dirtyRect = ExpandRectToNearlyVisible(dirtyRect);</span>
<span class="lineNum">    3384 </span><span class="lineNoCov">          0 :     visibleRect = dirtyRect;</span>
<span class="lineNum">    3385 </span>            :   }
<span class="lineNum">    3386 </span>            : 
<span class="lineNum">    3387 </span>            :   // We put non-overlay scrollbars in their own layers when this is the root
<span class="lineNum">    3388 </span>            :   // scroll frame and we are a toplevel content document. In this situation,
<span class="lineNum">    3389 </span>            :   // the scrollbar(s) would normally be assigned their own layer anyway, since
<span class="lineNum">    3390 </span>            :   // they're not scrolled with the rest of the document. But when both
<span class="lineNum">    3391 </span>            :   // scrollbars are visible, the layer's visible rectangle would be the size
<span class="lineNum">    3392 </span>            :   // of the viewport, so most layer implementations would create a layer buffer
<span class="lineNum">    3393 </span>            :   // that's much larger than necessary. Creating independent layers for each
<span class="lineNum">    3394 </span>            :   // scrollbar works around the problem.
<span class="lineNum">    3395 </span><span class="lineCov">          1 :   bool createLayersForScrollbars = mIsRoot &amp;&amp;</span>
<span class="lineNum">    3396 </span><span class="lineCov">          1 :     mOuter-&gt;PresContext()-&gt;IsRootContentDocument();</span>
<span class="lineNum">    3397 </span>            : 
<span class="lineNum">    3398 </span><span class="lineCov">        152 :   nsIScrollableFrame* sf = do_QueryFrame(mOuter);</span>
<span class="lineNum">    3399 </span><span class="lineCov">         76 :   MOZ_ASSERT(sf);</span>
<span class="lineNum">    3400 </span>            : 
<span class="lineNum">    3401 </span><span class="lineCov">         76 :   if (ignoringThisScrollFrame) {</span>
<span class="lineNum">    3402 </span>            :     // Root scrollframes have FrameMetrics and clipping on their container
<span class="lineNum">    3403 </span>            :     // layers, so don't apply clipping again.
<span class="lineNum">    3404 </span><span class="lineCov">         11 :     mAddClipRectToLayer = false;</span>
<span class="lineNum">    3405 </span>            : 
<span class="lineNum">    3406 </span>            :     // If we are a root scroll frame that has a display port we want to add
<span class="lineNum">    3407 </span>            :     // scrollbars, they will be children of the scrollable layer, but they get
<span class="lineNum">    3408 </span>            :     // adjusted by the APZC automatically.
<span class="lineNum">    3409 </span><span class="lineCov">         11 :     bool addScrollBars = mIsRoot &amp;&amp; mWillBuildScrollableLayer &amp;&amp; aBuilder-&gt;IsPaintingToWindow();</span>
<span class="lineNum">    3410 </span>            : 
<span class="lineNum">    3411 </span><span class="lineCov">         11 :     if (addScrollBars) {</span>
<span class="lineNum">    3412 </span>            :       // Add classic scrollbars.
<span class="lineNum">    3413 </span><span class="lineNoCov">          0 :       AppendScrollPartsTo(aBuilder, aLists, createLayersForScrollbars, false);</span>
<span class="lineNum">    3414 </span>            :     }
<span class="lineNum">    3415 </span>            : 
<span class="lineNum">    3416 </span>            :     {
<span class="lineNum">    3417 </span><span class="lineCov">         22 :       nsDisplayListBuilder::AutoCurrentActiveScrolledRootSetter asrSetter(aBuilder);</span>
<span class="lineNum">    3418 </span><span class="lineNoCov">          0 :       if (aBuilder-&gt;IsPaintingToWindow() &amp;&amp;</span>
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 :           gfxPrefs::LayoutUseContainersForRootFrames() &amp;&amp; mIsRoot) {</span>
<span class="lineNum">    3420 </span><span class="lineNoCov">          0 :         asrSetter.EnterScrollFrame(sf);</span>
<span class="lineNum">    3421 </span><span class="lineNoCov">          0 :         aBuilder-&gt;SetActiveScrolledRootForRootScrollframe(aBuilder-&gt;CurrentActiveScrolledRoot());</span>
<span class="lineNum">    3422 </span>            :       }
<span class="lineNum">    3423 </span>            : 
<span class="lineNum">    3424 </span>            :       nsDisplayListBuilder::AutoBuildingDisplayList
<span class="lineNum">    3425 </span><span class="lineCov">         22 :         building(aBuilder, mOuter, visibleRect, dirtyRect, aBuilder-&gt;IsAtRootOfPseudoStackingContext());</span>
<span class="lineNum">    3426 </span>            : 
<span class="lineNum">    3427 </span>            :       // Don't clip the scrolled child, and don't paint scrollbars/scrollcorner.
<span class="lineNum">    3428 </span>            :       // The scrolled frame shouldn't have its own background/border, so we
<span class="lineNum">    3429 </span>            :       // can just pass aLists directly.
<span class="lineNum">    3430 </span><span class="lineCov">         11 :       mOuter-&gt;BuildDisplayListForChild(aBuilder, mScrolledFrame, aLists);</span>
<span class="lineNum">    3431 </span>            :     }
<span class="lineNum">    3432 </span>            : 
<span class="lineNum">    3433 </span><span class="lineNoCov">          0 :     if (addScrollBars) {</span>
<span class="lineNum">    3434 </span>            :       // Add overlay scrollbars.
<span class="lineNum">    3435 </span><span class="lineNoCov">          0 :       AppendScrollPartsTo(aBuilder, aLists, createLayersForScrollbars, true);</span>
<span class="lineNum">    3436 </span>            :     }
<span class="lineNum">    3437 </span>            : 
<span class="lineNum">    3438 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    3439 </span>            :   }
<span class="lineNum">    3440 </span>            : 
<span class="lineNum">    3441 </span>            :   // Root scrollframes have FrameMetrics and clipping on their container
<span class="lineNum">    3442 </span>            :   // layers, so don't apply clipping again.
<span class="lineNum">    3443 </span><span class="lineCov">         65 :   mAddClipRectToLayer =</span>
<span class="lineNum">    3444 </span><span class="lineCov">         65 :     !(mIsRoot &amp;&amp; mOuter-&gt;PresShell()-&gt;GetIsViewportOverridden());</span>
<span class="lineNum">    3445 </span>            : 
<span class="lineNum">    3446 </span>            :   // Whether we might want to build a scrollable layer for this scroll frame
<span class="lineNum">    3447 </span>            :   // at some point in the future. This controls whether we add the information
<span class="lineNum">    3448 </span>            :   // to the layer tree (a scroll info layer if necessary, and add the right
<span class="lineNum">    3449 </span>            :   // area to the dispatch to content layer event regions) necessary to activate
<span class="lineNum">    3450 </span>            :   // a scroll frame so it creates a scrollable layer.
<span class="lineNum">    3451 </span><span class="lineCov">         65 :   bool couldBuildLayer = false;</span>
<span class="lineNum">    3452 </span><span class="lineNoCov">          0 :   if (aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3453 </span><span class="lineNoCov">          0 :     if (mWillBuildScrollableLayer) {</span>
<span class="lineNum">    3454 </span>            :       couldBuildLayer = true;
<span class="lineNum">    3455 </span>            :     } else {
<span class="lineNum">    3456 </span>            :       couldBuildLayer =
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :         nsLayoutUtils::AsyncPanZoomEnabled(mOuter) &amp;&amp;</span>
<span class="lineNum">    3458 </span><span class="lineCov">         65 :         WantAsyncScroll() &amp;&amp;</span>
<span class="lineNum">    3459 </span>            :         // If we are using containers for root frames, and we are the root
<span class="lineNum">    3460 </span>            :         // scroll frame for the display root, then we don't need a scroll
<span class="lineNum">    3461 </span>            :         // info layer. nsDisplayList::PaintForFrame already calls
<span class="lineNum">    3462 </span>            :         // ComputeFrameMetrics for us.
<span class="lineNum">    3463 </span><span class="lineNoCov">          0 :         (!(gfxPrefs::LayoutUseContainersForRootFrames() &amp;&amp; mIsRoot) ||</span>
<span class="lineNum">    3464 </span><span class="lineNoCov">          0 :          (aBuilder-&gt;RootReferenceFrame()-&gt;PresContext() != mOuter-&gt;PresContext()));</span>
<span class="lineNum">    3465 </span>            :     }
<span class="lineNum">    3466 </span>            :   }
<span class="lineNum">    3467 </span>            : 
<span class="lineNum">    3468 </span>            :   // Now display the scrollbars and scrollcorner. These parts are drawn
<span class="lineNum">    3469 </span>            :   // in the border-background layer, on top of our own background and
<span class="lineNum">    3470 </span>            :   // borders and underneath borders and backgrounds of later elements
<span class="lineNum">    3471 </span>            :   // in the tree.
<span class="lineNum">    3472 </span>            :   // Note that this does not apply for overlay scrollbars; those are drawn
<span class="lineNum">    3473 </span>            :   // in the positioned-elements layer on top of everything else by the call
<span class="lineNum">    3474 </span>            :   // to AppendScrollPartsTo(..., true) further down.
<span class="lineNum">    3475 </span><span class="lineNoCov">          0 :   AppendScrollPartsTo(aBuilder, aLists, createLayersForScrollbars, false);</span>
<span class="lineNum">    3476 </span>            : 
<span class="lineNum">    3477 </span><span class="lineNoCov">          0 :   const nsStyleDisplay* disp = mOuter-&gt;StyleDisplay();</span>
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 :   if (disp &amp;&amp; (disp-&gt;mWillChangeBitField &amp; NS_STYLE_WILL_CHANGE_SCROLL)) {</span>
<span class="lineNum">    3479 </span><span class="lineNoCov">          0 :     aBuilder-&gt;AddToWillChangeBudget(mOuter, GetScrollPositionClampingScrollPortSize());</span>
<span class="lineNum">    3480 </span>            :   }
<span class="lineNum">    3481 </span>            : 
<span class="lineNum">    3482 </span><span class="lineNoCov">          0 :   mScrollParentID = aBuilder-&gt;GetCurrentScrollParentId();</span>
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span><span class="lineCov">        130 :   Maybe&lt;nsRect&gt; contentBoxClip;</span>
<span class="lineNum">    3485 </span><span class="lineNoCov">          0 :   Maybe&lt;const DisplayItemClipChain*&gt; extraContentBoxClipForNonCaretContent;</span>
<span class="lineNum">    3486 </span><span class="lineCov">         65 :   if (MOZ_UNLIKELY(disp-&gt;mOverflowClipBoxBlock ==</span>
<span class="lineNum">    3487 </span>            :                      NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX ||
<span class="lineNum">    3488 </span>            :                    disp-&gt;mOverflowClipBoxInline ==
<span class="lineNum">    3489 </span>            :                       NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX)) {
<span class="lineNum">    3490 </span><span class="lineNoCov">          0 :     WritingMode wm = mScrolledFrame-&gt;GetWritingMode();</span>
<span class="lineNum">    3491 </span><span class="lineCov">         18 :     bool cbH = (wm.IsVertical() ? disp-&gt;mOverflowClipBoxBlock</span>
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :                                 : disp-&gt;mOverflowClipBoxInline) ==</span>
<span class="lineNum">    3493 </span><span class="lineNoCov">          0 :                NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX;</span>
<span class="lineNum">    3494 </span><span class="lineCov">         18 :     bool cbV = (wm.IsVertical() ? disp-&gt;mOverflowClipBoxInline</span>
<span class="lineNum">    3495 </span><span class="lineCov">         18 :                                 : disp-&gt;mOverflowClipBoxBlock) ==</span>
<span class="lineNum">    3496 </span><span class="lineNoCov">          0 :                NS_STYLE_OVERFLOW_CLIP_BOX_CONTENT_BOX;</span>
<span class="lineNum">    3497 </span>            :     // We only clip if there is *scrollable* overflow, to avoid clipping
<span class="lineNum">    3498 </span>            :     // *visual* overflow unnecessarily.
<span class="lineNum">    3499 </span><span class="lineCov">         36 :     nsRect clipRect = mScrollPort + aBuilder-&gt;ToReferenceFrame(mOuter);</span>
<span class="lineNum">    3500 </span><span class="lineNoCov">          0 :     nsRect so = mScrolledFrame-&gt;GetScrollableOverflowRect();</span>
<span class="lineNum">    3501 </span><span class="lineCov">         18 :     if ((cbH &amp;&amp; (clipRect.width != so.width || so.x &lt; 0)) ||</span>
<span class="lineNum">    3502 </span><span class="lineNoCov">          0 :         (cbV &amp;&amp; (clipRect.height != so.height || so.y &lt; 0))) {</span>
<span class="lineNum">    3503 </span><span class="lineNoCov">          0 :       nsMargin padding = mOuter-&gt;GetUsedPadding();</span>
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :       if (!cbH) {</span>
<span class="lineNum">    3505 </span><span class="lineNoCov">          0 :         padding.left = padding.right = nscoord(0);</span>
<span class="lineNum">    3506 </span>            :       }
<span class="lineNum">    3507 </span><span class="lineNoCov">          0 :       if (!cbV) {</span>
<span class="lineNum">    3508 </span><span class="lineNoCov">          0 :         padding.top = padding.bottom = nscoord(0);</span>
<span class="lineNum">    3509 </span>            :       }
<span class="lineNum">    3510 </span><span class="lineNoCov">          0 :       clipRect.Deflate(padding);</span>
<span class="lineNum">    3511 </span>            : 
<span class="lineNum">    3512 </span>            :       // The non-inflated clip needs to be set on all non-caret items.
<span class="lineNum">    3513 </span>            :       // We prepare an extra DisplayItemClipChain here that will be intersected
<span class="lineNum">    3514 </span>            :       // with those items after they've been created.
<span class="lineNum">    3515 </span><span class="lineNoCov">          0 :       const ActiveScrolledRoot* asr = aBuilder-&gt;CurrentActiveScrolledRoot();</span>
<span class="lineNum">    3516 </span>            : 
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :       DisplayItemClip newClip;</span>
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 :       newClip.SetTo(clipRect);</span>
<span class="lineNum">    3519 </span>            : 
<span class="lineNum">    3520 </span>            :       const DisplayItemClipChain* extraClip =
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :         aBuilder-&gt;AllocateDisplayItemClipChain(newClip, asr, nullptr);</span>
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span><span class="lineNoCov">          0 :       extraContentBoxClipForNonCaretContent = Some(extraClip);</span>
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :       nsIFrame* caretFrame = aBuilder-&gt;GetCaretFrame();</span>
<span class="lineNum">    3526 </span>            :       // Avoid clipping it in a zero-height line box (heuristic only).
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :       if (caretFrame &amp;&amp; caretFrame-&gt;GetRect().height != 0) {</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :         nsRect caretRect = aBuilder-&gt;GetCaretRect();</span>
<span class="lineNum">    3529 </span>            :         // Allow the caret to stick out of the content box clip by half the
<span class="lineNum">    3530 </span>            :         // caret height on the top, and its full width on the right.
<span class="lineNum">    3531 </span><span class="lineNoCov">          0 :         nsRect inflatedClip = clipRect;</span>
<span class="lineNum">    3532 </span><span class="lineNoCov">          0 :         inflatedClip.Inflate(nsMargin(caretRect.height / 2, caretRect.width, 0, 0));</span>
<span class="lineNum">    3533 </span><span class="lineNoCov">          0 :         contentBoxClip = Some(inflatedClip);</span>
<span class="lineNum">    3534 </span>            :       }
<span class="lineNum">    3535 </span>            :     }
<span class="lineNum">    3536 </span>            :   }
<span class="lineNum">    3537 </span>            : 
<span class="lineNum">    3538 </span><span class="lineCov">        130 :   nsDisplayListCollection scrolledContent(aBuilder);</span>
<span class="lineNum">    3539 </span>            :   {
<span class="lineNum">    3540 </span>            :     // Note that setting the current scroll parent id here means that positioned children
<span class="lineNum">    3541 </span>            :     // of this scroll info layer will pick up the scroll info layer as their scroll handoff
<span class="lineNum">    3542 </span>            :     // parent. This is intentional because that is what happens for positioned children
<span class="lineNum">    3543 </span>            :     // of scroll layers, and we want to maintain consistent behaviour between scroll layers
<span class="lineNum">    3544 </span>            :     // and scroll info layers.
<span class="lineNum">    3545 </span>            :     nsDisplayListBuilder::AutoCurrentScrollParentIdSetter idSetter(
<span class="lineNum">    3546 </span>            :         aBuilder,
<span class="lineNum">    3547 </span><span class="lineNoCov">          0 :         couldBuildLayer &amp;&amp; mScrolledFrame-&gt;GetContent()</span>
<span class="lineNum">    3548 </span><span class="lineNoCov">          0 :             ? nsLayoutUtils::FindOrCreateIDFor(mScrolledFrame-&gt;GetContent())</span>
<span class="lineNum">    3549 </span><span class="lineNoCov">          0 :             : aBuilder-&gt;GetCurrentScrollParentId());</span>
<span class="lineNum">    3550 </span>            : 
<span class="lineNum">    3551 </span><span class="lineCov">          1 :     nsRect clipRect = mScrollPort + aBuilder-&gt;ToReferenceFrame(mOuter);</span>
<span class="lineNum">    3552 </span>            :     // Our override of GetBorderRadii ensures we never have a radius at
<span class="lineNum">    3553 </span>            :     // the corners where we have a scrollbar.
<span class="lineNum">    3554 </span>            :     nscoord radii[8];
<span class="lineNum">    3555 </span><span class="lineCov">         65 :     bool haveRadii = mOuter-&gt;GetPaddingBoxBorderRadii(radii);</span>
<span class="lineNum">    3556 </span><span class="lineCov">         65 :     if (mIsRoot) {</span>
<span class="lineNum">    3557 </span><span class="lineNoCov">          0 :       clipRect.SizeTo(nsLayoutUtils::CalculateCompositionSizeForFrame(mOuter));</span>
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :       if (mOuter-&gt;PresContext()-&gt;IsRootContentDocument()) {</span>
<span class="lineNum">    3559 </span><span class="lineNoCov">          0 :         double res = mOuter-&gt;PresShell()-&gt;GetResolution();</span>
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 :         clipRect.width = NSToCoordRound(clipRect.width / res);</span>
<span class="lineNum">    3561 </span><span class="lineNoCov">          0 :         clipRect.height = NSToCoordRound(clipRect.height / res);</span>
<span class="lineNum">    3562 </span>            :       }
<span class="lineNum">    3563 </span>            :     }
<span class="lineNum">    3564 </span>            : 
<span class="lineNum">    3565 </span><span class="lineCov">        130 :     DisplayListClipState::AutoSaveRestore clipState(aBuilder);</span>
<span class="lineNum">    3566 </span><span class="lineNoCov">          0 :     if (mClipAllDescendants) {</span>
<span class="lineNum">    3567 </span><span class="lineNoCov">          0 :       clipState.ClipContentDescendants(clipRect, haveRadii ? radii : nullptr);</span>
<span class="lineNum">    3568 </span>            :     } else {
<span class="lineNum">    3569 </span><span class="lineCov">         65 :       clipState.ClipContainingBlockDescendants(clipRect, haveRadii ? radii : nullptr);</span>
<span class="lineNum">    3570 </span>            :     }
<span class="lineNum">    3571 </span>            : 
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 :     Maybe&lt;DisplayListClipState::AutoSaveRestore&gt; contentBoxClipState;;</span>
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :     if (contentBoxClip) {</span>
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :       contentBoxClipState.emplace(aBuilder);</span>
<span class="lineNum">    3575 </span><span class="lineNoCov">          0 :       if (mClipAllDescendants) {</span>
<span class="lineNum">    3576 </span><span class="lineNoCov">          0 :         contentBoxClipState-&gt;ClipContentDescendants(*contentBoxClip);</span>
<span class="lineNum">    3577 </span>            :       } else {
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :         contentBoxClipState-&gt;ClipContainingBlockDescendants(*contentBoxClip);</span>
<span class="lineNum">    3579 </span>            :       }
<span class="lineNum">    3580 </span>            :     }
<span class="lineNum">    3581 </span>            : 
<span class="lineNum">    3582 </span><span class="lineCov">        130 :     nsDisplayListBuilder::AutoCurrentActiveScrolledRootSetter asrSetter(aBuilder);</span>
<span class="lineNum">    3583 </span><span class="lineCov">         65 :     if (mWillBuildScrollableLayer &amp;&amp; aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3584 </span><span class="lineNoCov">          0 :       asrSetter.EnterScrollFrame(sf);</span>
<span class="lineNum">    3585 </span>            :     }
<span class="lineNum">    3586 </span>            : 
<span class="lineNum">    3587 </span><span class="lineCov">         65 :     if (mIsScrollableLayerInRootContainer) {</span>
<span class="lineNum">    3588 </span><span class="lineNoCov">          0 :       aBuilder-&gt;SetActiveScrolledRootForRootScrollframe(aBuilder-&gt;CurrentActiveScrolledRoot());</span>
<span class="lineNum">    3589 </span>            :     }
<span class="lineNum">    3590 </span>            : 
<span class="lineNum">    3591 </span><span class="lineCov">         65 :     if (mWillBuildScrollableLayer) {</span>
<span class="lineNum">    3592 </span>            :       // Create a hit test info item for the scrolled content that's not
<span class="lineNum">    3593 </span>            :       // clipped to the displayport. This ensures that within the bounds
<span class="lineNum">    3594 </span>            :       // of the scroll frame, the scrolled content is always hit, even
<span class="lineNum">    3595 </span>            :       // if we are checkerboarding.
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :       if (aBuilder-&gt;BuildCompositorHitTestInfo()) {</span>
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :         CompositorHitTestInfo info = mScrolledFrame-&gt;GetCompositorHitTestInfo(aBuilder);</span>
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :         if (info != CompositorHitTestInfo::eInvisibleToHitTest) {</span>
<span class="lineNum">    3599 </span>            :           nsDisplayCompositorHitTestInfo* hitInfo =
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :               MakeDisplayItem&lt;nsDisplayCompositorHitTestInfo&gt;(aBuilder, mScrolledFrame, info, 1);</span>
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :           aBuilder-&gt;SetCompositorHitTestInfo(hitInfo);</span>
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :           scrolledContent.BorderBackground()-&gt;AppendToTop(hitInfo);</span>
<span class="lineNum">    3603 </span>            :         }
<span class="lineNum">    3604 </span>            :       }
<span class="lineNum">    3605 </span>            :     }
<span class="lineNum">    3606 </span>            : 
<span class="lineNum">    3607 </span>            :     {
<span class="lineNum">    3608 </span>            :       // Clip our contents to the unsnapped scrolled rect. This makes sure that
<span class="lineNum">    3609 </span>            :       // we don't have display items over the subpixel seam at the edge of the
<span class="lineNum">    3610 </span>            :       // scrolled area.
<span class="lineNum">    3611 </span><span class="lineCov">        130 :       DisplayListClipState::AutoSaveRestore scrolledRectClipState(aBuilder);</span>
<span class="lineNum">    3612 </span>            :       nsRect scrolledRectClip =
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 :         GetUnsnappedScrolledRectInternal(mScrolledFrame-&gt;GetScrollableOverflowRect(),</span>
<span class="lineNum">    3614 </span><span class="lineCov">        390 :                                          mScrollPort.Size()) + mScrolledFrame-&gt;GetPosition();</span>
<span class="lineNum">    3615 </span><span class="lineNoCov">          0 :       if (mWillBuildScrollableLayer &amp;&amp; aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3616 </span>            :         // Clip the contents to the display port.
<span class="lineNum">    3617 </span>            :         // The dirty rect already acts kind of like a clip, in that
<span class="lineNum">    3618 </span>            :         // FrameLayerBuilder intersects item bounds and opaque regions with
<span class="lineNum">    3619 </span>            :         // it, but it doesn't have the consistent snapping behavior of a
<span class="lineNum">    3620 </span>            :         // true clip.
<span class="lineNum">    3621 </span>            :         // For a case where this makes a difference, imagine the following
<span class="lineNum">    3622 </span>            :         // scenario: The display port has an edge that falls on a fractional
<span class="lineNum">    3623 </span>            :         // layer pixel, and there's an opaque display item that covers the
<span class="lineNum">    3624 </span>            :         // whole display port up until that fractional edge, and there is a
<span class="lineNum">    3625 </span>            :         // transparent display item that overlaps the edge. We want to prevent
<span class="lineNum">    3626 </span>            :         // this transparent item from enlarging the scrolled layer's visible
<span class="lineNum">    3627 </span>            :         // region beyond its opaque region. The dirty rect doesn't do that -
<span class="lineNum">    3628 </span>            :         // it gets rounded out, whereas a true clip gets rounded to nearest
<span class="lineNum">    3629 </span>            :         // pixels.
<span class="lineNum">    3630 </span>            :         // If there is no display port, we don't need this because the clip
<span class="lineNum">    3631 </span>            :         // from the scroll port is still applied.
<span class="lineNum">    3632 </span><span class="lineNoCov">          0 :         scrolledRectClip = scrolledRectClip.Intersect(visibleRect);</span>
<span class="lineNum">    3633 </span>            :       }
<span class="lineNum">    3634 </span>            :       scrolledRectClipState.ClipContainingBlockDescendants(
<span class="lineNum">    3635 </span><span class="lineCov">         65 :         scrolledRectClip + aBuilder-&gt;ToReferenceFrame(mOuter));</span>
<span class="lineNum">    3636 </span>            : 
<span class="lineNum">    3637 </span>            :       nsDisplayListBuilder::AutoBuildingDisplayList
<span class="lineNum">    3638 </span><span class="lineCov">        130 :         building(aBuilder, mOuter, visibleRect, dirtyRect, aBuilder-&gt;IsAtRootOfPseudoStackingContext());</span>
<span class="lineNum">    3639 </span>            : 
<span class="lineNum">    3640 </span><span class="lineNoCov">          0 :       mOuter-&gt;BuildDisplayListForChild(aBuilder, mScrolledFrame, scrolledContent);</span>
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span><span class="lineCov">         65 :       if (dirtyRectHasBeenOverriden &amp;&amp; gfxPrefs::LayoutDisplayListShowArea()) {</span>
<span class="lineNum">    3643 </span>            :         nsDisplaySolidColor* color =
<span class="lineNum">    3644 </span><span class="lineNoCov">          0 :           MakeDisplayItem&lt;nsDisplaySolidColor&gt;(aBuilder, mOuter,</span>
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :                                                dirtyRect + aBuilder-&gt;GetCurrentFrameOffsetToReferenceFrame(),</span>
<span class="lineNum">    3646 </span><span class="lineNoCov">          0 :                                                NS_RGBA(0, 0, 255, 64), false);</span>
<span class="lineNum">    3647 </span><span class="lineNoCov">          0 :         color-&gt;SetOverrideZIndex(INT32_MAX);</span>
<span class="lineNum">    3648 </span><span class="lineNoCov">          0 :         scrolledContent.PositionedDescendants()-&gt;AppendToTop(color);</span>
<span class="lineNum">    3649 </span>            :       }
<span class="lineNum">    3650 </span>            :     }
<span class="lineNum">    3651 </span>            : 
<span class="lineNum">    3652 </span><span class="lineCov">          1 :     if (extraContentBoxClipForNonCaretContent) {</span>
<span class="lineNum">    3653 </span>            :       // The items were built while the inflated content box clip was in
<span class="lineNum">    3654 </span>            :       // effect, so that the caret wasn't clipped unnecessarily. We apply
<span class="lineNum">    3655 </span>            :       // the non-inflated clip to the non-caret items now, by intersecting
<span class="lineNum">    3656 </span>            :       // it with their existing clip.
<span class="lineNum">    3657 </span><span class="lineNoCov">          0 :       ClipListsExceptCaret(&amp;scrolledContent, aBuilder, mScrolledFrame,</span>
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :                            *extraContentBoxClipForNonCaretContent);</span>
<span class="lineNum">    3659 </span>            :     }
<span class="lineNum">    3660 </span>            : 
<span class="lineNum">    3661 </span><span class="lineCov">          1 :     if (aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3662 </span><span class="lineCov">          1 :       mIsScrollParent = idSetter.ShouldForceLayerForScrollParent();</span>
<span class="lineNum">    3663 </span>            :     }
<span class="lineNum">    3664 </span><span class="lineCov">          1 :     if (idSetter.ShouldForceLayerForScrollParent() &amp;&amp;</span>
<span class="lineNum">    3665 </span><span class="lineNoCov">          0 :         !gfxPrefs::LayoutUseContainersForRootFrames())</span>
<span class="lineNum">    3666 </span>            :     {
<span class="lineNum">    3667 </span>            :       // Note that forcing layerization of scroll parents follows the scroll
<span class="lineNum">    3668 </span>            :       // handoff chain which is subject to the out-of-flow-frames caveat noted
<span class="lineNum">    3669 </span>            :       // above (where the idSetter variable is created).
<span class="lineNum">    3670 </span>            :       //
<span class="lineNum">    3671 </span>            :       // This is not compatible when using containes for root scrollframes.
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :       MOZ_ASSERT(couldBuildLayer &amp;&amp; mScrolledFrame-&gt;GetContent() &amp;&amp;</span>
<span class="lineNum">    3673 </span>            :         aBuilder-&gt;IsPaintingToWindow());
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :       if (!mWillBuildScrollableLayer) {</span>
<span class="lineNum">    3675 </span>            :         // Set a displayport so next paint we don't have to force layerization
<span class="lineNum">    3676 </span>            :         // after the fact.
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 :         nsLayoutUtils::SetDisplayPortMargins(mOuter-&gt;GetContent(),</span>
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :                                              mOuter-&gt;PresShell(),</span>
<span class="lineNum">    3679 </span><span class="lineNoCov">          0 :                                              ScreenMargin(),</span>
<span class="lineNum">    3680 </span>            :                                              0,
<span class="lineNum">    3681 </span><span class="lineNoCov">          0 :                                              nsLayoutUtils::RepaintMode::DoNotRepaint);</span>
<span class="lineNum">    3682 </span>            :         // Call DecideScrollableLayer to recompute mWillBuildScrollableLayer and
<span class="lineNum">    3683 </span>            :         // recompute the current animated geometry root if needed.
<span class="lineNum">    3684 </span>            :         // It's too late to change the dirty rect so pass a copy.
<span class="lineNum">    3685 </span><span class="lineNoCov">          0 :         nsRect copyOfDirtyRect = dirtyRect;</span>
<span class="lineNum">    3686 </span><span class="lineNoCov">          0 :         nsRect copyOfVisibleRect = visibleRect;</span>
<span class="lineNum">    3687 </span><span class="lineNoCov">          0 :         Unused &lt;&lt; DecideScrollableLayer(aBuilder, &amp;copyOfVisibleRect, &amp;copyOfDirtyRect,</span>
<span class="lineNum">    3688 </span>            :                     /* aSetBase = */ false, nullptr);
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :         if (mWillBuildScrollableLayer) {</span>
<span class="lineNum">    3690 </span><span class="lineNoCov">          0 :           asrSetter.InsertScrollFrame(sf);</span>
<span class="lineNum">    3691 </span><span class="lineNoCov">          0 :           aBuilder-&gt;SetDisablePartialUpdates(true);</span>
<span class="lineNum">    3692 </span>            :         }
<span class="lineNum">    3693 </span>            :       }
<span class="lineNum">    3694 </span>            :     }
<span class="lineNum">    3695 </span>            :   }
<span class="lineNum">    3696 </span>            : 
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :   if (mWillBuildScrollableLayer &amp;&amp; aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :     aBuilder-&gt;ForceLayerForScrollParent();</span>
<span class="lineNum">    3699 </span>            :   }
<span class="lineNum">    3700 </span>            : 
<span class="lineNum">    3701 </span><span class="lineCov">          1 :   if (couldBuildLayer) {</span>
<span class="lineNum">    3702 </span>            :     // Make sure that APZ will dispatch events back to content so we can create
<span class="lineNum">    3703 </span>            :     // a displayport for this frame. We'll add the item later on.
<span class="lineNum">    3704 </span><span class="lineNoCov">          0 :     if (!mWillBuildScrollableLayer) {</span>
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :       if (aBuilder-&gt;BuildCompositorHitTestInfo()) {</span>
<span class="lineNum">    3706 </span>            :         CompositorHitTestInfo info = CompositorHitTestInfo::eVisibleToHitTest
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :                                    | CompositorHitTestInfo::eDispatchToContent;</span>
<span class="lineNum">    3708 </span>            :         // If the scroll frame has non-default overscroll-behavior, instruct
<span class="lineNum">    3709 </span>            :         // APZ to require a target confirmation before processing events that
<span class="lineNum">    3710 </span>            :         // hit this scroll frame (that is, to drop the events if a confirmation
<span class="lineNum">    3711 </span>            :         // does not arrive within the timeout period). Otherwise, APZ's
<span class="lineNum">    3712 </span>            :         // fallback behaviour of scrolling the enclosing scroll frame would
<span class="lineNum">    3713 </span>            :         // violate the specified overscroll-behavior.
<span class="lineNum">    3714 </span><span class="lineNoCov">          0 :         ScrollbarStyles scrollbarStyles = GetScrollbarStylesFromFrame();</span>
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :         if (scrollbarStyles.mOverscrollBehaviorX != StyleOverscrollBehavior::Auto ||</span>
<span class="lineNum">    3716 </span>            :             scrollbarStyles.mOverscrollBehaviorY != StyleOverscrollBehavior::Auto) {
<span class="lineNum">    3717 </span>            :           info |= CompositorHitTestInfo::eRequiresTargetConfirmation;
<span class="lineNum">    3718 </span>            :         }
<span class="lineNum">    3719 </span>            :         nsDisplayCompositorHitTestInfo* hitInfo =
<span class="lineNum">    3720 </span><span class="lineNoCov">          0 :             MakeDisplayItem&lt;nsDisplayCompositorHitTestInfo&gt;(aBuilder, mScrolledFrame, info, 1,</span>
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :                 Some(mScrollPort + aBuilder-&gt;ToReferenceFrame(mOuter)));</span>
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 :         AppendInternalItemToTop(scrolledContent, hitInfo, Some(INT32_MAX));</span>
<span class="lineNum">    3723 </span>            :       }
<span class="lineNum">    3724 </span>            :     }
<span class="lineNum">    3725 </span>            : 
<span class="lineNum">    3726 </span><span class="lineNoCov">          0 :     if (aBuilder-&gt;ShouldBuildScrollInfoItemsForHoisting()) {</span>
<span class="lineNum">    3727 </span><span class="lineNoCov">          0 :       aBuilder-&gt;AppendNewScrollInfoItemForHoisting(</span>
<span class="lineNum">    3728 </span>            :         MakeDisplayItem&lt;nsDisplayScrollInfoLayer&gt;(aBuilder, mScrolledFrame,
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 :                                                 mOuter));</span>
<span class="lineNum">    3730 </span>            :     }
<span class="lineNum">    3731 </span>            :   }
<span class="lineNum">    3732 </span>            :   // Now display overlay scrollbars and the resizer, if we have one.
<span class="lineNum">    3733 </span><span class="lineNoCov">          0 :   AppendScrollPartsTo(aBuilder, scrolledContent, createLayersForScrollbars, true);</span>
<span class="lineNum">    3734 </span>            : 
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :   scrolledContent.MoveTo(aLists);</span>
<span class="lineNum">    3736 </span>            : }
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span>            : bool
<span class="lineNum">    3739 </span><span class="lineCov">         87 : ScrollFrameHelper::DecideScrollableLayer(nsDisplayListBuilder* aBuilder,</span>
<span class="lineNum">    3740 </span>            :                                          nsRect* aVisibleRect,
<span class="lineNum">    3741 </span>            :                                          nsRect* aDirtyRect,
<span class="lineNum">    3742 </span>            :                                          bool aSetBase,
<span class="lineNum">    3743 </span>            :                                          bool* aDirtyRectHasBeenOverriden)
<span class="lineNum">    3744 </span>            : {
<span class="lineNum">    3745 </span>            :   // Save and check if this changes so we can recompute the current agr.
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :   bool oldWillBuildScrollableLayer = mWillBuildScrollableLayer;</span>
<span class="lineNum">    3747 </span>            : 
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :   nsIContent* content = mOuter-&gt;GetContent();</span>
<span class="lineNum">    3749 </span><span class="lineNoCov">          0 :   bool usingDisplayPort = nsLayoutUtils::HasDisplayPort(content);</span>
<span class="lineNum">    3750 </span><span class="lineNoCov">          0 :   if (aBuilder-&gt;IsPaintingToWindow()) {</span>
<span class="lineNum">    3751 </span><span class="lineCov">         65 :     if (aSetBase) {</span>
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :       nsRect displayportBase = *aVisibleRect;</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :       nsPresContext* pc = mOuter-&gt;PresContext();</span>
<span class="lineNum">    3754 </span><span class="lineNoCov">          0 :       if (mIsRoot &amp;&amp; (pc-&gt;IsRootContentDocument() || !pc-&gt;GetParentPresContext())) {</span>
<span class="lineNum">    3755 </span><span class="lineNoCov">          0 :         displayportBase =</span>
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :           nsRect(nsPoint(0, 0), nsLayoutUtils::CalculateCompositionSizeForFrame(mOuter));</span>
<span class="lineNum">    3757 </span>            :       } else {
<span class="lineNum">    3758 </span>            :         // Make the displayport base equal to the visible rect restricted to
<span class="lineNum">    3759 </span>            :         // the scrollport and the root composition bounds, relative to the
<span class="lineNum">    3760 </span>            :         // scrollport.
<span class="lineNum">    3761 </span><span class="lineCov">         65 :         displayportBase = aVisibleRect-&gt;Intersect(mScrollPort);</span>
<span class="lineNum">    3762 </span>            : 
<span class="lineNum">    3763 </span>            :         // Only restrict to the root composition bounds if necessary,
<span class="lineNum">    3764 </span>            :         // as the required coordinate transformation is expensive.
<span class="lineNum">    3765 </span><span class="lineNoCov">          0 :         if (usingDisplayPort) {</span>
<span class="lineNum">    3766 </span>            :           const nsPresContext* rootPresContext =
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :             pc-&gt;GetToplevelContentDocumentPresContext();</span>
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :           if (!rootPresContext) {</span>
<span class="lineNum">    3769 </span><span class="lineNoCov">          0 :             rootPresContext = pc-&gt;GetRootPresContext();</span>
<span class="lineNum">    3770 </span>            :           }
<span class="lineNum">    3771 </span><span class="lineNoCov">          0 :           if (rootPresContext) {</span>
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :             const nsIPresShell* const rootPresShell = rootPresContext-&gt;PresShell();</span>
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 :             nsIFrame* rootFrame = rootPresShell-&gt;GetRootScrollFrame();</span>
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :             if (!rootFrame) {</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :               rootFrame = rootPresShell-&gt;GetRootFrame();</span>
<span class="lineNum">    3776 </span>            :             }
<span class="lineNum">    3777 </span><span class="lineNoCov">          0 :             if (rootFrame) {</span>
<span class="lineNum">    3778 </span>            :               nsRect rootCompBounds =
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :                 nsRect(nsPoint(0, 0), nsLayoutUtils::CalculateCompositionSizeForFrame(rootFrame));</span>
<span class="lineNum">    3780 </span>            : 
<span class="lineNum">    3781 </span>            :               // If rootFrame is the RCD-RSF then CalculateCompositionSizeForFrame
<span class="lineNum">    3782 </span>            :               // did not take the document's resolution into account, so we must.
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :               if (rootPresContext-&gt;IsRootContentDocument() &amp;&amp;</span>
<span class="lineNum">    3784 </span><span class="lineNoCov">          0 :                   rootFrame == rootPresShell-&gt;GetRootScrollFrame()) {</span>
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :                 rootCompBounds = rootCompBounds.RemoveResolution(rootPresShell-&gt;GetResolution());</span>
<span class="lineNum">    3786 </span>            :               }
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span>            :               // We want to convert the root composition bounds from the coordinate
<span class="lineNum">    3789 </span>            :               // space of |rootFrame| to the coordinate space of |mOuter|. We do
<span class="lineNum">    3790 </span>            :               // that with the TransformRect call below. However, since we care
<span class="lineNum">    3791 </span>            :               // about the root composition bounds relative to what the user is
<span class="lineNum">    3792 </span>            :               // actually seeing, we also need to incorporate the APZ callback
<span class="lineNum">    3793 </span>            :               // transforms into this. Most of the time those transforms are
<span class="lineNum">    3794 </span>            :               // negligible, but in some cases (e.g. when a zoom is applied on
<span class="lineNum">    3795 </span>            :               // an overflow:hidden document) it is not (see bug 1280013).
<span class="lineNum">    3796 </span>            :               // XXX: Eventually we may want to create a modified version of
<span class="lineNum">    3797 </span>            :               // TransformRect that includes the APZ callback transforms
<span class="lineNum">    3798 </span>            :               // directly.
<span class="lineNum">    3799 </span><span class="lineNoCov">          0 :               nsLayoutUtils::TransformRect(rootFrame, mOuter, rootCompBounds);</span>
<span class="lineNum">    3800 </span><span class="lineNoCov">          0 :               rootCompBounds += CSSPoint::ToAppUnits(</span>
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :                   nsLayoutUtils::GetCumulativeApzCallbackTransform(mOuter));</span>
<span class="lineNum">    3802 </span>            : 
<span class="lineNum">    3803 </span>            :               // We want to limit displayportBase to be no larger than rootCompBounds on
<span class="lineNum">    3804 </span>            :               // either axis, but we don't want to just blindly intersect the two, because
<span class="lineNum">    3805 </span>            :               // rootCompBounds might be offset from where displayportBase is (see bug
<span class="lineNum">    3806 </span>            :               // 1327095 comment 8). Instead, we translate rootCompBounds so as to
<span class="lineNum">    3807 </span>            :               // maximize the overlap with displayportBase, and *then* do the intersection.
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :               if (rootCompBounds.x &gt; displayportBase.x &amp;&amp; rootCompBounds.XMost() &gt; displayportBase.XMost()) {</span>
<span class="lineNum">    3809 </span>            :                 // rootCompBounds is at a greater x-position for both left and right, so translate it such
<span class="lineNum">    3810 </span>            :                 // that the XMost() values are the same. This will line up the right edge of the two rects,
<span class="lineNum">    3811 </span>            :                 // and might mean that rootCompbounds.x is smaller than displayportBase.x. We can avoid that
<span class="lineNum">    3812 </span>            :                 // by taking the min of the x delta and XMost() delta, but it doesn't really matter because
<span class="lineNum">    3813 </span>            :                 // the intersection between the two rects below will end up the same.
<span class="lineNum">    3814 </span><span class="lineNoCov">          0 :                 rootCompBounds.x -= (rootCompBounds.XMost() - displayportBase.XMost());</span>
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :               } else if (rootCompBounds.x &lt; displayportBase.x &amp;&amp; rootCompBounds.XMost() &lt; displayportBase.XMost()) {</span>
<span class="lineNum">    3816 </span>            :                 // Analaogous code for when the rootCompBounds is at a smaller x-position.
<span class="lineNum">    3817 </span><span class="lineNoCov">          0 :                 rootCompBounds.x = displayportBase.x;</span>
<span class="lineNum">    3818 </span>            :               }
<span class="lineNum">    3819 </span>            :               // Do the same for y-axis
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :               if (rootCompBounds.y &gt; displayportBase.y &amp;&amp; rootCompBounds.YMost() &gt; displayportBase.YMost()) {</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :                 rootCompBounds.y -= (rootCompBounds.YMost() - displayportBase.YMost());</span>
<span class="lineNum">    3822 </span><span class="lineNoCov">          0 :               } else if (rootCompBounds.y &lt; displayportBase.y &amp;&amp; rootCompBounds.YMost() &lt; displayportBase.YMost()) {</span>
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :                 rootCompBounds.y = displayportBase.y;</span>
<span class="lineNum">    3824 </span>            :               }
<span class="lineNum">    3825 </span>            : 
<span class="lineNum">    3826 </span>            :               // Now we can do the intersection
<span class="lineNum">    3827 </span><span class="lineNoCov">          0 :               displayportBase = displayportBase.Intersect(rootCompBounds);</span>
<span class="lineNum">    3828 </span>            :             }
<span class="lineNum">    3829 </span>            :           }
<span class="lineNum">    3830 </span>            :         }
<span class="lineNum">    3831 </span>            : 
<span class="lineNum">    3832 </span><span class="lineNoCov">          0 :         displayportBase -= mScrollPort.TopLeft();</span>
<span class="lineNum">    3833 </span>            :       }
<span class="lineNum">    3834 </span>            : 
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 :       nsLayoutUtils::SetDisplayPortBase(mOuter-&gt;GetContent(), displayportBase);</span>
<span class="lineNum">    3836 </span>            :     }
<span class="lineNum">    3837 </span>            : 
<span class="lineNum">    3838 </span>            :     // If we don't have aSetBase == true then should have already
<span class="lineNum">    3839 </span>            :     // been called with aSetBase == true which should have set a
<span class="lineNum">    3840 </span>            :     // displayport base.
<span class="lineNum">    3841 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(content-&gt;GetProperty(nsGkAtoms::DisplayPortBase));</span>
<span class="lineNum">    3842 </span><span class="lineCov">        130 :     nsRect displayPort;</span>
<span class="lineNum">    3843 </span>            :     usingDisplayPort =
<span class="lineNum">    3844 </span><span class="lineCov">         65 :       nsLayoutUtils::GetDisplayPort(content, &amp;displayPort, RelativeTo::ScrollFrame);</span>
<span class="lineNum">    3845 </span>            : 
<span class="lineNum">    3846 </span><span class="lineCov">         65 :     if (usingDisplayPort) {</span>
<span class="lineNum">    3847 </span>            :       // Override the dirty rectangle if the displayport has been set.
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :       *aVisibleRect = displayPort;</span>
<span class="lineNum">    3849 </span><span class="lineNoCov">          0 :       if (!aBuilder-&gt;IsPartialUpdate() || aBuilder-&gt;InInvalidSubtree()) {</span>
<span class="lineNum">    3850 </span><span class="lineNoCov">          0 :         *aDirtyRect = displayPort;</span>
<span class="lineNum">    3851 </span><span class="lineNoCov">          0 :         if (aDirtyRectHasBeenOverriden) {</span>
<span class="lineNum">    3852 </span><span class="lineNoCov">          0 :           *aDirtyRectHasBeenOverriden = true;</span>
<span class="lineNum">    3853 </span>            :         }
<span class="lineNum">    3854 </span><span class="lineNoCov">          0 :       } else if (mOuter-&gt;HasOverrideDirtyRegion()) {</span>
<span class="lineNum">    3855 </span>            :         nsRect* rect =
<span class="lineNum">    3856 </span><span class="lineNoCov">          0 :           mOuter-&gt;GetProperty(nsDisplayListBuilder::DisplayListBuildingDisplayPortRect());</span>
<span class="lineNum">    3857 </span><span class="lineNoCov">          0 :         if (rect) {</span>
<span class="lineNum">    3858 </span><span class="lineNoCov">          0 :           *aDirtyRect = *rect;</span>
<span class="lineNum">    3859 </span><span class="lineNoCov">          0 :           if (aDirtyRectHasBeenOverriden) {</span>
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 :             *aDirtyRectHasBeenOverriden = true;</span>
<span class="lineNum">    3861 </span>            :           }
<span class="lineNum">    3862 </span>            :         }
<span class="lineNum">    3863 </span>            :       }
<span class="lineNum">    3864 </span><span class="lineCov">         65 :     } else if (mIsRoot) {</span>
<span class="lineNum">    3865 </span>            :       // The displayPort getter takes care of adjusting for resolution. So if
<span class="lineNum">    3866 </span>            :       // we have resolution but no displayPort then we need to adjust for
<span class="lineNum">    3867 </span>            :       // resolution here.
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :       nsIPresShell* presShell = mOuter-&gt;PresShell();</span>
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :       *aVisibleRect = aVisibleRect-&gt;RemoveResolution(</span>
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 :         presShell-&gt;ScaleToResolution() ? presShell-&gt;GetResolution () : 1.0f);</span>
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :       *aDirtyRect = aDirtyRect-&gt;RemoveResolution(</span>
<span class="lineNum">    3872 </span><span class="lineNoCov">          0 :         presShell-&gt;ScaleToResolution() ? presShell-&gt;GetResolution () : 1.0f);</span>
<span class="lineNum">    3873 </span>            :     }
<span class="lineNum">    3874 </span>            :   }
<span class="lineNum">    3875 </span>            : 
<span class="lineNum">    3876 </span>            :   // Since making new layers is expensive, only create a scrollable layer
<span class="lineNum">    3877 </span>            :   // for some scroll frames.
<span class="lineNum">    3878 </span>            :   // When a displayport is being used, force building of a layer so that
<span class="lineNum">    3879 </span>            :   // the compositor can find the scrollable layer for async scrolling.
<span class="lineNum">    3880 </span>            :   // If the element is marked 'scrollgrab', also force building of a layer
<span class="lineNum">    3881 </span>            :   // so that APZ can implement scroll grabbing.
<span class="lineNum">    3882 </span><span class="lineCov">         87 :   mWillBuildScrollableLayer = usingDisplayPort || nsContentUtils::HasScrollgrab(content);</span>
<span class="lineNum">    3883 </span>            : 
<span class="lineNum">    3884 </span>            :   // The cached animated geometry root for the display builder is out of
<span class="lineNum">    3885 </span>            :   // date if we just introduced a new animated geometry root.
<span class="lineNum">    3886 </span><span class="lineCov">         87 :   if (oldWillBuildScrollableLayer != mWillBuildScrollableLayer) {</span>
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :     aBuilder-&gt;RecomputeCurrentAnimatedGeometryRoot();</span>
<span class="lineNum">    3888 </span>            :   }
<span class="lineNum">    3889 </span>            : 
<span class="lineNum">    3890 </span><span class="lineCov">         87 :   if (gfxPrefs::LayoutUseContainersForRootFrames() &amp;&amp; mWillBuildScrollableLayer &amp;&amp; mIsRoot) {</span>
<span class="lineNum">    3891 </span><span class="lineNoCov">          0 :     mIsScrollableLayerInRootContainer = true;</span>
<span class="lineNum">    3892 </span>            :   }
<span class="lineNum">    3893 </span>            : 
<span class="lineNum">    3894 </span><span class="lineNoCov">          0 :   return mWillBuildScrollableLayer;</span>
<span class="lineNum">    3895 </span>            : }
<span class="lineNum">    3896 </span>            : 
<span class="lineNum">    3897 </span>            : 
<span class="lineNum">    3898 </span>            : Maybe&lt;ScrollMetadata&gt;
<span class="lineNum">    3899 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ComputeScrollMetadata(LayerManager* aLayerManager,</span>
<span class="lineNum">    3900 </span>            :                                          const nsIFrame* aContainerReferenceFrame,
<span class="lineNum">    3901 </span>            :                                          const ContainerLayerParameters&amp; aParameters,
<span class="lineNum">    3902 </span>            :                                          const DisplayItemClip* aClip) const
<span class="lineNum">    3903 </span>            : {
<span class="lineNum">    3904 </span><span class="lineNoCov">          0 :   if (!mWillBuildScrollableLayer || mIsScrollableLayerInRootContainer) {</span>
<span class="lineNum">    3905 </span>            :     return Nothing();
<span class="lineNum">    3906 </span>            :   }
<span class="lineNum">    3907 </span>            : 
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :   if (!nsLayoutUtils::UsesAsyncScrolling(mOuter)) {</span>
<span class="lineNum">    3909 </span>            :     // Return early, since if we don't use APZ we don't need FrameMetrics.
<span class="lineNum">    3910 </span>            :     return Nothing();
<span class="lineNum">    3911 </span>            :   }
<span class="lineNum">    3912 </span>            : 
<span class="lineNum">    3913 </span><span class="lineNoCov">          0 :   nsPoint toReferenceFrame = mOuter-&gt;GetOffsetToCrossDoc(aContainerReferenceFrame);</span>
<span class="lineNum">    3914 </span>            : 
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :   Maybe&lt;nsRect&gt; parentLayerClip;</span>
<span class="lineNum">    3916 </span>            :   // For containerful frames, the clip is on the container layer.
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 :   if (aClip &amp;&amp;</span>
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :       (!gfxPrefs::LayoutUseContainersForRootFrames() || mAddClipRectToLayer)) {</span>
<span class="lineNum">    3919 </span><span class="lineNoCov">          0 :     parentLayerClip = Some(aClip-&gt;GetClipRect());</span>
<span class="lineNum">    3920 </span>            :   }
<span class="lineNum">    3921 </span>            : 
<span class="lineNum">    3922 </span><span class="lineNoCov">          0 :   bool isRootContent = mIsRoot &amp;&amp; mOuter-&gt;PresContext()-&gt;IsRootContentDocument();</span>
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mScrolledFrame-&gt;GetContent());</span>
<span class="lineNum">    3925 </span>            : 
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :   nsRect scrollport = mScrollPort + toReferenceFrame;</span>
<span class="lineNum">    3927 </span>            : 
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :   return Some(nsLayoutUtils::ComputeScrollMetadata(</span>
<span class="lineNum">    3929 </span><span class="lineNoCov">          0 :     mScrolledFrame, mOuter, mOuter-&gt;GetContent(),</span>
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :     aContainerReferenceFrame, aLayerManager, mScrollParentID,</span>
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :     scrollport, parentLayerClip, isRootContent, aParameters));</span>
<span class="lineNum">    3932 </span>            : }
<span class="lineNum">    3933 </span>            : 
<span class="lineNum">    3934 </span>            : void
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ClipLayerToDisplayPort(Layer* aLayer,</span>
<span class="lineNum">    3936 </span>            :                                           const DisplayItemClip* aClip,
<span class="lineNum">    3937 </span>            :                                           const ContainerLayerParameters&amp; aParameters) const
<span class="lineNum">    3938 </span>            : {
<span class="lineNum">    3939 </span>            :   // If APZ is not enabled, we still need the displayport to be clipped
<span class="lineNum">    3940 </span>            :   // in the compositor.
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :   if (!nsLayoutUtils::UsesAsyncScrolling(mOuter)) {</span>
<span class="lineNum">    3942 </span><span class="lineNoCov">          0 :     Maybe&lt;nsRect&gt; parentLayerClip;</span>
<span class="lineNum">    3943 </span>            :     // For containerful frames, the clip is on the container layer.
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :     if (aClip &amp;&amp;</span>
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :         (!gfxPrefs::LayoutUseContainersForRootFrames() || mAddClipRectToLayer)) {</span>
<span class="lineNum">    3946 </span><span class="lineNoCov">          0 :       parentLayerClip = Some(aClip-&gt;GetClipRect());</span>
<span class="lineNum">    3947 </span>            :     }
<span class="lineNum">    3948 </span>            : 
<span class="lineNum">    3949 </span><span class="lineNoCov">          0 :     if (parentLayerClip) {</span>
<span class="lineNum">    3950 </span>            :       ParentLayerIntRect displayportClip =
<span class="lineNum">    3951 </span>            :         ViewAs&lt;ParentLayerPixel&gt;(
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :           parentLayerClip-&gt;ScaleToNearestPixels(</span>
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :             aParameters.mXScale,</span>
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :             aParameters.mYScale,</span>
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :             mScrolledFrame-&gt;PresContext()-&gt;AppUnitsPerDevPixel()));</span>
<span class="lineNum">    3956 </span>            : 
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :       ParentLayerIntRect layerClip;</span>
<span class="lineNum">    3958 </span><span class="lineNoCov">          0 :       if (const ParentLayerIntRect* origClip = aLayer-&gt;GetClipRect().ptrOr(nullptr)) {</span>
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :         layerClip = displayportClip.Intersect(*origClip);</span>
<span class="lineNum">    3960 </span>            :       } else {
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 :         layerClip = displayportClip;</span>
<span class="lineNum">    3962 </span>            :       }
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :       aLayer-&gt;SetClipRect(Some(layerClip));</span>
<span class="lineNum">    3964 </span>            :     }
<span class="lineNum">    3965 </span>            :   }
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3967 </span>            : 
<span class="lineNum">    3968 </span>            : bool
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 : ScrollFrameHelper::IsRectNearlyVisible(const nsRect&amp; aRect) const</span>
<span class="lineNum">    3970 </span>            : {
<span class="lineNum">    3971 </span>            :   // Use the right rect depending on if a display port is set.
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :   nsRect displayPort;</span>
<span class="lineNum">    3973 </span>            :   bool usingDisplayport =
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :     nsLayoutUtils::GetDisplayPort(mOuter-&gt;GetContent(), &amp;displayPort, RelativeTo::ScrollFrame);</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :   return aRect.Intersects(ExpandRectToNearlyVisible(usingDisplayport ? displayPort : mScrollPort));</span>
<span class="lineNum">    3976 </span>            : }
<span class="lineNum">    3977 </span>            : 
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 : static void HandleScrollPref(nsIScrollable *aScrollable, int32_t aOrientation,</span>
<span class="lineNum">    3979 </span>            :                              uint8_t&amp; aValue)
<span class="lineNum">    3980 </span>            : {
<span class="lineNum">    3981 </span>            :   int32_t pref;
<span class="lineNum">    3982 </span><span class="lineNoCov">          0 :   aScrollable-&gt;GetDefaultScrollbarPreferences(aOrientation, &amp;pref);</span>
<span class="lineNum">    3983 </span><span class="lineNoCov">          0 :   switch (pref) {</span>
<span class="lineNum">    3984 </span>            :     case nsIScrollable::Scrollbar_Auto:
<span class="lineNum">    3985 </span>            :       // leave |aValue| untouched
<span class="lineNum">    3986 </span>            :       break;
<span class="lineNum">    3987 </span>            :     case nsIScrollable::Scrollbar_Never:
<span class="lineNum">    3988 </span><span class="lineNoCov">          0 :       aValue = NS_STYLE_OVERFLOW_HIDDEN;</span>
<span class="lineNum">    3989 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3990 </span>            :     case nsIScrollable::Scrollbar_Always:
<span class="lineNum">    3991 </span><span class="lineNoCov">          0 :       aValue = NS_STYLE_OVERFLOW_SCROLL;</span>
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    3993 </span>            :   }
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3995 </span>            : 
<span class="lineNum">    3996 </span>            : ScrollbarStyles
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetScrollbarStylesFromFrame() const</span>
<span class="lineNum">    3998 </span>            : {
<span class="lineNum">    3999 </span><span class="lineCov">        672 :   nsPresContext* presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    4000 </span><span class="lineNoCov">          0 :   if (!presContext-&gt;IsDynamic() &amp;&amp;</span>
<span class="lineNum">    4001 </span><span class="lineNoCov">          0 :       !(mIsRoot &amp;&amp; presContext-&gt;HasPaginatedScrolling())) {</span>
<span class="lineNum">    4002 </span><span class="lineNoCov">          0 :     return ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN, NS_STYLE_OVERFLOW_HIDDEN);</span>
<span class="lineNum">    4003 </span>            :   }
<span class="lineNum">    4004 </span>            : 
<span class="lineNum">    4005 </span><span class="lineCov">        336 :   if (!mIsRoot) {</span>
<span class="lineNum">    4006 </span><span class="lineNoCov">          0 :     const nsStyleDisplay* disp = mOuter-&gt;StyleDisplay();</span>
<span class="lineNum">    4007 </span><span class="lineCov">        302 :     return ScrollbarStyles(disp);</span>
<span class="lineNum">    4008 </span>            :   }
<span class="lineNum">    4009 </span>            : 
<span class="lineNum">    4010 </span><span class="lineNoCov">          0 :   ScrollbarStyles result = presContext-&gt;GetViewportScrollbarStylesOverride();</span>
<span class="lineNum">    4011 </span><span class="lineCov">         68 :   nsCOMPtr&lt;nsISupports&gt; container = presContext-&gt;GetContainerWeak();</span>
<span class="lineNum">    4012 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIScrollable&gt; scrollable = do_QueryInterface(container);</span>
<span class="lineNum">    4013 </span><span class="lineNoCov">          0 :   if (scrollable) {</span>
<span class="lineNum">    4014 </span><span class="lineNoCov">          0 :     HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_X,</span>
<span class="lineNum">    4015 </span><span class="lineNoCov">          0 :                      result.mHorizontal);</span>
<span class="lineNum">    4016 </span><span class="lineCov">         10 :     HandleScrollPref(scrollable, nsIScrollable::ScrollOrientation_Y,</span>
<span class="lineNum">    4017 </span><span class="lineCov">         10 :                      result.mVertical);</span>
<span class="lineNum">    4018 </span>            :   }
<span class="lineNum">    4019 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    4020 </span>            : }
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span>            : nsRect
<span class="lineNum">    4023 </span><span class="lineCov">        151 : ScrollFrameHelper::GetScrollRange() const</span>
<span class="lineNum">    4024 </span>            : {
<span class="lineNum">    4025 </span><span class="lineNoCov">          0 :   return GetScrollRange(mScrollPort.width, mScrollPort.height);</span>
<span class="lineNum">    4026 </span>            : }
<span class="lineNum">    4027 </span>            : 
<span class="lineNum">    4028 </span>            : nsRect
<span class="lineNum">    4029 </span><span class="lineCov">        207 : ScrollFrameHelper::GetScrollRange(nscoord aWidth, nscoord aHeight) const</span>
<span class="lineNum">    4030 </span>            : {
<span class="lineNum">    4031 </span><span class="lineCov">        207 :   nsRect range = GetScrolledRect();</span>
<span class="lineNum">    4032 </span><span class="lineNoCov">          0 :   range.width = std::max(range.width - aWidth, 0);</span>
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :   range.height = std::max(range.height - aHeight, 0);</span>
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :   return range;</span>
<span class="lineNum">    4035 </span>            : }
<span class="lineNum">    4036 </span>            : 
<span class="lineNum">    4037 </span>            : nsRect
<span class="lineNum">    4038 </span><span class="lineCov">         56 : ScrollFrameHelper::GetScrollRangeForClamping() const</span>
<span class="lineNum">    4039 </span>            : {
<span class="lineNum">    4040 </span><span class="lineNoCov">          0 :   if (!ShouldClampScrollPosition()) {</span>
<span class="lineNum">    4041 </span>            :     return nsRect(nscoord_MIN/2, nscoord_MIN/2,
<span class="lineNum">    4042 </span>            :                   nscoord_MAX - nscoord_MIN/2, nscoord_MAX - nscoord_MIN/2);
<span class="lineNum">    4043 </span>            :   }
<span class="lineNum">    4044 </span><span class="lineNoCov">          0 :   nsSize scrollPortSize = GetScrollPositionClampingScrollPortSize();</span>
<span class="lineNum">    4045 </span><span class="lineNoCov">          0 :   return GetScrollRange(scrollPortSize.width, scrollPortSize.height);</span>
<span class="lineNum">    4046 </span>            : }
<span class="lineNum">    4047 </span>            : 
<span class="lineNum">    4048 </span>            : nsSize
<span class="lineNum">    4049 </span><span class="lineCov">        167 : ScrollFrameHelper::GetScrollPositionClampingScrollPortSize() const</span>
<span class="lineNum">    4050 </span>            : {
<span class="lineNum">    4051 </span><span class="lineCov">        167 :   nsIPresShell* presShell = mOuter-&gt;PresShell();</span>
<span class="lineNum">    4052 </span><span class="lineCov">        228 :   if (mIsRoot &amp;&amp; presShell-&gt;IsScrollPositionClampingScrollPortSizeSet()) {</span>
<span class="lineNum">    4053 </span><span class="lineNoCov">          0 :     return presShell-&gt;GetScrollPositionClampingScrollPortSize();</span>
<span class="lineNum">    4054 </span>            :   }
<span class="lineNum">    4055 </span><span class="lineCov">        167 :   return mScrollPort.Size();</span>
<span class="lineNum">    4056 </span>            : }
<span class="lineNum">    4057 </span>            : 
<span class="lineNum">    4058 </span>            : static void
<span class="lineNum">    4059 </span><span class="lineNoCov">          0 : AdjustForWholeDelta(int32_t aDelta, nscoord* aCoord)</span>
<span class="lineNum">    4060 </span>            : {
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :   if (aDelta &lt; 0) {</span>
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 :     *aCoord = nscoord_MIN;</span>
<span class="lineNum">    4063 </span><span class="lineNoCov">          0 :   } else if (aDelta &gt; 0) {</span>
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :     *aCoord = nscoord_MAX;</span>
<span class="lineNum">    4065 </span>            :   }
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span>            : /**
<span class="lineNum">    4069 </span>            :  * Calculate lower/upper scrollBy range in given direction.
<span class="lineNum">    4070 </span>            :  * @param aDelta specifies scrollBy direction, if 0 then range will be 0 size
<span class="lineNum">    4071 </span>            :  * @param aPos desired destination in AppUnits
<span class="lineNum">    4072 </span>            :  * @param aNeg/PosTolerance defines relative range distance
<span class="lineNum">    4073 </span>            :  *   below and above of aPos point
<span class="lineNum">    4074 </span>            :  * @param aMultiplier used for conversion of tolerance into appUnis
<span class="lineNum">    4075 </span>            :  */
<span class="lineNum">    4076 </span>            : static void
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 : CalcRangeForScrollBy(int32_t aDelta, nscoord aPos,</span>
<span class="lineNum">    4078 </span>            :                      float aNegTolerance,
<span class="lineNum">    4079 </span>            :                      float aPosTolerance,
<span class="lineNum">    4080 </span>            :                      nscoord aMultiplier,
<span class="lineNum">    4081 </span>            :                      nscoord* aLower, nscoord* aUpper)
<span class="lineNum">    4082 </span>            : {
<span class="lineNum">    4083 </span><span class="lineNoCov">          0 :   if (!aDelta) {</span>
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :     *aLower = *aUpper = aPos;</span>
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4086 </span>            :   }
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :   *aLower = aPos - NSToCoordRound(aMultiplier * (aDelta &gt; 0 ? aNegTolerance : aPosTolerance));</span>
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 :   *aUpper = aPos + NSToCoordRound(aMultiplier * (aDelta &gt; 0 ? aPosTolerance : aNegTolerance));</span>
<span class="lineNum">    4089 </span>            : }
<span class="lineNum">    4090 </span>            : 
<span class="lineNum">    4091 </span>            : void
<span class="lineNum">    4092 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollBy(nsIntPoint aDelta,</span>
<span class="lineNum">    4093 </span>            :                             nsIScrollableFrame::ScrollUnit aUnit,
<span class="lineNum">    4094 </span>            :                             nsIScrollableFrame::ScrollMode aMode,
<span class="lineNum">    4095 </span>            :                             nsIntPoint* aOverflow,
<span class="lineNum">    4096 </span>            :                             nsAtom *aOrigin,
<span class="lineNum">    4097 </span>            :                             nsIScrollableFrame::ScrollMomentum aMomentum,
<span class="lineNum">    4098 </span>            :                             nsIScrollbarMediator::ScrollSnapMode aSnap)
<span class="lineNum">    4099 </span>            : {
<span class="lineNum">    4100 </span>            :   // When a smooth scroll is being processed on a frame, mouse wheel and trackpad
<span class="lineNum">    4101 </span>            :   // momentum scroll event updates must notcancel the SMOOTH or SMOOTH_MSD
<span class="lineNum">    4102 </span>            :   // scroll animations, enabling Javascript that depends on them to be responsive
<span class="lineNum">    4103 </span>            :   // without forcing the user to wait for the fling animations to completely stop.
<span class="lineNum">    4104 </span><span class="lineNoCov">          0 :   switch (aMomentum) {</span>
<span class="lineNum">    4105 </span>            :   case nsIScrollableFrame::NOT_MOMENTUM:
<span class="lineNum">    4106 </span><span class="lineNoCov">          0 :     mIgnoreMomentumScroll = false;</span>
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4108 </span>            :   case nsIScrollableFrame::SYNTHESIZED_MOMENTUM_EVENT:
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :     if (mIgnoreMomentumScroll) {</span>
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4111 </span>            :     }
<span class="lineNum">    4112 </span>            :     break;
<span class="lineNum">    4113 </span>            :   }
<span class="lineNum">    4114 </span>            : 
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :   if (mAsyncSmoothMSDScroll != nullptr) {</span>
<span class="lineNum">    4116 </span>            :     // When CSSOM-View scroll-behavior smooth scrolling is interrupted,
<span class="lineNum">    4117 </span>            :     // the scroll is not completed to avoid non-smooth snapping to the
<span class="lineNum">    4118 </span>            :     // prior smooth scroll's destination.
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :     mDestination = GetScrollPosition();</span>
<span class="lineNum">    4120 </span>            :   }
<span class="lineNum">    4121 </span>            : 
<span class="lineNum">    4122 </span><span class="lineNoCov">          0 :   nsSize deltaMultiplier;</span>
<span class="lineNum">    4123 </span>            :   float negativeTolerance;
<span class="lineNum">    4124 </span>            :   float positiveTolerance;
<span class="lineNum">    4125 </span><span class="lineNoCov">          0 :   if (!aOrigin){</span>
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 :     aOrigin = nsGkAtoms::other;</span>
<span class="lineNum">    4127 </span>            :   }
<span class="lineNum">    4128 </span><span class="lineNoCov">          0 :   bool isGenericOrigin = (aOrigin == nsGkAtoms::other);</span>
<span class="lineNum">    4129 </span><span class="lineNoCov">          0 :   switch (aUnit) {</span>
<span class="lineNum">    4130 </span>            :   case nsIScrollableFrame::DEVICE_PIXELS: {
<span class="lineNum">    4131 </span>            :     nscoord appUnitsPerDevPixel =
<span class="lineNum">    4132 </span><span class="lineNoCov">          0 :       mOuter-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    4133 </span><span class="lineNoCov">          0 :     deltaMultiplier = nsSize(appUnitsPerDevPixel, appUnitsPerDevPixel);</span>
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :     if (isGenericOrigin){</span>
<span class="lineNum">    4135 </span><span class="lineNoCov">          0 :       aOrigin = nsGkAtoms::pixels;</span>
<span class="lineNum">    4136 </span>            :     }
<span class="lineNum">    4137 </span>            :     negativeTolerance = positiveTolerance = 0.5f;
<span class="lineNum">    4138 </span>            :     break;
<span class="lineNum">    4139 </span>            :   }
<span class="lineNum">    4140 </span>            :   case nsIScrollableFrame::LINES: {
<span class="lineNum">    4141 </span><span class="lineNoCov">          0 :     deltaMultiplier = GetLineScrollAmount();</span>
<span class="lineNum">    4142 </span><span class="lineNoCov">          0 :     if (isGenericOrigin){</span>
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 :       aOrigin = nsGkAtoms::lines;</span>
<span class="lineNum">    4144 </span>            :     }
<span class="lineNum">    4145 </span>            :     negativeTolerance = positiveTolerance = 0.1f;
<span class="lineNum">    4146 </span>            :     break;
<span class="lineNum">    4147 </span>            :   }
<span class="lineNum">    4148 </span>            :   case nsIScrollableFrame::PAGES: {
<span class="lineNum">    4149 </span><span class="lineNoCov">          0 :     deltaMultiplier = GetPageScrollAmount();</span>
<span class="lineNum">    4150 </span><span class="lineNoCov">          0 :     if (isGenericOrigin){</span>
<span class="lineNum">    4151 </span><span class="lineNoCov">          0 :       aOrigin = nsGkAtoms::pages;</span>
<span class="lineNum">    4152 </span>            :     }
<span class="lineNum">    4153 </span>            :     negativeTolerance = 0.05f;
<span class="lineNum">    4154 </span>            :     positiveTolerance = 0;
<span class="lineNum">    4155 </span>            :     break;
<span class="lineNum">    4156 </span>            :   }
<span class="lineNum">    4157 </span>            :   case nsIScrollableFrame::WHOLE: {
<span class="lineNum">    4158 </span><span class="lineNoCov">          0 :     nsPoint pos = GetScrollPosition();</span>
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :     AdjustForWholeDelta(aDelta.x, &amp;pos.x);</span>
<span class="lineNum">    4160 </span><span class="lineNoCov">          0 :     AdjustForWholeDelta(aDelta.y, &amp;pos.y);</span>
<span class="lineNum">    4161 </span><span class="lineNoCov">          0 :     if (aSnap == nsIScrollableFrame::ENABLE_SNAP) {</span>
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :       GetSnapPointForDestination(aUnit, mDestination, pos);</span>
<span class="lineNum">    4163 </span>            :     }
<span class="lineNum">    4164 </span><span class="lineNoCov">          0 :     ScrollTo(pos, aMode);</span>
<span class="lineNum">    4165 </span>            :     // 'this' might be destroyed here
<span class="lineNum">    4166 </span><span class="lineNoCov">          0 :     if (aOverflow) {</span>
<span class="lineNum">    4167 </span><span class="lineNoCov">          0 :       *aOverflow = nsIntPoint(0, 0);</span>
<span class="lineNum">    4168 </span>            :     }
<span class="lineNum">    4169 </span>            :     return;
<span class="lineNum">    4170 </span>            :   }
<span class="lineNum">    4171 </span>            :   default:
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :     NS_ERROR(&quot;Invalid scroll mode&quot;);</span>
<span class="lineNum">    4173 </span>            :     return;
<span class="lineNum">    4174 </span>            :   }
<span class="lineNum">    4175 </span>            : 
<span class="lineNum">    4176 </span><span class="lineNoCov">          0 :   nsPoint newPos = mDestination + nsPoint(aDelta.x*deltaMultiplier.width, aDelta.y*deltaMultiplier.height);</span>
<span class="lineNum">    4177 </span>            : 
<span class="lineNum">    4178 </span><span class="lineNoCov">          0 :   if (aSnap == nsIScrollableFrame::ENABLE_SNAP) {</span>
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :     ScrollbarStyles styles = GetScrollbarStylesFromFrame();</span>
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :     if (styles.mScrollSnapTypeY != NS_STYLE_SCROLL_SNAP_TYPE_NONE ||</span>
<span class="lineNum">    4181 </span>            :         styles.mScrollSnapTypeX != NS_STYLE_SCROLL_SNAP_TYPE_NONE) {
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :       nscoord appUnitsPerDevPixel = mOuter-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    4183 </span><span class="lineNoCov">          0 :       deltaMultiplier = nsSize(appUnitsPerDevPixel, appUnitsPerDevPixel);</span>
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :       negativeTolerance = 0.1f;</span>
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :       positiveTolerance = 0;</span>
<span class="lineNum">    4186 </span><span class="lineNoCov">          0 :       nsIScrollableFrame::ScrollUnit snapUnit = aUnit;</span>
<span class="lineNum">    4187 </span><span class="lineNoCov">          0 :       if (aOrigin == nsGkAtoms::mouseWheel) {</span>
<span class="lineNum">    4188 </span>            :         // When using a clicky scroll wheel, snap point selection works the same
<span class="lineNum">    4189 </span>            :         // as keyboard up/down/left/right navigation, but with varying amounts
<span class="lineNum">    4190 </span>            :         // of scroll delta.
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :         snapUnit = nsIScrollableFrame::LINES;</span>
<span class="lineNum">    4192 </span>            :       }
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :       GetSnapPointForDestination(snapUnit, mDestination, newPos);</span>
<span class="lineNum">    4194 </span>            :     }
<span class="lineNum">    4195 </span>            :   }
<span class="lineNum">    4196 </span>            : 
<span class="lineNum">    4197 </span>            :   // Calculate desired range values.
<span class="lineNum">    4198 </span>            :   nscoord rangeLowerX, rangeUpperX, rangeLowerY, rangeUpperY;
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :   CalcRangeForScrollBy(aDelta.x, newPos.x, negativeTolerance, positiveTolerance,</span>
<span class="lineNum">    4200 </span><span class="lineNoCov">          0 :                        deltaMultiplier.width, &amp;rangeLowerX, &amp;rangeUpperX);</span>
<span class="lineNum">    4201 </span><span class="lineNoCov">          0 :   CalcRangeForScrollBy(aDelta.y, newPos.y, negativeTolerance, positiveTolerance,</span>
<span class="lineNum">    4202 </span><span class="lineNoCov">          0 :                        deltaMultiplier.height, &amp;rangeLowerY, &amp;rangeUpperY);</span>
<span class="lineNum">    4203 </span>            :   nsRect range(rangeLowerX,
<span class="lineNum">    4204 </span>            :                rangeLowerY,
<span class="lineNum">    4205 </span>            :                rangeUpperX - rangeLowerX,
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :                rangeUpperY - rangeLowerY);</span>
<span class="lineNum">    4207 </span><span class="lineNoCov">          0 :   AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    4208 </span><span class="lineNoCov">          0 :   ScrollToWithOrigin(newPos, aMode, aOrigin, &amp;range);</span>
<span class="lineNum">    4209 </span><span class="lineNoCov">          0 :   if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    4210 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4211 </span>            :   }
<span class="lineNum">    4212 </span>            : 
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :   if (aOverflow) {</span>
<span class="lineNum">    4214 </span><span class="lineNoCov">          0 :     nsPoint clampAmount = newPos - mDestination;</span>
<span class="lineNum">    4215 </span><span class="lineNoCov">          0 :     float appUnitsPerDevPixel = mOuter-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    4216 </span><span class="lineNoCov">          0 :     *aOverflow = nsIntPoint(</span>
<span class="lineNum">    4217 </span>            :         NSAppUnitsToIntPixels(clampAmount.x, appUnitsPerDevPixel),
<span class="lineNum">    4218 </span>            :         NSAppUnitsToIntPixels(clampAmount.y, appUnitsPerDevPixel));
<span class="lineNum">    4219 </span>            :   }
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span><span class="lineNoCov">          0 :   if (aUnit == nsIScrollableFrame::DEVICE_PIXELS &amp;&amp;</span>
<span class="lineNum">    4222 </span><span class="lineNoCov">          0 :       !nsLayoutUtils::AsyncPanZoomEnabled(mOuter)) {</span>
<span class="lineNum">    4223 </span>            :     // When APZ is disabled, we must track the velocity
<span class="lineNum">    4224 </span>            :     // on the main thread; otherwise, the APZC will manage this.
<span class="lineNum">    4225 </span><span class="lineNoCov">          0 :     mVelocityQueue.Sample(GetScrollPosition());</span>
<span class="lineNum">    4226 </span>            :   }
<span class="lineNum">    4227 </span>            : }
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span>            : void
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollSnap(nsIScrollableFrame::ScrollMode aMode)</span>
<span class="lineNum">    4231 </span>            : {
<span class="lineNum">    4232 </span><span class="lineNoCov">          0 :   float flingSensitivity = gfxPrefs::ScrollSnapPredictionSensitivity();</span>
<span class="lineNum">    4233 </span><span class="lineNoCov">          0 :   int maxVelocity = gfxPrefs::ScrollSnapPredictionMaxVelocity();</span>
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 :   maxVelocity = nsPresContext::CSSPixelsToAppUnits(maxVelocity);</span>
<span class="lineNum">    4235 </span><span class="lineNoCov">          0 :   int maxOffset = maxVelocity * flingSensitivity;</span>
<span class="lineNum">    4236 </span><span class="lineNoCov">          0 :   nsPoint velocity = mVelocityQueue.GetVelocity();</span>
<span class="lineNum">    4237 </span>            :   // Multiply each component individually to avoid integer multiply
<span class="lineNum">    4238 </span><span class="lineNoCov">          0 :   nsPoint predictedOffset = nsPoint(velocity.x * flingSensitivity,</span>
<span class="lineNum">    4239 </span><span class="lineNoCov">          0 :                                     velocity.y * flingSensitivity);</span>
<span class="lineNum">    4240 </span><span class="lineNoCov">          0 :   predictedOffset.Clamp(maxOffset);</span>
<span class="lineNum">    4241 </span><span class="lineNoCov">          0 :   nsPoint pos = GetScrollPosition();</span>
<span class="lineNum">    4242 </span><span class="lineNoCov">          0 :   nsPoint destinationPos = pos + predictedOffset;</span>
<span class="lineNum">    4243 </span><span class="lineNoCov">          0 :   ScrollSnap(destinationPos, aMode);</span>
<span class="lineNum">    4244 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4245 </span>            : 
<span class="lineNum">    4246 </span>            : void
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollSnap(const nsPoint &amp;aDestination,</span>
<span class="lineNum">    4248 </span>            :                               nsIScrollableFrame::ScrollMode aMode)
<span class="lineNum">    4249 </span>            : {
<span class="lineNum">    4250 </span><span class="lineNoCov">          0 :   nsRect scrollRange = GetScrollRangeForClamping();</span>
<span class="lineNum">    4251 </span><span class="lineNoCov">          0 :   nsPoint pos = GetScrollPosition();</span>
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :   nsPoint snapDestination = scrollRange.ClampPoint(aDestination);</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :   if (GetSnapPointForDestination(nsIScrollableFrame::DEVICE_PIXELS,</span>
<span class="lineNum">    4254 </span>            :                                                  pos,
<span class="lineNum">    4255 </span>            :                                                  snapDestination)) {
<span class="lineNum">    4256 </span><span class="lineNoCov">          0 :     ScrollTo(snapDestination, aMode);</span>
<span class="lineNum">    4257 </span>            :   }
<span class="lineNum">    4258 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4259 </span>            : 
<span class="lineNum">    4260 </span>            : nsSize
<span class="lineNum">    4261 </span><span class="lineCov">          5 : ScrollFrameHelper::GetLineScrollAmount() const</span>
<span class="lineNum">    4262 </span>            : {
<span class="lineNum">    4263 </span>            :   RefPtr&lt;nsFontMetrics&gt; fm =
<span class="lineNum">    4264 </span><span class="lineCov">         15 :     nsLayoutUtils::GetInflatedFontMetricsForFrame(mOuter);</span>
<span class="lineNum">    4265 </span><span class="lineCov">          5 :   NS_ASSERTION(fm, &quot;FontMetrics is null, assuming fontHeight == 1 appunit&quot;);</span>
<span class="lineNum">    4266 </span>            :   static nscoord sMinLineScrollAmountInPixels = -1;
<span class="lineNum">    4267 </span><span class="lineCov">          5 :   if (sMinLineScrollAmountInPixels &lt; 0) {</span>
<span class="lineNum">    4268 </span>            :     Preferences::AddIntVarCache(&amp;sMinLineScrollAmountInPixels,
<span class="lineNum">    4269 </span><span class="lineCov">          1 :                                 &quot;mousewheel.min_line_scroll_amount&quot;, 1);</span>
<span class="lineNum">    4270 </span>            :   }
<span class="lineNum">    4271 </span><span class="lineCov">         10 :   int32_t appUnitsPerDevPixel = mOuter-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    4272 </span>            :   nscoord minScrollAmountInAppUnits =
<span class="lineNum">    4273 </span><span class="lineCov">         10 :     std::max(1, sMinLineScrollAmountInPixels) * appUnitsPerDevPixel;</span>
<span class="lineNum">    4274 </span><span class="lineCov">          5 :   nscoord horizontalAmount = fm ? fm-&gt;AveCharWidth() : 0;</span>
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :   nscoord verticalAmount = fm ? fm-&gt;MaxHeight() : 0;</span>
<span class="lineNum">    4276 </span><span class="lineCov">         15 :   return nsSize(std::max(horizontalAmount, minScrollAmountInAppUnits),</span>
<span class="lineNum">    4277 </span><span class="lineCov">         15 :                 std::max(verticalAmount, minScrollAmountInAppUnits));</span>
<span class="lineNum">    4278 </span>            : }
<span class="lineNum">    4279 </span>            : 
<span class="lineNum">    4280 </span>            : /**
<span class="lineNum">    4281 </span>            :  * Compute the scrollport size excluding any fixed-pos headers and
<span class="lineNum">    4282 </span>            :  * footers. A header or footer is an box that spans that entire width
<span class="lineNum">    4283 </span>            :  * of the viewport and touches the top (or bottom, respectively) of the
<span class="lineNum">    4284 </span>            :  * viewport. We also want to consider fixed elements that stack or overlap
<span class="lineNum">    4285 </span>            :  * to effectively create a larger header or footer. Headers and footers that
<span class="lineNum">    4286 </span>            :  * cover more than a third of the the viewport are ignored since they
<span class="lineNum">    4287 </span>            :  * probably aren't true headers and footers and we don't want to restrict
<span class="lineNum">    4288 </span>            :  * scrolling too much in such cases. This is a bit conservative --- some
<span class="lineNum">    4289 </span>            :  * pages use elements as headers or footers that don't span the entire width
<span class="lineNum">    4290 </span>            :  * of the viewport --- but it should be a good start.
<span class="lineNum">    4291 </span>            :  */
<span class="lineNum">    4292 </span>            : struct TopAndBottom
<span class="lineNum">    4293 </span>            : {
<span class="lineNum">    4294 </span><span class="lineNoCov">          0 :   TopAndBottom(nscoord aTop, nscoord aBottom) : top(aTop), bottom(aBottom) {}</span>
<span class="lineNum">    4295 </span>            : 
<span class="lineNum">    4296 </span>            :   nscoord top, bottom;
<span class="lineNum">    4297 </span>            : };
<span class="lineNum">    4298 </span>            : struct TopComparator
<span class="lineNum">    4299 </span>            : {
<span class="lineNum">    4300 </span>            :   bool Equals(const TopAndBottom&amp; A, const TopAndBottom&amp; B) const {
<span class="lineNum">    4301 </span>            :     return A.top == B.top;
<span class="lineNum">    4302 </span>            :   }
<span class="lineNum">    4303 </span>            :   bool LessThan(const TopAndBottom&amp; A, const TopAndBottom&amp; B) const {
<span class="lineNum">    4304 </span>            :     return A.top &lt; B.top;
<span class="lineNum">    4305 </span>            :   }
<span class="lineNum">    4306 </span>            : };
<span class="lineNum">    4307 </span>            : struct ReverseBottomComparator
<span class="lineNum">    4308 </span>            : {
<span class="lineNum">    4309 </span>            :   bool Equals(const TopAndBottom&amp; A, const TopAndBottom&amp; B) const {
<span class="lineNum">    4310 </span>            :     return A.bottom == B.bottom;
<span class="lineNum">    4311 </span>            :   }
<span class="lineNum">    4312 </span>            :   bool LessThan(const TopAndBottom&amp; A, const TopAndBottom&amp; B) const {
<span class="lineNum">    4313 </span>            :     return A.bottom &gt; B.bottom;
<span class="lineNum">    4314 </span>            :   }
<span class="lineNum">    4315 </span>            : };
<span class="lineNum">    4316 </span>            : static nsSize
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 : GetScrollPortSizeExcludingHeadersAndFooters(nsIFrame* aViewportFrame,</span>
<span class="lineNum">    4318 </span>            :                                             const nsRect&amp; aScrollPort)
<span class="lineNum">    4319 </span>            : {
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :   AutoTArray&lt;TopAndBottom, 50&gt; list;</span>
<span class="lineNum">    4321 </span><span class="lineNoCov">          0 :   nsFrameList fixedFrames = aViewportFrame-&gt;GetChildList(nsIFrame::kFixedList);</span>
<span class="lineNum">    4322 </span><span class="lineNoCov">          0 :   for (nsFrameList::Enumerator iterator(fixedFrames); !iterator.AtEnd();</span>
<span class="lineNum">    4323 </span><span class="lineNoCov">          0 :        iterator.Next()) {</span>
<span class="lineNum">    4324 </span><span class="lineNoCov">          0 :     nsIFrame* f = iterator.get();</span>
<span class="lineNum">    4325 </span><span class="lineNoCov">          0 :     nsRect r = f-&gt;GetRectRelativeToSelf();</span>
<span class="lineNum">    4326 </span><span class="lineNoCov">          0 :     r = nsLayoutUtils::TransformFrameRectToAncestor(f, r, aViewportFrame);</span>
<span class="lineNum">    4327 </span><span class="lineNoCov">          0 :     r = r.Intersect(aScrollPort);</span>
<span class="lineNum">    4328 </span><span class="lineNoCov">          0 :     if ((r.width &gt;= aScrollPort.width / 2 ||</span>
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 :          r.width &gt;= NSIntPixelsToAppUnits(800, AppUnitsPerCSSPixel())) &amp;&amp;</span>
<span class="lineNum">    4330 </span><span class="lineNoCov">          0 :         r.height &lt;= aScrollPort.height/3) {</span>
<span class="lineNum">    4331 </span><span class="lineNoCov">          0 :       list.AppendElement(TopAndBottom(r.y, r.YMost()));</span>
<span class="lineNum">    4332 </span>            :     }
<span class="lineNum">    4333 </span>            :   }
<span class="lineNum">    4334 </span>            : 
<span class="lineNum">    4335 </span><span class="lineNoCov">          0 :   list.Sort(TopComparator());</span>
<span class="lineNum">    4336 </span><span class="lineNoCov">          0 :   nscoord headerBottom = 0;</span>
<span class="lineNum">    4337 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; list.Length(); ++i) {</span>
<span class="lineNum">    4338 </span><span class="lineNoCov">          0 :     if (list[i].top &lt;= headerBottom) {</span>
<span class="lineNum">    4339 </span><span class="lineNoCov">          0 :       headerBottom = std::max(headerBottom, list[i].bottom);</span>
<span class="lineNum">    4340 </span>            :     }
<span class="lineNum">    4341 </span>            :   }
<span class="lineNum">    4342 </span>            : 
<span class="lineNum">    4343 </span><span class="lineNoCov">          0 :   list.Sort(ReverseBottomComparator());</span>
<span class="lineNum">    4344 </span><span class="lineNoCov">          0 :   nscoord footerTop = aScrollPort.height;</span>
<span class="lineNum">    4345 </span><span class="lineNoCov">          0 :   for (uint32_t i = 0; i &lt; list.Length(); ++i) {</span>
<span class="lineNum">    4346 </span><span class="lineNoCov">          0 :     if (list[i].bottom &gt;= footerTop) {</span>
<span class="lineNum">    4347 </span><span class="lineNoCov">          0 :       footerTop = std::min(footerTop, list[i].top);</span>
<span class="lineNum">    4348 </span>            :     }
<span class="lineNum">    4349 </span>            :   }
<span class="lineNum">    4350 </span>            : 
<span class="lineNum">    4351 </span><span class="lineNoCov">          0 :   headerBottom = std::min(aScrollPort.height/3, headerBottom);</span>
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :   footerTop = std::max(aScrollPort.height - aScrollPort.height/3, footerTop);</span>
<span class="lineNum">    4353 </span>            : 
<span class="lineNum">    4354 </span><span class="lineNoCov">          0 :   return nsSize(aScrollPort.width, footerTop - headerBottom);</span>
<span class="lineNum">    4355 </span>            : }
<span class="lineNum">    4356 </span>            : 
<span class="lineNum">    4357 </span>            : nsSize
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetPageScrollAmount() const</span>
<span class="lineNum">    4359 </span>            : {
<span class="lineNum">    4360 </span><span class="lineNoCov">          0 :   nsSize lineScrollAmount = GetLineScrollAmount();</span>
<span class="lineNum">    4361 </span><span class="lineNoCov">          0 :   nsSize effectiveScrollPortSize;</span>
<span class="lineNum">    4362 </span><span class="lineNoCov">          0 :   if (mIsRoot) {</span>
<span class="lineNum">    4363 </span>            :     // Reduce effective scrollport height by the height of any fixed-pos
<span class="lineNum">    4364 </span>            :     // headers or footers
<span class="lineNum">    4365 </span><span class="lineNoCov">          0 :     nsIFrame* root = mOuter-&gt;PresShell()-&gt;GetRootFrame();</span>
<span class="lineNum">    4366 </span>            :     effectiveScrollPortSize =
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 :       GetScrollPortSizeExcludingHeadersAndFooters(root, mScrollPort);</span>
<span class="lineNum">    4368 </span>            :   } else {
<span class="lineNum">    4369 </span><span class="lineNoCov">          0 :     effectiveScrollPortSize = mScrollPort.Size();</span>
<span class="lineNum">    4370 </span>            :   }
<span class="lineNum">    4371 </span>            :   // The page increment is the size of the page, minus the smaller of
<span class="lineNum">    4372 </span>            :   // 10% of the size or 2 lines.
<span class="lineNum">    4373 </span><span class="lineNoCov">          0 :   return nsSize(</span>
<span class="lineNum">    4374 </span>            :     effectiveScrollPortSize.width -
<span class="lineNum">    4375 </span><span class="lineNoCov">          0 :       std::min(effectiveScrollPortSize.width/10, 2*lineScrollAmount.width),</span>
<span class="lineNum">    4376 </span>            :     effectiveScrollPortSize.height -
<span class="lineNum">    4377 </span><span class="lineNoCov">          0 :       std::min(effectiveScrollPortSize.height/10, 2*lineScrollAmount.height));</span>
<span class="lineNum">    4378 </span>            : }
<span class="lineNum">    4379 </span>            : 
<span class="lineNum">    4380 </span>            :   /**
<span class="lineNum">    4381 </span>            :    * this code is resposible for restoring the scroll position back to some
<span class="lineNum">    4382 </span>            :    * saved position. if the user has not moved the scroll position manually
<span class="lineNum">    4383 </span>            :    * we keep scrolling down until we get to our original position. keep in
<span class="lineNum">    4384 </span>            :    * mind that content could incrementally be coming in. we only want to stop
<span class="lineNum">    4385 </span>            :    * when we reach our new position.
<span class="lineNum">    4386 </span>            :    */
<span class="lineNum">    4387 </span>            : void
<span class="lineNum">    4388 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollToRestoredPosition()</span>
<span class="lineNum">    4389 </span>            : {
<span class="lineNum">    4390 </span><span class="lineNoCov">          0 :   if (mRestorePos.y == -1 || mLastPos.x == -1 || mLastPos.y == -1) {</span>
<span class="lineNum">    4391 </span>            :     return;
<span class="lineNum">    4392 </span>            :   }
<span class="lineNum">    4393 </span>            :   // make sure our scroll position did not change for where we last put
<span class="lineNum">    4394 </span>            :   // it. if it does then the user must have moved it, and we no longer
<span class="lineNum">    4395 </span>            :   // need to restore.
<span class="lineNum">    4396 </span>            :   //
<span class="lineNum">    4397 </span>            :   // In the RTL case, we check whether the scroll position changed using the
<span class="lineNum">    4398 </span>            :   // logical scroll position, but we scroll to the physical scroll position in
<span class="lineNum">    4399 </span>            :   // all cases
<span class="lineNum">    4400 </span>            : 
<span class="lineNum">    4401 </span>            :   // if we didn't move, we still need to restore
<span class="lineNum">    4402 </span><span class="lineNoCov">          0 :   if (GetLogicalScrollPosition() == mLastPos) {</span>
<span class="lineNum">    4403 </span>            :     // if our desired position is different to the scroll position, scroll.
<span class="lineNum">    4404 </span>            :     // remember that we could be incrementally loading so we may enter
<span class="lineNum">    4405 </span>            :     // and scroll many times.
<span class="lineNum">    4406 </span><span class="lineNoCov">          0 :     if (mRestorePos != mLastPos /* GetLogicalScrollPosition() */) {</span>
<span class="lineNum">    4407 </span><span class="lineNoCov">          0 :       LoadingState state = GetPageLoadingState();</span>
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 :       if (state == LoadingState::Stopped &amp;&amp; !NS_SUBTREE_DIRTY(mOuter)) {</span>
<span class="lineNum">    4409 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    4410 </span>            :       }
<span class="lineNum">    4411 </span><span class="lineNoCov">          0 :       nsPoint scrollToPos = mRestorePos;</span>
<span class="lineNum">    4412 </span><span class="lineNoCov">          0 :       if (!IsPhysicalLTR()) {</span>
<span class="lineNum">    4413 </span>            :         // convert from logical to physical scroll position
<span class="lineNum">    4414 </span><span class="lineNoCov">          0 :         scrollToPos.x = mScrollPort.x -</span>
<span class="lineNum">    4415 </span><span class="lineNoCov">          0 :           (mScrollPort.XMost() - scrollToPos.x - mScrolledFrame-&gt;GetRect().width);</span>
<span class="lineNum">    4416 </span>            :       }
<span class="lineNum">    4417 </span><span class="lineNoCov">          0 :       AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    4418 </span>            :       // It's very important to pass nsGkAtoms::restore here, so
<span class="lineNum">    4419 </span>            :       // ScrollToWithOrigin won't clear out mRestorePos.
<span class="lineNum">    4420 </span><span class="lineNoCov">          0 :       ScrollToWithOrigin(scrollToPos, nsIScrollableFrame::INSTANT,</span>
<span class="lineNum">    4421 </span><span class="lineNoCov">          0 :                          nsGkAtoms::restore, nullptr);</span>
<span class="lineNum">    4422 </span><span class="lineNoCov">          0 :       if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    4423 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    4424 </span>            :       }
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :       if (state == LoadingState::Loading || NS_SUBTREE_DIRTY(mOuter)) {</span>
<span class="lineNum">    4426 </span>            :         // If we're trying to do a history scroll restore, then we want to
<span class="lineNum">    4427 </span>            :         // keep trying this until we succeed, because the page can be loading
<span class="lineNum">    4428 </span>            :         // incrementally. So re-get the scroll position for the next iteration,
<span class="lineNum">    4429 </span>            :         // it might not be exactly equal to mRestorePos due to rounding and
<span class="lineNum">    4430 </span>            :         // clamping.
<span class="lineNum">    4431 </span><span class="lineNoCov">          0 :         mLastPos = GetLogicalScrollPosition();</span>
<span class="lineNum">    4432 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    4433 </span>            :       }
<span class="lineNum">    4434 </span>            :     }
<span class="lineNum">    4435 </span>            :     // If we get here, either we reached the desired position (mLastPos ==
<span class="lineNum">    4436 </span>            :     // mRestorePos) or we're not trying to do a history scroll restore, so
<span class="lineNum">    4437 </span>            :     // we can stop after the scroll attempt above.
<span class="lineNum">    4438 </span><span class="lineNoCov">          0 :     mRestorePos.y = -1;</span>
<span class="lineNum">    4439 </span><span class="lineNoCov">          0 :     mLastPos.x = -1;</span>
<span class="lineNum">    4440 </span><span class="lineNoCov">          0 :     mLastPos.y = -1;</span>
<span class="lineNum">    4441 </span>            :   } else {
<span class="lineNum">    4442 </span>            :     // user moved the position, so we won't need to restore
<span class="lineNum">    4443 </span><span class="lineNoCov">          0 :     mLastPos.x = -1;</span>
<span class="lineNum">    4444 </span><span class="lineNoCov">          0 :     mLastPos.y = -1;</span>
<span class="lineNum">    4445 </span>            :   }
<span class="lineNum">    4446 </span>            : }
<span class="lineNum">    4447 </span>            : 
<span class="lineNum">    4448 </span>            : auto
<span class="lineNum">    4449 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetPageLoadingState() -&gt; LoadingState</span>
<span class="lineNum">    4450 </span>            : {
<span class="lineNum">    4451 </span><span class="lineNoCov">          0 :   bool loadCompleted = false, stopped = false;</span>
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :   nsCOMPtr&lt;nsIDocShell&gt; ds = mOuter-&gt;GetContent()-&gt;GetComposedDoc()-&gt;GetDocShell();</span>
<span class="lineNum">    4453 </span><span class="lineNoCov">          0 :   if (ds) {</span>
<span class="lineNum">    4454 </span><span class="lineNoCov">          0 :     nsCOMPtr&lt;nsIContentViewer&gt; cv;</span>
<span class="lineNum">    4455 </span><span class="lineNoCov">          0 :     ds-&gt;GetContentViewer(getter_AddRefs(cv));</span>
<span class="lineNum">    4456 </span><span class="lineNoCov">          0 :     cv-&gt;GetLoadCompleted(&amp;loadCompleted);</span>
<span class="lineNum">    4457 </span><span class="lineNoCov">          0 :     cv-&gt;GetIsStopped(&amp;stopped);</span>
<span class="lineNum">    4458 </span>            :   }
<span class="lineNum">    4459 </span><span class="lineNoCov">          0 :   return loadCompleted ? (stopped ? LoadingState::Stopped : LoadingState::Loaded)</span>
<span class="lineNum">    4460 </span><span class="lineNoCov">          0 :                        : LoadingState::Loading;</span>
<span class="lineNum">    4461 </span>            : }
<span class="lineNum">    4462 </span>            : 
<span class="lineNum">    4463 </span>            : nsresult
<span class="lineNum">    4464 </span><span class="lineCov">          2 : ScrollFrameHelper::FireScrollPortEvent()</span>
<span class="lineNum">    4465 </span>            : {
<span class="lineNum">    4466 </span><span class="lineNoCov">          0 :   mAsyncScrollPortEvent.Forget();</span>
<span class="lineNum">    4467 </span>            : 
<span class="lineNum">    4468 </span>            :   // Keep this in sync with PostOverflowEvent().
<span class="lineNum">    4469 </span><span class="lineNoCov">          0 :   nsSize scrollportSize = mScrollPort.Size();</span>
<span class="lineNum">    4470 </span><span class="lineNoCov">          0 :   nsSize childSize = GetScrolledRect().Size();</span>
<span class="lineNum">    4471 </span>            : 
<span class="lineNum">    4472 </span><span class="lineNoCov">          0 :   bool newVerticalOverflow = childSize.height &gt; scrollportSize.height;</span>
<span class="lineNum">    4473 </span><span class="lineNoCov">          0 :   bool vertChanged = mVerticalOverflow != newVerticalOverflow;</span>
<span class="lineNum">    4474 </span>            : 
<span class="lineNum">    4475 </span><span class="lineNoCov">          0 :   bool newHorizontalOverflow = childSize.width &gt; scrollportSize.width;</span>
<span class="lineNum">    4476 </span><span class="lineCov">          2 :   bool horizChanged = mHorizontalOverflow != newHorizontalOverflow;</span>
<span class="lineNum">    4477 </span>            : 
<span class="lineNum">    4478 </span><span class="lineCov">          2 :   if (!vertChanged &amp;&amp; !horizChanged) {</span>
<span class="lineNum">    4479 </span>            :     return NS_OK;
<span class="lineNum">    4480 </span>            :   }
<span class="lineNum">    4481 </span>            : 
<span class="lineNum">    4482 </span>            :   // If both either overflowed or underflowed then we dispatch only one
<span class="lineNum">    4483 </span>            :   // DOM event.
<span class="lineNum">    4484 </span><span class="lineCov">          2 :   bool both = vertChanged &amp;&amp; horizChanged &amp;&amp;</span>
<span class="lineNum">    4485 </span><span class="lineCov">          2 :                 newVerticalOverflow == newHorizontalOverflow;</span>
<span class="lineNum">    4486 </span>            :   InternalScrollPortEvent::OrientType orient;
<span class="lineNum">    4487 </span><span class="lineNoCov">          0 :   if (both) {</span>
<span class="lineNum">    4488 </span><span class="lineNoCov">          0 :     orient = InternalScrollPortEvent::eBoth;</span>
<span class="lineNum">    4489 </span><span class="lineNoCov">          0 :     mHorizontalOverflow = newHorizontalOverflow;</span>
<span class="lineNum">    4490 </span><span class="lineNoCov">          0 :     mVerticalOverflow = newVerticalOverflow;</span>
<span class="lineNum">    4491 </span><span class="lineNoCov">          0 :   } else if (vertChanged) {</span>
<span class="lineNum">    4492 </span><span class="lineNoCov">          0 :     orient = InternalScrollPortEvent::eVertical;</span>
<span class="lineNum">    4493 </span><span class="lineCov">          1 :     mVerticalOverflow = newVerticalOverflow;</span>
<span class="lineNum">    4494 </span><span class="lineCov">          1 :     if (horizChanged) {</span>
<span class="lineNum">    4495 </span>            :       // We need to dispatch a separate horizontal DOM event. Do that the next
<span class="lineNum">    4496 </span>            :       // time around since dispatching the vertical DOM event might destroy
<span class="lineNum">    4497 </span>            :       // the frame.
<span class="lineNum">    4498 </span><span class="lineNoCov">          0 :       PostOverflowEvent();</span>
<span class="lineNum">    4499 </span>            :     }
<span class="lineNum">    4500 </span>            :   } else {
<span class="lineNum">    4501 </span><span class="lineCov">          1 :     orient = InternalScrollPortEvent::eHorizontal;</span>
<span class="lineNum">    4502 </span><span class="lineCov">          1 :     mHorizontalOverflow = newHorizontalOverflow;</span>
<span class="lineNum">    4503 </span>            :   }
<span class="lineNum">    4504 </span>            : 
<span class="lineNum">    4505 </span>            :   InternalScrollPortEvent event(true,
<span class="lineNum">    4506 </span><span class="lineCov">          2 :     (orient == InternalScrollPortEvent::eHorizontal ? mHorizontalOverflow :</span>
<span class="lineNum">    4507 </span>            :                                                       mVerticalOverflow) ?
<span class="lineNum">    4508 </span><span class="lineCov">          4 :     eScrollPortOverflow : eScrollPortUnderflow, nullptr);</span>
<span class="lineNum">    4509 </span><span class="lineNoCov">          0 :   event.mOrient = orient;</span>
<span class="lineNum">    4510 </span><span class="lineNoCov">          0 :   return EventDispatcher::Dispatch(mOuter-&gt;GetContent(),</span>
<span class="lineNum">    4511 </span><span class="lineNoCov">          0 :                                    mOuter-&gt;PresContext(), &amp;event);</span>
<span class="lineNum">    4512 </span>            : }
<span class="lineNum">    4513 </span>            : 
<span class="lineNum">    4514 </span>            : void
<span class="lineNum">    4515 </span><span class="lineNoCov">          0 : ScrollFrameHelper::PostScrollEndEvent()</span>
<span class="lineNum">    4516 </span>            : {
<span class="lineNum">    4517 </span><span class="lineNoCov">          0 :   if (mScrollEndEvent) {</span>
<span class="lineNum">    4518 </span>            :     return;
<span class="lineNum">    4519 </span>            :   }
<span class="lineNum">    4520 </span>            : 
<span class="lineNum">    4521 </span>            :   // The ScrollEndEvent constructor registers itself with the refresh driver.
<span class="lineNum">    4522 </span><span class="lineNoCov">          0 :   mScrollEndEvent = new ScrollEndEvent(this);</span>
<span class="lineNum">    4523 </span>            : }
<span class="lineNum">    4524 </span>            : 
<span class="lineNum">    4525 </span>            : void
<span class="lineNum">    4526 </span><span class="lineNoCov">          0 : ScrollFrameHelper::FireScrollEndEvent()</span>
<span class="lineNum">    4527 </span>            : {
<span class="lineNum">    4528 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mOuter-&gt;GetContent());</span>
<span class="lineNum">    4529 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mScrollEndEvent);</span>
<span class="lineNum">    4530 </span><span class="lineNoCov">          0 :   mScrollEndEvent-&gt;Revoke();</span>
<span class="lineNum">    4531 </span><span class="lineNoCov">          0 :   mScrollEndEvent = nullptr;</span>
<span class="lineNum">    4532 </span>            : 
<span class="lineNum">    4533 </span><span class="lineNoCov">          0 :   nsContentUtils::DispatchEventOnlyToChrome(mOuter-&gt;GetContent()-&gt;OwnerDoc(),</span>
<span class="lineNum">    4534 </span><span class="lineNoCov">          0 :                                             mOuter-&gt;GetContent(),</span>
<span class="lineNum">    4535 </span><span class="lineNoCov">          0 :                                             NS_LITERAL_STRING(&quot;scrollend&quot;),</span>
<span class="lineNum">    4536 </span>            :                                             true /* aCanBubble */,
<span class="lineNum">    4537 </span><span class="lineNoCov">          0 :                                             false /* aCancelable */);</span>
<span class="lineNum">    4538 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4539 </span>            : 
<span class="lineNum">    4540 </span>            : void
<span class="lineNum">    4541 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ReloadChildFrames()</span>
<span class="lineNum">    4542 </span>            : {
<span class="lineNum">    4543 </span><span class="lineNoCov">          0 :   mScrolledFrame = nullptr;</span>
<span class="lineNum">    4544 </span><span class="lineNoCov">          0 :   mHScrollbarBox = nullptr;</span>
<span class="lineNum">    4545 </span><span class="lineNoCov">          0 :   mVScrollbarBox = nullptr;</span>
<span class="lineNum">    4546 </span><span class="lineCov">         60 :   mScrollCornerBox = nullptr;</span>
<span class="lineNum">    4547 </span><span class="lineNoCov">          0 :   mResizerBox = nullptr;</span>
<span class="lineNum">    4548 </span>            : 
<span class="lineNum">    4549 </span><span class="lineCov">        240 :   for (nsIFrame* frame : mOuter-&gt;PrincipalChildList()) {</span>
<span class="lineNum">    4550 </span><span class="lineNoCov">          0 :     nsIContent* content = frame-&gt;GetContent();</span>
<span class="lineNum">    4551 </span><span class="lineNoCov">          0 :     if (content == mOuter-&gt;GetContent()) {</span>
<span class="lineNum">    4552 </span><span class="lineNoCov">          0 :       NS_ASSERTION(!mScrolledFrame, &quot;Already found the scrolled frame&quot;);</span>
<span class="lineNum">    4553 </span><span class="lineNoCov">          0 :       mScrolledFrame = frame;</span>
<span class="lineNum">    4554 </span>            :     } else {
<span class="lineNum">    4555 </span><span class="lineNoCov">          0 :       nsAutoString value;</span>
<span class="lineNum">    4556 </span><span class="lineNoCov">          0 :       if (content-&gt;IsElement()) {</span>
<span class="lineNum">    4557 </span><span class="lineCov">         30 :         content-&gt;AsElement()-&gt;GetAttr(kNameSpaceID_None, nsGkAtoms::orient,</span>
<span class="lineNum">    4558 </span><span class="lineCov">         30 :                                       value);</span>
<span class="lineNum">    4559 </span>            :       }
<span class="lineNum">    4560 </span><span class="lineNoCov">          0 :       if (!value.IsEmpty()) {</span>
<span class="lineNum">    4561 </span>            :         // probably a scrollbar then
<span class="lineNum">    4562 </span><span class="lineCov">         20 :         if (value.LowerCaseEqualsLiteral(&quot;horizontal&quot;)) {</span>
<span class="lineNum">    4563 </span><span class="lineNoCov">          0 :           NS_ASSERTION(!mHScrollbarBox, &quot;Found multiple horizontal scrollbars?&quot;);</span>
<span class="lineNum">    4564 </span><span class="lineCov">         10 :           mHScrollbarBox = frame;</span>
<span class="lineNum">    4565 </span>            :         } else {
<span class="lineNum">    4566 </span><span class="lineNoCov">          0 :           NS_ASSERTION(!mVScrollbarBox, &quot;Found multiple vertical scrollbars?&quot;);</span>
<span class="lineNum">    4567 </span><span class="lineNoCov">          0 :           mVScrollbarBox = frame;</span>
<span class="lineNum">    4568 </span>            :         }
<span class="lineNum">    4569 </span><span class="lineCov">         10 :       } else if (content-&gt;IsXULElement(nsGkAtoms::resizer)) {</span>
<span class="lineNum">    4570 </span><span class="lineNoCov">          0 :         NS_ASSERTION(!mResizerBox, &quot;Found multiple resizers&quot;);</span>
<span class="lineNum">    4571 </span><span class="lineNoCov">          0 :         mResizerBox = frame;</span>
<span class="lineNum">    4572 </span><span class="lineCov">         10 :       } else if (content-&gt;IsXULElement(nsGkAtoms::scrollcorner)) {</span>
<span class="lineNum">    4573 </span>            :         // probably a scrollcorner
<span class="lineNum">    4574 </span><span class="lineNoCov">          0 :         NS_ASSERTION(!mScrollCornerBox, &quot;Found multiple scrollcorners&quot;);</span>
<span class="lineNum">    4575 </span><span class="lineNoCov">          0 :         mScrollCornerBox = frame;</span>
<span class="lineNum">    4576 </span>            :       }
<span class="lineNum">    4577 </span>            :     }
<span class="lineNum">    4578 </span>            :   }
<span class="lineNum">    4579 </span><span class="lineCov">         60 : }</span>
<span class="lineNum">    4580 </span>            : 
<span class="lineNum">    4581 </span>            : nsresult
<span class="lineNum">    4582 </span><span class="lineCov">         30 : ScrollFrameHelper::CreateAnonymousContent(</span>
<span class="lineNum">    4583 </span>            :   nsTArray&lt;nsIAnonymousContentCreator::ContentInfo&gt;&amp; aElements)
<span class="lineNum">    4584 </span>            : {
<span class="lineNum">    4585 </span><span class="lineCov">         60 :   nsPresContext* presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    4586 </span><span class="lineCov">         30 :   nsIFrame* parent = mOuter-&gt;GetParent();</span>
<span class="lineNum">    4587 </span>            : 
<span class="lineNum">    4588 </span>            :   // Don't create scrollbars if we're an SVG document being used as an image,
<span class="lineNum">    4589 </span>            :   // or if we're printing/print previewing.
<span class="lineNum">    4590 </span>            :   // (In the printing case, we allow scrollbars if this is the child of the
<span class="lineNum">    4591 </span>            :   // viewport &amp; paginated scrolling is enabled, because then we must be the
<span class="lineNum">    4592 </span>            :   // scroll frame for the print preview window, &amp; that does need scrollbars.)
<span class="lineNum">    4593 </span><span class="lineCov">        107 :   if (presContext-&gt;Document()-&gt;IsBeingUsedAsImage() ||</span>
<span class="lineNum">    4594 </span><span class="lineNoCov">          0 :       (!presContext-&gt;IsDynamic() &amp;&amp;</span>
<span class="lineNum">    4595 </span><span class="lineNoCov">          0 :        !(mIsRoot &amp;&amp; presContext-&gt;HasPaginatedScrolling()))) {</span>
<span class="lineNum">    4596 </span><span class="lineCov">         13 :     mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = true;</span>
<span class="lineNum">    4597 </span><span class="lineCov">         13 :     return NS_OK;</span>
<span class="lineNum">    4598 </span>            :   }
<span class="lineNum">    4599 </span>            : 
<span class="lineNum">    4600 </span>            :   // Check if the frame is resizable. Note:
<span class="lineNum">    4601 </span>            :   // &quot;The effect of the resize property on generated content is undefined.
<span class="lineNum">    4602 </span>            :   //  Implementations should not apply the resize property to generated
<span class="lineNum">    4603 </span>            :   //  content.&quot; [1]
<span class="lineNum">    4604 </span>            :   // For info on what is generated content, see [2].
<span class="lineNum">    4605 </span>            :   // [1]: https://drafts.csswg.org/css-ui/#resize
<span class="lineNum">    4606 </span>            :   // [2]: https://www.w3.org/TR/CSS2/generate.html#content
<span class="lineNum">    4607 </span><span class="lineNoCov">          0 :   int8_t resizeStyle = mOuter-&gt;StyleDisplay()-&gt;mResize;</span>
<span class="lineNum">    4608 </span><span class="lineCov">         17 :   bool isResizable = resizeStyle != NS_STYLE_RESIZE_NONE &amp;&amp;</span>
<span class="lineNum">    4609 </span><span class="lineCov">         17 :                      !mOuter-&gt;HasAnyStateBits(NS_FRAME_GENERATED_CONTENT);</span>
<span class="lineNum">    4610 </span>            : 
<span class="lineNum">    4611 </span><span class="lineCov">         34 :   nsIScrollableFrame *scrollable = do_QueryFrame(mOuter);</span>
<span class="lineNum">    4612 </span>            : 
<span class="lineNum">    4613 </span>            :   // If we're the scrollframe for the root, then we want to construct
<span class="lineNum">    4614 </span>            :   // our scrollbar frames no matter what.  That way later dynamic
<span class="lineNum">    4615 </span>            :   // changes to propagated overflow styles will show or hide
<span class="lineNum">    4616 </span>            :   // scrollbars on the viewport without requiring frame reconstruction
<span class="lineNum">    4617 </span>            :   // of the viewport (good!).
<span class="lineNum">    4618 </span>            :   bool canHaveHorizontal;
<span class="lineNum">    4619 </span>            :   bool canHaveVertical;
<span class="lineNum">    4620 </span><span class="lineNoCov">          0 :   if (!mIsRoot) {</span>
<span class="lineNum">    4621 </span><span class="lineNoCov">          0 :     ScrollbarStyles styles = scrollable-&gt;GetScrollbarStyles();</span>
<span class="lineNum">    4622 </span><span class="lineNoCov">          0 :     canHaveHorizontal = styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN;</span>
<span class="lineNum">    4623 </span><span class="lineCov">         12 :     canHaveVertical = styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN;</span>
<span class="lineNum">    4624 </span><span class="lineCov">         12 :     if (!canHaveHorizontal &amp;&amp; !canHaveVertical &amp;&amp; !isResizable) {</span>
<span class="lineNum">    4625 </span>            :       // Nothing to do.
<span class="lineNum">    4626 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">    4627 </span>            :     }
<span class="lineNum">    4628 </span>            :   } else {
<span class="lineNum">    4629 </span>            :     canHaveHorizontal = true;
<span class="lineNum">    4630 </span>            :     canHaveVertical = true;
<span class="lineNum">    4631 </span>            :   }
<span class="lineNum">    4632 </span>            : 
<span class="lineNum">    4633 </span>            :   // The anonymous &lt;div&gt; used by &lt;inputs&gt; never gets scrollbars.
<span class="lineNum">    4634 </span><span class="lineNoCov">          0 :   nsITextControlFrame* textFrame = do_QueryFrame(parent);</span>
<span class="lineNum">    4635 </span><span class="lineNoCov">          0 :   if (textFrame) {</span>
<span class="lineNum">    4636 </span>            :     // Make sure we are not a text area.
<span class="lineNum">    4637 </span>            :     HTMLTextAreaElement* textAreaElement =
<span class="lineNum">    4638 </span><span class="lineCov">          2 :       HTMLTextAreaElement::FromNode(parent-&gt;GetContent());</span>
<span class="lineNum">    4639 </span><span class="lineCov">          1 :     if (!textAreaElement) {</span>
<span class="lineNum">    4640 </span><span class="lineNoCov">          0 :       mNeverHasVerticalScrollbar = mNeverHasHorizontalScrollbar = true;</span>
<span class="lineNum">    4641 </span><span class="lineNoCov">          0 :       return NS_OK;</span>
<span class="lineNum">    4642 </span>            :     }
<span class="lineNum">    4643 </span>            :   }
<span class="lineNum">    4644 </span>            : 
<span class="lineNum">    4645 </span><span class="lineNoCov">          0 :   nsNodeInfoManager* nodeInfoManager = presContext-&gt;Document()-&gt;NodeInfoManager();</span>
<span class="lineNum">    4646 </span>            :   RefPtr&lt;NodeInfo&gt; nodeInfo =
<span class="lineNum">    4647 </span><span class="lineNoCov">          0 :     nodeInfoManager-&gt;GetNodeInfo(nsGkAtoms::scrollbar, nullptr,</span>
<span class="lineNum">    4648 </span>            :                                  kNameSpaceID_XUL,
<span class="lineNum">    4649 </span><span class="lineNoCov">          0 :                                  nsINode::ELEMENT_NODE);</span>
<span class="lineNum">    4650 </span><span class="lineNoCov">          0 :   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">    4651 </span>            : 
<span class="lineNum">    4652 </span><span class="lineNoCov">          0 :   if (canHaveHorizontal) {</span>
<span class="lineNum">    4653 </span><span class="lineNoCov">          0 :     RefPtr&lt;NodeInfo&gt; ni = nodeInfo;</span>
<span class="lineNum">    4654 </span><span class="lineCov">         10 :     NS_TrustedNewXULElement(getter_AddRefs(mHScrollbarContent), ni.forget());</span>
<span class="lineNum">    4655 </span>            : #ifdef DEBUG
<span class="lineNum">    4656 </span>            :     // Scrollbars can get restyled by theme changes.  Whether such a restyle
<span class="lineNum">    4657 </span>            :     // will actually reconstruct them correctly if it involves a frame
<span class="lineNum">    4658 </span>            :     // reconstruct... I don't know.  :(
<span class="lineNum">    4659 </span><span class="lineNoCov">          0 :     mHScrollbarContent-&gt;SetProperty(nsGkAtoms::restylableAnonymousNode,</span>
<span class="lineNum">    4660 </span><span class="lineNoCov">          0 :                                     reinterpret_cast&lt;void*&gt;(true));</span>
<span class="lineNum">    4661 </span>            : #endif // DEBUG
<span class="lineNum">    4662 </span>            : 
<span class="lineNum">    4663 </span><span class="lineCov">          5 :     mHScrollbarContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::orient,</span>
<span class="lineNum">    4664 </span><span class="lineCov">         15 :                                 NS_LITERAL_STRING(&quot;horizontal&quot;), false);</span>
<span class="lineNum">    4665 </span><span class="lineCov">          5 :     mHScrollbarContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::clickthrough,</span>
<span class="lineNum">    4666 </span><span class="lineNoCov">          0 :                                 NS_LITERAL_STRING(&quot;always&quot;), false);</span>
<span class="lineNum">    4667 </span><span class="lineNoCov">          0 :     if (mIsRoot) {</span>
<span class="lineNum">    4668 </span><span class="lineCov">          5 :       mHScrollbarContent-&gt;SetProperty(nsGkAtoms::docLevelNativeAnonymousContent,</span>
<span class="lineNum">    4669 </span><span class="lineCov">          5 :                                       reinterpret_cast&lt;void*&gt;(true));</span>
<span class="lineNum">    4670 </span>            : 
<span class="lineNum">    4671 </span><span class="lineNoCov">          0 :       mHScrollbarContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::root_,</span>
<span class="lineNum">    4672 </span><span class="lineNoCov">          0 :                                   NS_LITERAL_STRING(&quot;true&quot;), false);</span>
<span class="lineNum">    4673 </span>            :     }
<span class="lineNum">    4674 </span><span class="lineNoCov">          0 :     if (!aElements.AppendElement(mHScrollbarContent))</span>
<span class="lineNum">    4675 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">    4676 </span>            :   }
<span class="lineNum">    4677 </span>            : 
<span class="lineNum">    4678 </span><span class="lineNoCov">          0 :   if (canHaveVertical) {</span>
<span class="lineNum">    4679 </span><span class="lineCov">         10 :     RefPtr&lt;NodeInfo&gt; ni = nodeInfo;</span>
<span class="lineNum">    4680 </span><span class="lineNoCov">          0 :     NS_TrustedNewXULElement(getter_AddRefs(mVScrollbarContent), ni.forget());</span>
<span class="lineNum">    4681 </span>            : #ifdef DEBUG
<span class="lineNum">    4682 </span>            :     // Scrollbars can get restyled by theme changes.  Whether such a restyle
<span class="lineNum">    4683 </span>            :     // will actually reconstruct them correctly if it involves a frame
<span class="lineNum">    4684 </span>            :     // reconstruct... I don't know.  :(
<span class="lineNum">    4685 </span><span class="lineNoCov">          0 :     mVScrollbarContent-&gt;SetProperty(nsGkAtoms::restylableAnonymousNode,</span>
<span class="lineNum">    4686 </span><span class="lineNoCov">          0 :                                     reinterpret_cast&lt;void*&gt;(true));</span>
<span class="lineNum">    4687 </span>            : #endif // DEBUG
<span class="lineNum">    4688 </span>            : 
<span class="lineNum">    4689 </span><span class="lineNoCov">          0 :     mVScrollbarContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::orient,</span>
<span class="lineNum">    4690 </span><span class="lineCov">         15 :                                 NS_LITERAL_STRING(&quot;vertical&quot;), false);</span>
<span class="lineNum">    4691 </span><span class="lineNoCov">          0 :     mVScrollbarContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::clickthrough,</span>
<span class="lineNum">    4692 </span><span class="lineCov">         15 :                                 NS_LITERAL_STRING(&quot;always&quot;), false);</span>
<span class="lineNum">    4693 </span><span class="lineNoCov">          0 :     if (mIsRoot) {</span>
<span class="lineNum">    4694 </span><span class="lineNoCov">          0 :       mVScrollbarContent-&gt;SetProperty(nsGkAtoms::docLevelNativeAnonymousContent,</span>
<span class="lineNum">    4695 </span><span class="lineCov">          5 :                                       reinterpret_cast&lt;void*&gt;(true));</span>
<span class="lineNum">    4696 </span><span class="lineNoCov">          0 :       mVScrollbarContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::root_,</span>
<span class="lineNum">    4697 </span><span class="lineNoCov">          0 :                                   NS_LITERAL_STRING(&quot;true&quot;), false);</span>
<span class="lineNum">    4698 </span>            :     }
<span class="lineNum">    4699 </span><span class="lineCov">          5 :     if (!aElements.AppendElement(mVScrollbarContent))</span>
<span class="lineNum">    4700 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">    4701 </span>            :   }
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span><span class="lineCov">          5 :   if (isResizable) {</span>
<span class="lineNum">    4704 </span><span class="lineNoCov">          0 :     RefPtr&lt;NodeInfo&gt; nodeInfo;</span>
<span class="lineNum">    4705 </span><span class="lineNoCov">          0 :     nodeInfo = nodeInfoManager-&gt;GetNodeInfo(nsGkAtoms::resizer, nullptr,</span>
<span class="lineNum">    4706 </span>            :                                             kNameSpaceID_XUL,
<span class="lineNum">    4707 </span><span class="lineNoCov">          0 :                                             nsINode::ELEMENT_NODE);</span>
<span class="lineNum">    4708 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">    4709 </span>            : 
<span class="lineNum">    4710 </span><span class="lineNoCov">          0 :     NS_TrustedNewXULElement(getter_AddRefs(mResizerContent), nodeInfo.forget());</span>
<span class="lineNum">    4711 </span>            : 
<span class="lineNum">    4712 </span><span class="lineNoCov">          0 :     nsAutoString dir;</span>
<span class="lineNum">    4713 </span><span class="lineNoCov">          0 :     switch (resizeStyle) {</span>
<span class="lineNum">    4714 </span>            :       case NS_STYLE_RESIZE_HORIZONTAL:
<span class="lineNum">    4715 </span><span class="lineNoCov">          0 :         if (IsScrollbarOnRight()) {</span>
<span class="lineNum">    4716 </span><span class="lineNoCov">          0 :           dir.AssignLiteral(&quot;right&quot;);</span>
<span class="lineNum">    4717 </span>            :         }
<span class="lineNum">    4718 </span>            :         else {
<span class="lineNum">    4719 </span><span class="lineNoCov">          0 :           dir.AssignLiteral(&quot;left&quot;);</span>
<span class="lineNum">    4720 </span>            :         }
<span class="lineNum">    4721 </span>            :         break;
<span class="lineNum">    4722 </span>            :       case NS_STYLE_RESIZE_VERTICAL:
<span class="lineNum">    4723 </span><span class="lineNoCov">          0 :         dir.AssignLiteral(&quot;bottom&quot;);</span>
<span class="lineNum">    4724 </span><span class="lineNoCov">          0 :         if (!IsScrollbarOnRight()) {</span>
<span class="lineNum">    4725 </span><span class="lineNoCov">          0 :           mResizerContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::flip, EmptyString(), false);</span>
<span class="lineNum">    4726 </span>            :         }
<span class="lineNum">    4727 </span>            :         break;
<span class="lineNum">    4728 </span>            :       case NS_STYLE_RESIZE_BOTH:
<span class="lineNum">    4729 </span><span class="lineNoCov">          0 :         if (IsScrollbarOnRight()) {</span>
<span class="lineNum">    4730 </span><span class="lineNoCov">          0 :           dir.AssignLiteral(&quot;bottomright&quot;);</span>
<span class="lineNum">    4731 </span>            :         }
<span class="lineNum">    4732 </span>            :         else {
<span class="lineNum">    4733 </span><span class="lineNoCov">          0 :           dir.AssignLiteral(&quot;bottomleft&quot;);</span>
<span class="lineNum">    4734 </span>            :         }
<span class="lineNum">    4735 </span>            :         break;
<span class="lineNum">    4736 </span>            :       default:
<span class="lineNum">    4737 </span><span class="lineNoCov">          0 :         NS_WARNING(&quot;only resizable types should have resizers&quot;);</span>
<span class="lineNum">    4738 </span>            :     }
<span class="lineNum">    4739 </span><span class="lineNoCov">          0 :     mResizerContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::dir, dir, false);</span>
<span class="lineNum">    4740 </span>            : 
<span class="lineNum">    4741 </span><span class="lineNoCov">          0 :     if (mIsRoot) {</span>
<span class="lineNum">    4742 </span><span class="lineNoCov">          0 :       mResizerContent-&gt;SetProperty(nsGkAtoms::docLevelNativeAnonymousContent,</span>
<span class="lineNum">    4743 </span><span class="lineNoCov">          0 :                                    reinterpret_cast&lt;void*&gt;(true));</span>
<span class="lineNum">    4744 </span>            : 
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 :       Element* browserRoot = GetBrowserRoot(mOuter-&gt;GetContent());</span>
<span class="lineNum">    4746 </span><span class="lineNoCov">          0 :       mCollapsedResizer = !(browserRoot &amp;&amp;</span>
<span class="lineNum">    4747 </span><span class="lineNoCov">          0 :                             browserRoot-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::showresizer));</span>
<span class="lineNum">    4748 </span>            :     } else {
<span class="lineNum">    4749 </span><span class="lineNoCov">          0 :       mResizerContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::element,</span>
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 :                                     NS_LITERAL_STRING(&quot;_parent&quot;), false);</span>
<span class="lineNum">    4751 </span>            :     }
<span class="lineNum">    4752 </span>            : 
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :     mResizerContent-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::clickthrough,</span>
<span class="lineNum">    4754 </span><span class="lineNoCov">          0 :                                   NS_LITERAL_STRING(&quot;always&quot;), false);</span>
<span class="lineNum">    4755 </span>            : 
<span class="lineNum">    4756 </span><span class="lineNoCov">          0 :     if (!aElements.AppendElement(mResizerContent))</span>
<span class="lineNum">    4757 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">    4758 </span>            :   }
<span class="lineNum">    4759 </span>            : 
<span class="lineNum">    4760 </span><span class="lineCov">          5 :   if (canHaveHorizontal &amp;&amp; canHaveVertical) {</span>
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :     nodeInfo = nodeInfoManager-&gt;GetNodeInfo(nsGkAtoms::scrollcorner, nullptr,</span>
<span class="lineNum">    4762 </span>            :                                             kNameSpaceID_XUL,
<span class="lineNum">    4763 </span><span class="lineCov">          5 :                                             nsINode::ELEMENT_NODE);</span>
<span class="lineNum">    4764 </span><span class="lineCov">         10 :     NS_TrustedNewXULElement(getter_AddRefs(mScrollCornerContent), nodeInfo.forget());</span>
<span class="lineNum">    4765 </span><span class="lineNoCov">          0 :     if (mIsRoot) {</span>
<span class="lineNum">    4766 </span><span class="lineNoCov">          0 :       mScrollCornerContent-&gt;SetProperty(nsGkAtoms::docLevelNativeAnonymousContent,</span>
<span class="lineNum">    4767 </span><span class="lineCov">          5 :                                         reinterpret_cast&lt;void*&gt;(true));</span>
<span class="lineNum">    4768 </span>            :     }
<span class="lineNum">    4769 </span><span class="lineNoCov">          0 :     if (!aElements.AppendElement(mScrollCornerContent))</span>
<span class="lineNum">    4770 </span>            :       return NS_ERROR_OUT_OF_MEMORY;
<span class="lineNum">    4771 </span>            :   }
<span class="lineNum">    4772 </span>            : 
<span class="lineNum">    4773 </span>            :   return NS_OK;
<span class="lineNum">    4774 </span>            : }
<span class="lineNum">    4775 </span>            : 
<span class="lineNum">    4776 </span>            : void
<span class="lineNum">    4777 </span><span class="lineCov">        361 : ScrollFrameHelper::AppendAnonymousContentTo(nsTArray&lt;nsIContent*&gt;&amp; aElements,</span>
<span class="lineNum">    4778 </span>            :                                                 uint32_t aFilter)
<span class="lineNum">    4779 </span>            : {
<span class="lineNum">    4780 </span><span class="lineCov">        722 :   if (mHScrollbarContent) {</span>
<span class="lineNum">    4781 </span><span class="lineNoCov">          0 :     aElements.AppendElement(mHScrollbarContent);</span>
<span class="lineNum">    4782 </span>            :   }
<span class="lineNum">    4783 </span>            : 
<span class="lineNum">    4784 </span><span class="lineCov">        722 :   if (mVScrollbarContent) {</span>
<span class="lineNum">    4785 </span><span class="lineCov">         66 :     aElements.AppendElement(mVScrollbarContent);</span>
<span class="lineNum">    4786 </span>            :   }
<span class="lineNum">    4787 </span>            : 
<span class="lineNum">    4788 </span><span class="lineNoCov">          0 :   if (mScrollCornerContent) {</span>
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :     aElements.AppendElement(mScrollCornerContent);</span>
<span class="lineNum">    4790 </span>            :   }
<span class="lineNum">    4791 </span>            : 
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 :   if (mResizerContent) {</span>
<span class="lineNum">    4793 </span><span class="lineNoCov">          0 :     aElements.AppendElement(mResizerContent);</span>
<span class="lineNum">    4794 </span>            :   }
<span class="lineNum">    4795 </span><span class="lineCov">        361 : }</span>
<span class="lineNum">    4796 </span>            : 
<span class="lineNum">    4797 </span>            : void
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 : ScrollFrameHelper::Destroy(PostDestroyData&amp; aPostDestroyData)</span>
<span class="lineNum">    4799 </span>            : {
<span class="lineNum">    4800 </span><span class="lineCov">          4 :   if (mScrollbarActivity) {</span>
<span class="lineNum">    4801 </span><span class="lineNoCov">          0 :     mScrollbarActivity-&gt;Destroy();</span>
<span class="lineNum">    4802 </span><span class="lineNoCov">          0 :     mScrollbarActivity = nullptr;</span>
<span class="lineNum">    4803 </span>            :   }
<span class="lineNum">    4804 </span>            : 
<span class="lineNum">    4805 </span>            :   // Unbind the content created in CreateAnonymousContent later...
<span class="lineNum">    4806 </span><span class="lineNoCov">          0 :   aPostDestroyData.AddAnonymousContent(mHScrollbarContent.forget());</span>
<span class="lineNum">    4807 </span><span class="lineNoCov">          0 :   aPostDestroyData.AddAnonymousContent(mVScrollbarContent.forget());</span>
<span class="lineNum">    4808 </span><span class="lineCov">          6 :   aPostDestroyData.AddAnonymousContent(mScrollCornerContent.forget());</span>
<span class="lineNum">    4809 </span><span class="lineCov">          6 :   aPostDestroyData.AddAnonymousContent(mResizerContent.forget());</span>
<span class="lineNum">    4810 </span>            : 
<span class="lineNum">    4811 </span><span class="lineNoCov">          0 :   if (mPostedReflowCallback) {</span>
<span class="lineNum">    4812 </span><span class="lineNoCov">          0 :     mOuter-&gt;PresShell()-&gt;CancelReflowCallback(this);</span>
<span class="lineNum">    4813 </span><span class="lineNoCov">          0 :     mPostedReflowCallback = false;</span>
<span class="lineNum">    4814 </span>            :   }
<span class="lineNum">    4815 </span>            : 
<span class="lineNum">    4816 </span><span class="lineCov">          4 :   if (mDisplayPortExpiryTimer) {</span>
<span class="lineNum">    4817 </span><span class="lineNoCov">          0 :     mDisplayPortExpiryTimer-&gt;Cancel();</span>
<span class="lineNum">    4818 </span><span class="lineNoCov">          0 :     mDisplayPortExpiryTimer = nullptr;</span>
<span class="lineNum">    4819 </span>            :   }
<span class="lineNum">    4820 </span><span class="lineCov">          4 :   if (mActivityExpirationState.IsTracked()) {</span>
<span class="lineNum">    4821 </span><span class="lineNoCov">          0 :     gScrollFrameActivityTracker-&gt;RemoveObject(this);</span>
<span class="lineNum">    4822 </span>            :   }
<span class="lineNum">    4823 </span><span class="lineNoCov">          0 :   if (gScrollFrameActivityTracker &amp;&amp;</span>
<span class="lineNum">    4824 </span><span class="lineCov">          2 :       gScrollFrameActivityTracker-&gt;IsEmpty()) {</span>
<span class="lineNum">    4825 </span><span class="lineNoCov">          0 :     delete gScrollFrameActivityTracker;</span>
<span class="lineNum">    4826 </span><span class="lineNoCov">          0 :     gScrollFrameActivityTracker = nullptr;</span>
<span class="lineNum">    4827 </span>            :   }
<span class="lineNum">    4828 </span>            : 
<span class="lineNum">    4829 </span><span class="lineNoCov">          0 :   if (mScrollActivityTimer) {</span>
<span class="lineNum">    4830 </span><span class="lineNoCov">          0 :     mScrollActivityTimer-&gt;Cancel();</span>
<span class="lineNum">    4831 </span><span class="lineNoCov">          0 :     mScrollActivityTimer = nullptr;</span>
<span class="lineNum">    4832 </span>            :   }
<span class="lineNum">    4833 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    4834 </span>            : 
<span class="lineNum">    4835 </span>            : /**
<span class="lineNum">    4836 </span>            :  * Called when we want to update the scrollbar position, either because scrolling happened
<span class="lineNum">    4837 </span>            :  * or the user moved the scrollbar position and we need to undo that (e.g., when the user
<span class="lineNum">    4838 </span>            :  * clicks to scroll and we're using smooth scrolling, so we need to put the thumb back
<span class="lineNum">    4839 </span>            :  * to its initial position for the start of the smooth sequence).
<span class="lineNum">    4840 </span>            :  */
<span class="lineNum">    4841 </span>            : void
<span class="lineNum">    4842 </span><span class="lineNoCov">          0 : ScrollFrameHelper::UpdateScrollbarPosition()</span>
<span class="lineNum">    4843 </span>            : {
<span class="lineNum">    4844 </span><span class="lineNoCov">          0 :   AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    4845 </span><span class="lineNoCov">          0 :   mFrameIsUpdatingScrollbar = true;</span>
<span class="lineNum">    4846 </span>            : 
<span class="lineNum">    4847 </span><span class="lineNoCov">          0 :   nsPoint pt = GetScrollPosition();</span>
<span class="lineNum">    4848 </span><span class="lineNoCov">          0 :   if (mVScrollbarBox) {</span>
<span class="lineNum">    4849 </span><span class="lineNoCov">          0 :     SetCoordAttribute(mVScrollbarBox-&gt;GetContent()-&gt;AsElement(),</span>
<span class="lineNum">    4850 </span><span class="lineNoCov">          0 :                       nsGkAtoms::curpos, pt.y - GetScrolledRect().y);</span>
<span class="lineNum">    4851 </span><span class="lineNoCov">          0 :     if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    4852 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4853 </span>            :     }
<span class="lineNum">    4854 </span>            :   }
<span class="lineNum">    4855 </span><span class="lineNoCov">          0 :   if (mHScrollbarBox) {</span>
<span class="lineNum">    4856 </span><span class="lineNoCov">          0 :     SetCoordAttribute(mHScrollbarBox-&gt;GetContent()-&gt;AsElement(), nsGkAtoms::curpos,</span>
<span class="lineNum">    4857 </span><span class="lineNoCov">          0 :                       pt.x - GetScrolledRect().x);</span>
<span class="lineNum">    4858 </span><span class="lineNoCov">          0 :     if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    4859 </span>            :       return;
<span class="lineNum">    4860 </span>            :     }
<span class="lineNum">    4861 </span>            :   }
<span class="lineNum">    4862 </span>            : 
<span class="lineNum">    4863 </span><span class="lineNoCov">          0 :   mFrameIsUpdatingScrollbar = false;</span>
<span class="lineNum">    4864 </span>            : }
<span class="lineNum">    4865 </span>            : 
<span class="lineNum">    4866 </span><span class="lineNoCov">          0 : void ScrollFrameHelper::CurPosAttributeChanged(nsIContent* aContent,</span>
<span class="lineNum">    4867 </span>            :                                                bool aDoScroll)
<span class="lineNum">    4868 </span>            : {
<span class="lineNum">    4869 </span><span class="lineCov">         15 :   NS_ASSERTION(aContent, &quot;aContent must not be null&quot;);</span>
<span class="lineNum">    4870 </span><span class="lineNoCov">          0 :   NS_ASSERTION((mHScrollbarBox &amp;&amp; mHScrollbarBox-&gt;GetContent() == aContent) ||</span>
<span class="lineNum">    4871 </span>            :                (mVScrollbarBox &amp;&amp; mVScrollbarBox-&gt;GetContent() == aContent),
<span class="lineNum">    4872 </span>            :                &quot;unexpected child&quot;);
<span class="lineNum">    4873 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(aContent-&gt;IsElement());</span>
<span class="lineNum">    4874 </span>            : 
<span class="lineNum">    4875 </span>            :   // Attribute changes on the scrollbars happen in one of three ways:
<span class="lineNum">    4876 </span>            :   // 1) The scrollbar changed the attribute in response to some user event
<span class="lineNum">    4877 </span>            :   // 2) We changed the attribute in response to a ScrollPositionDidChange
<span class="lineNum">    4878 </span>            :   // callback from the scrolling view
<span class="lineNum">    4879 </span>            :   // 3) We changed the attribute to adjust the scrollbars for the start
<span class="lineNum">    4880 </span>            :   // of a smooth scroll operation
<span class="lineNum">    4881 </span>            :   //
<span class="lineNum">    4882 </span>            :   // In cases 2 and 3 we do not need to scroll because we're just
<span class="lineNum">    4883 </span>            :   // updating our scrollbar.
<span class="lineNum">    4884 </span><span class="lineNoCov">          0 :   if (mFrameIsUpdatingScrollbar)</span>
<span class="lineNum">    4885 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    4886 </span>            : 
<span class="lineNum">    4887 </span><span class="lineCov">          5 :   nsRect scrolledRect = GetScrolledRect();</span>
<span class="lineNum">    4888 </span>            : 
<span class="lineNum">    4889 </span><span class="lineCov">          1 :   nsPoint current = GetScrollPosition() - scrolledRect.TopLeft();</span>
<span class="lineNum">    4890 </span><span class="lineCov">          1 :   nsPoint dest;</span>
<span class="lineNum">    4891 </span><span class="lineCov">          5 :   nsRect allowedRange;</span>
<span class="lineNum">    4892 </span><span class="lineCov">          5 :   dest.x = GetCoordAttribute(mHScrollbarBox, nsGkAtoms::curpos, current.x,</span>
<span class="lineNum">    4893 </span>            :                              &amp;allowedRange.x, &amp;allowedRange.width);
<span class="lineNum">    4894 </span><span class="lineNoCov">          0 :   dest.y = GetCoordAttribute(mVScrollbarBox, nsGkAtoms::curpos, current.y,</span>
<span class="lineNum">    4895 </span>            :                              &amp;allowedRange.y, &amp;allowedRange.height);
<span class="lineNum">    4896 </span><span class="lineCov">         10 :   current += scrolledRect.TopLeft();</span>
<span class="lineNum">    4897 </span><span class="lineCov">         10 :   dest += scrolledRect.TopLeft();</span>
<span class="lineNum">    4898 </span><span class="lineCov">         15 :   allowedRange += scrolledRect.TopLeft();</span>
<span class="lineNum">    4899 </span>            : 
<span class="lineNum">    4900 </span>            :   // Don't try to scroll if we're already at an acceptable place.
<span class="lineNum">    4901 </span>            :   // Don't call Contains here since Contains returns false when the point is
<span class="lineNum">    4902 </span>            :   // on the bottom or right edge of the rectangle.
<span class="lineNum">    4903 </span><span class="lineCov">          1 :   if (allowedRange.ClampPoint(current) == current) {</span>
<span class="lineNum">    4904 </span><span class="lineCov">          5 :     return;</span>
<span class="lineNum">    4905 </span>            :   }
<span class="lineNum">    4906 </span>            : 
<span class="lineNum">    4907 </span><span class="lineNoCov">          0 :   if (mScrollbarActivity) {</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :     RefPtr&lt;ScrollbarActivity&gt; scrollbarActivity(mScrollbarActivity);</span>
<span class="lineNum">    4909 </span><span class="lineNoCov">          0 :     scrollbarActivity-&gt;ActivityOccurred();</span>
<span class="lineNum">    4910 </span>            :   }
<span class="lineNum">    4911 </span>            : 
<span class="lineNum">    4912 </span>            :   const bool isSmooth =
<span class="lineNum">    4913 </span><span class="lineNoCov">          0 :     aContent-&gt;AsElement()-&gt;HasAttr(kNameSpaceID_None, nsGkAtoms::smooth);</span>
<span class="lineNum">    4914 </span><span class="lineNoCov">          0 :   if (isSmooth) {</span>
<span class="lineNum">    4915 </span>            :     // Make sure an attribute-setting callback occurs even if the view
<span class="lineNum">    4916 </span>            :     // didn't actually move yet.  We need to make sure other listeners
<span class="lineNum">    4917 </span>            :     // see that the scroll position is not (yet) what they thought it
<span class="lineNum">    4918 </span>            :     // was.
<span class="lineNum">    4919 </span><span class="lineNoCov">          0 :     AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    4920 </span><span class="lineNoCov">          0 :     UpdateScrollbarPosition();</span>
<span class="lineNum">    4921 </span><span class="lineNoCov">          0 :     if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    4922 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    4923 </span>            :     }
<span class="lineNum">    4924 </span>            :   }
<span class="lineNum">    4925 </span>            : 
<span class="lineNum">    4926 </span><span class="lineNoCov">          0 :   if (aDoScroll) {</span>
<span class="lineNum">    4927 </span><span class="lineNoCov">          0 :     ScrollToWithOrigin(dest,</span>
<span class="lineNum">    4928 </span>            :                        isSmooth ? nsIScrollableFrame::SMOOTH : nsIScrollableFrame::INSTANT,
<span class="lineNum">    4929 </span><span class="lineNoCov">          0 :                        nsGkAtoms::scrollbars, &amp;allowedRange);</span>
<span class="lineNum">    4930 </span>            :   }
<span class="lineNum">    4931 </span>            :   // 'this' might be destroyed here
<span class="lineNum">    4932 </span>            : }
<span class="lineNum">    4933 </span>            : 
<span class="lineNum">    4934 </span>            : /* ============= Scroll events ========== */
<span class="lineNum">    4935 </span>            : 
<span class="lineNum">    4936 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollEvent::ScrollEvent(ScrollFrameHelper* aHelper)</span>
<span class="lineNum">    4937 </span>            :   : Runnable(&quot;ScrollFrameHelper::ScrollEvent&quot;)
<span class="lineNum">    4938 </span><span class="lineNoCov">          0 :   , mHelper(aHelper)</span>
<span class="lineNum">    4939 </span>            : {
<span class="lineNum">    4940 </span><span class="lineNoCov">          0 :   mHelper-&gt;mOuter-&gt;PresContext()-&gt;RefreshDriver()-&gt;PostScrollEvent(this);</span>
<span class="lineNum">    4941 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4942 </span>            : 
<span class="lineNum">    4943 </span>            : NS_IMETHODIMP
<span class="lineNum">    4944 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollEvent::Run()</span>
<span class="lineNum">    4945 </span>            : {
<span class="lineNum">    4946 </span><span class="lineNoCov">          0 :   if (mHelper) {</span>
<span class="lineNum">    4947 </span><span class="lineNoCov">          0 :     mHelper-&gt;FireScrollEvent();</span>
<span class="lineNum">    4948 </span>            :   }
<span class="lineNum">    4949 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4950 </span>            : }
<span class="lineNum">    4951 </span>            : 
<span class="lineNum">    4952 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollEndEvent::ScrollEndEvent(ScrollFrameHelper* aHelper)</span>
<span class="lineNum">    4953 </span>            :   : Runnable(&quot;ScrollFrameHelper::ScrollEndEvent&quot;)
<span class="lineNum">    4954 </span><span class="lineNoCov">          0 :   , mHelper(aHelper)</span>
<span class="lineNum">    4955 </span>            : {
<span class="lineNum">    4956 </span><span class="lineNoCov">          0 :   mHelper-&gt;mOuter-&gt;PresContext()-&gt;RefreshDriver()-&gt;PostScrollEvent(this);</span>
<span class="lineNum">    4957 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4958 </span>            : 
<span class="lineNum">    4959 </span>            : NS_IMETHODIMP
<span class="lineNum">    4960 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrollEndEvent::Run()</span>
<span class="lineNum">    4961 </span>            : {
<span class="lineNum">    4962 </span><span class="lineNoCov">          0 :   if (mHelper) {</span>
<span class="lineNum">    4963 </span><span class="lineNoCov">          0 :     mHelper-&gt;FireScrollEndEvent();</span>
<span class="lineNum">    4964 </span>            :   }
<span class="lineNum">    4965 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    4966 </span>            : }
<span class="lineNum">    4967 </span>            : 
<span class="lineNum">    4968 </span>            : void
<span class="lineNum">    4969 </span><span class="lineNoCov">          0 : ScrollFrameHelper::FireScrollEvent()</span>
<span class="lineNum">    4970 </span>            : {
<span class="lineNum">    4971 </span><span class="lineNoCov">          0 :   AUTO_PROFILER_TRACING(&quot;Paint&quot;, &quot;FireScrollEvent&quot;);</span>
<span class="lineNum">    4972 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mScrollEvent);</span>
<span class="lineNum">    4973 </span><span class="lineNoCov">          0 :   mScrollEvent-&gt;Revoke();</span>
<span class="lineNum">    4974 </span><span class="lineNoCov">          0 :   mScrollEvent = nullptr;</span>
<span class="lineNum">    4975 </span>            : 
<span class="lineNum">    4976 </span><span class="lineNoCov">          0 :   ActiveLayerTracker::SetCurrentScrollHandlerFrame(mOuter);</span>
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :   WidgetGUIEvent event(true, eScroll, nullptr);</span>
<span class="lineNum">    4978 </span><span class="lineNoCov">          0 :   nsEventStatus status = nsEventStatus_eIgnore;</span>
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :   nsIContent* content = mOuter-&gt;GetContent();</span>
<span class="lineNum">    4980 </span><span class="lineNoCov">          0 :   nsPresContext* prescontext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    4981 </span>            :   // Fire viewport scroll events at the document (where they
<span class="lineNum">    4982 </span>            :   // will bubble to the window)
<span class="lineNum">    4983 </span><span class="lineNoCov">          0 :   mozilla::layers::ScrollLinkedEffectDetector detector(content-&gt;GetComposedDoc());</span>
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 :   if (mIsRoot) {</span>
<span class="lineNum">    4985 </span><span class="lineNoCov">          0 :     nsIDocument* doc = content-&gt;GetUncomposedDoc();</span>
<span class="lineNum">    4986 </span><span class="lineNoCov">          0 :     if (doc) {</span>
<span class="lineNum">    4987 </span><span class="lineNoCov">          0 :       prescontext-&gt;SetTelemetryScrollY(GetScrollPosition().y);</span>
<span class="lineNum">    4988 </span><span class="lineNoCov">          0 :       EventDispatcher::Dispatch(doc, prescontext, &amp;event, nullptr,  &amp;status);</span>
<span class="lineNum">    4989 </span>            :     }
<span class="lineNum">    4990 </span>            :   } else {
<span class="lineNum">    4991 </span>            :     // scroll events fired at elements don't bubble (although scroll events
<span class="lineNum">    4992 </span>            :     // fired at documents do, to the window)
<span class="lineNum">    4993 </span><span class="lineNoCov">          0 :     event.mFlags.mBubbles = false;</span>
<span class="lineNum">    4994 </span><span class="lineNoCov">          0 :     EventDispatcher::Dispatch(content, prescontext, &amp;event, nullptr, &amp;status);</span>
<span class="lineNum">    4995 </span>            :   }
<span class="lineNum">    4996 </span><span class="lineNoCov">          0 :   ActiveLayerTracker::SetCurrentScrollHandlerFrame(nullptr);</span>
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4998 </span>            : 
<span class="lineNum">    4999 </span>            : void
<span class="lineNum">    5000 </span><span class="lineNoCov">          0 : ScrollFrameHelper::PostScrollEvent()</span>
<span class="lineNum">    5001 </span>            : {
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :   if (mScrollEvent) {</span>
<span class="lineNum">    5003 </span>            :     return;
<span class="lineNum">    5004 </span>            :   }
<span class="lineNum">    5005 </span>            : 
<span class="lineNum">    5006 </span>            :   // The ScrollEvent constructor registers itself with the refresh driver.
<span class="lineNum">    5007 </span><span class="lineNoCov">          0 :   mScrollEvent = new ScrollEvent(this);</span>
<span class="lineNum">    5008 </span>            : }
<span class="lineNum">    5009 </span>            : 
<span class="lineNum">    5010 </span>            : NS_IMETHODIMP
<span class="lineNum">    5011 </span><span class="lineCov">          2 : ScrollFrameHelper::AsyncScrollPortEvent::Run()</span>
<span class="lineNum">    5012 </span>            : {
<span class="lineNum">    5013 </span><span class="lineCov">          2 :   if (mHelper) {</span>
<span class="lineNum">    5014 </span><span class="lineNoCov">          0 :     mHelper-&gt;mOuter-&gt;PresContext()-&gt;Document()-&gt;</span>
<span class="lineNum">    5015 </span><span class="lineCov">          4 :       FlushPendingNotifications(FlushType::InterruptibleLayout);</span>
<span class="lineNum">    5016 </span>            :   }
<span class="lineNum">    5017 </span><span class="lineCov">          2 :   return mHelper ? mHelper-&gt;FireScrollPortEvent() : NS_OK;</span>
<span class="lineNum">    5018 </span>            : }
<span class="lineNum">    5019 </span>            : 
<span class="lineNum">    5020 </span>            : bool
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 : nsXULScrollFrame::AddHorizontalScrollbar(nsBoxLayoutState&amp; aState, bool aOnBottom)</span>
<span class="lineNum">    5022 </span>            : {
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :   if (!mHelper.mHScrollbarBox) {</span>
<span class="lineNum">    5024 </span>            :     return true;
<span class="lineNum">    5025 </span>            :   }
<span class="lineNum">    5026 </span>            : 
<span class="lineNum">    5027 </span><span class="lineNoCov">          0 :   return AddRemoveScrollbar(aState, aOnBottom, true, true);</span>
<span class="lineNum">    5028 </span>            : }
<span class="lineNum">    5029 </span>            : 
<span class="lineNum">    5030 </span>            : bool
<span class="lineNum">    5031 </span><span class="lineNoCov">          0 : nsXULScrollFrame::AddVerticalScrollbar(nsBoxLayoutState&amp; aState, bool aOnRight)</span>
<span class="lineNum">    5032 </span>            : {
<span class="lineNum">    5033 </span><span class="lineNoCov">          0 :   if (!mHelper.mVScrollbarBox) {</span>
<span class="lineNum">    5034 </span>            :     return true;
<span class="lineNum">    5035 </span>            :   }
<span class="lineNum">    5036 </span>            : 
<span class="lineNum">    5037 </span><span class="lineNoCov">          0 :   return AddRemoveScrollbar(aState, aOnRight, false, true);</span>
<span class="lineNum">    5038 </span>            : }
<span class="lineNum">    5039 </span>            : 
<span class="lineNum">    5040 </span>            : void
<span class="lineNum">    5041 </span><span class="lineNoCov">          0 : nsXULScrollFrame::RemoveHorizontalScrollbar(nsBoxLayoutState&amp; aState, bool aOnBottom)</span>
<span class="lineNum">    5042 </span>            : {
<span class="lineNum">    5043 </span>            :   // removing a scrollbar should always fit
<span class="lineNum">    5044 </span><span class="lineNoCov">          0 :   DebugOnly&lt;bool&gt; result = AddRemoveScrollbar(aState, aOnBottom, true, false);</span>
<span class="lineNum">    5045 </span><span class="lineNoCov">          0 :   NS_ASSERTION(result, &quot;Removing horizontal scrollbar failed to fit??&quot;);</span>
<span class="lineNum">    5046 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5047 </span>            : 
<span class="lineNum">    5048 </span>            : void
<span class="lineNum">    5049 </span><span class="lineNoCov">          0 : nsXULScrollFrame::RemoveVerticalScrollbar(nsBoxLayoutState&amp; aState, bool aOnRight)</span>
<span class="lineNum">    5050 </span>            : {
<span class="lineNum">    5051 </span>            :   // removing a scrollbar should always fit
<span class="lineNum">    5052 </span><span class="lineNoCov">          0 :   DebugOnly&lt;bool&gt; result = AddRemoveScrollbar(aState, aOnRight, false, false);</span>
<span class="lineNum">    5053 </span><span class="lineNoCov">          0 :   NS_ASSERTION(result, &quot;Removing vertical scrollbar failed to fit??&quot;);</span>
<span class="lineNum">    5054 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5055 </span>            : 
<span class="lineNum">    5056 </span>            : bool
<span class="lineNum">    5057 </span><span class="lineNoCov">          0 : nsXULScrollFrame::AddRemoveScrollbar(nsBoxLayoutState&amp; aState,</span>
<span class="lineNum">    5058 </span>            :                                      bool aOnRightOrBottom, bool aHorizontal, bool aAdd)
<span class="lineNum">    5059 </span>            : {
<span class="lineNum">    5060 </span><span class="lineNoCov">          0 :   if (aHorizontal) {</span>
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 :      if (mHelper.mNeverHasHorizontalScrollbar || !mHelper.mHScrollbarBox)</span>
<span class="lineNum">    5062 </span>            :        return false;
<span class="lineNum">    5063 </span>            : 
<span class="lineNum">    5064 </span><span class="lineNoCov">          0 :      nsSize hSize = mHelper.mHScrollbarBox-&gt;GetXULPrefSize(aState);</span>
<span class="lineNum">    5065 </span><span class="lineNoCov">          0 :      nsBox::AddMargin(mHelper.mHScrollbarBox, hSize);</span>
<span class="lineNum">    5066 </span>            : 
<span class="lineNum">    5067 </span><span class="lineNoCov">          0 :      ScrollFrameHelper::SetScrollbarVisibility(mHelper.mHScrollbarBox, aAdd);</span>
<span class="lineNum">    5068 </span>            : 
<span class="lineNum">    5069 </span>            :      // We can't directly pass mHasHorizontalScrollbar as the bool outparam for
<span class="lineNum">    5070 </span>            :      // AddRemoveScrollbar() because it's a bool:1 bitfield. Hence this var:
<span class="lineNum">    5071 </span>            :      bool hasHorizontalScrollbar;
<span class="lineNum">    5072 </span><span class="lineNoCov">          0 :      bool fit = AddRemoveScrollbar(hasHorizontalScrollbar,</span>
<span class="lineNum">    5073 </span>            :                                    mHelper.mScrollPort.y,
<span class="lineNum">    5074 </span>            :                                    mHelper.mScrollPort.height,
<span class="lineNum">    5075 </span><span class="lineNoCov">          0 :                                    hSize.height, aOnRightOrBottom, aAdd);</span>
<span class="lineNum">    5076 </span><span class="lineNoCov">          0 :      mHelper.mHasHorizontalScrollbar = hasHorizontalScrollbar;</span>
<span class="lineNum">    5077 </span><span class="lineNoCov">          0 :      if (!fit) {</span>
<span class="lineNum">    5078 </span><span class="lineNoCov">          0 :        ScrollFrameHelper::SetScrollbarVisibility(mHelper.mHScrollbarBox, !aAdd);</span>
<span class="lineNum">    5079 </span>            :      }
<span class="lineNum">    5080 </span>            :      return fit;
<span class="lineNum">    5081 </span>            :   } else {
<span class="lineNum">    5082 </span><span class="lineNoCov">          0 :      if (mHelper.mNeverHasVerticalScrollbar || !mHelper.mVScrollbarBox)</span>
<span class="lineNum">    5083 </span>            :        return false;
<span class="lineNum">    5084 </span>            : 
<span class="lineNum">    5085 </span><span class="lineNoCov">          0 :      nsSize vSize = mHelper.mVScrollbarBox-&gt;GetXULPrefSize(aState);</span>
<span class="lineNum">    5086 </span><span class="lineNoCov">          0 :      nsBox::AddMargin(mHelper.mVScrollbarBox, vSize);</span>
<span class="lineNum">    5087 </span>            : 
<span class="lineNum">    5088 </span><span class="lineNoCov">          0 :      ScrollFrameHelper::SetScrollbarVisibility(mHelper.mVScrollbarBox, aAdd);</span>
<span class="lineNum">    5089 </span>            : 
<span class="lineNum">    5090 </span>            :      // We can't directly pass mHasVerticalScrollbar as the bool outparam for
<span class="lineNum">    5091 </span>            :      // AddRemoveScrollbar() because it's a bool:1 bitfield. Hence this var:
<span class="lineNum">    5092 </span>            :      bool hasVerticalScrollbar;
<span class="lineNum">    5093 </span><span class="lineNoCov">          0 :      bool fit = AddRemoveScrollbar(hasVerticalScrollbar,</span>
<span class="lineNum">    5094 </span>            :                                    mHelper.mScrollPort.x,
<span class="lineNum">    5095 </span>            :                                    mHelper.mScrollPort.width,
<span class="lineNum">    5096 </span><span class="lineNoCov">          0 :                                    vSize.width, aOnRightOrBottom, aAdd);</span>
<span class="lineNum">    5097 </span><span class="lineNoCov">          0 :      mHelper.mHasVerticalScrollbar = hasVerticalScrollbar;</span>
<span class="lineNum">    5098 </span><span class="lineNoCov">          0 :      if (!fit) {</span>
<span class="lineNum">    5099 </span><span class="lineNoCov">          0 :        ScrollFrameHelper::SetScrollbarVisibility(mHelper.mVScrollbarBox, !aAdd);</span>
<span class="lineNum">    5100 </span>            :      }
<span class="lineNum">    5101 </span>            :      return fit;
<span class="lineNum">    5102 </span>            :   }
<span class="lineNum">    5103 </span>            : }
<span class="lineNum">    5104 </span>            : 
<span class="lineNum">    5105 </span>            : bool
<span class="lineNum">    5106 </span><span class="lineNoCov">          0 : nsXULScrollFrame::AddRemoveScrollbar(bool&amp; aHasScrollbar, nscoord&amp; aXY,</span>
<span class="lineNum">    5107 </span>            :                                      nscoord&amp; aSize, nscoord aSbSize,
<span class="lineNum">    5108 </span>            :                                      bool aOnRightOrBottom, bool aAdd)
<span class="lineNum">    5109 </span>            : {
<span class="lineNum">    5110 </span><span class="lineNoCov">          0 :    nscoord size = aSize;</span>
<span class="lineNum">    5111 </span><span class="lineNoCov">          0 :    nscoord xy = aXY;</span>
<span class="lineNum">    5112 </span>            : 
<span class="lineNum">    5113 </span><span class="lineNoCov">          0 :    if (size != NS_INTRINSICSIZE) {</span>
<span class="lineNum">    5114 </span><span class="lineNoCov">          0 :      if (aAdd) {</span>
<span class="lineNum">    5115 </span><span class="lineNoCov">          0 :         size -= aSbSize;</span>
<span class="lineNum">    5116 </span><span class="lineNoCov">          0 :         if (!aOnRightOrBottom &amp;&amp; size &gt;= 0)</span>
<span class="lineNum">    5117 </span><span class="lineNoCov">          0 :           xy += aSbSize;</span>
<span class="lineNum">    5118 </span>            :      } else {
<span class="lineNum">    5119 </span><span class="lineNoCov">          0 :         size += aSbSize;</span>
<span class="lineNum">    5120 </span><span class="lineNoCov">          0 :         if (!aOnRightOrBottom)</span>
<span class="lineNum">    5121 </span><span class="lineNoCov">          0 :           xy -= aSbSize;</span>
<span class="lineNum">    5122 </span>            :      }
<span class="lineNum">    5123 </span>            :    }
<span class="lineNum">    5124 </span>            : 
<span class="lineNum">    5125 </span>            :    // not enough room? Yes? Return true.
<span class="lineNum">    5126 </span><span class="lineNoCov">          0 :    if (size &gt;= 0) {</span>
<span class="lineNum">    5127 </span><span class="lineNoCov">          0 :        aHasScrollbar = aAdd;</span>
<span class="lineNum">    5128 </span><span class="lineNoCov">          0 :        aSize = size;</span>
<span class="lineNum">    5129 </span><span class="lineNoCov">          0 :        aXY = xy;</span>
<span class="lineNum">    5130 </span><span class="lineNoCov">          0 :        return true;</span>
<span class="lineNum">    5131 </span>            :    }
<span class="lineNum">    5132 </span>            : 
<span class="lineNum">    5133 </span><span class="lineNoCov">          0 :    aHasScrollbar = false;</span>
<span class="lineNum">    5134 </span><span class="lineNoCov">          0 :    return false;</span>
<span class="lineNum">    5135 </span>            : }
<span class="lineNum">    5136 </span>            : 
<span class="lineNum">    5137 </span>            : void
<span class="lineNum">    5138 </span><span class="lineCov">         17 : nsXULScrollFrame::LayoutScrollArea(nsBoxLayoutState&amp; aState,</span>
<span class="lineNum">    5139 </span>            :                                    const nsPoint&amp; aScrollPosition)
<span class="lineNum">    5140 </span>            : {
<span class="lineNum">    5141 </span><span class="lineNoCov">          0 :   uint32_t oldflags = aState.LayoutFlags();</span>
<span class="lineNum">    5142 </span><span class="lineCov">         51 :   nsRect childRect = nsRect(mHelper.mScrollPort.TopLeft() - aScrollPosition,</span>
<span class="lineNum">    5143 </span><span class="lineNoCov">          0 :                             mHelper.mScrollPort.Size());</span>
<span class="lineNum">    5144 </span><span class="lineCov">         17 :   int32_t flags = NS_FRAME_NO_MOVE_VIEW;</span>
<span class="lineNum">    5145 </span>            : 
<span class="lineNum">    5146 </span><span class="lineNoCov">          0 :   nsSize minSize = mHelper.mScrolledFrame-&gt;GetXULMinSize(aState);</span>
<span class="lineNum">    5147 </span>            : 
<span class="lineNum">    5148 </span><span class="lineCov">          1 :   if (minSize.height &gt; childRect.height)</span>
<span class="lineNum">    5149 </span><span class="lineCov">          1 :     childRect.height = minSize.height;</span>
<span class="lineNum">    5150 </span>            : 
<span class="lineNum">    5151 </span><span class="lineCov">         17 :   if (minSize.width &gt; childRect.width)</span>
<span class="lineNum">    5152 </span><span class="lineNoCov">          0 :     childRect.width = minSize.width;</span>
<span class="lineNum">    5153 </span>            : 
<span class="lineNum">    5154 </span>            :   // TODO: Handle transformed children that inherit perspective
<span class="lineNum">    5155 </span>            :   // from this frame. See AdjustForPerspective for how we handle
<span class="lineNum">    5156 </span>            :   // this for HTML scroll frames.
<span class="lineNum">    5157 </span>            : 
<span class="lineNum">    5158 </span><span class="lineCov">         34 :   aState.SetLayoutFlags(flags);</span>
<span class="lineNum">    5159 </span><span class="lineNoCov">          0 :   ClampAndSetBounds(aState, childRect, aScrollPosition);</span>
<span class="lineNum">    5160 </span><span class="lineCov">         17 :   mHelper.mScrolledFrame-&gt;XULLayout(aState);</span>
<span class="lineNum">    5161 </span>            : 
<span class="lineNum">    5162 </span><span class="lineCov">         34 :   childRect = mHelper.mScrolledFrame-&gt;GetRect();</span>
<span class="lineNum">    5163 </span>            : 
<span class="lineNum">    5164 </span><span class="lineCov">         34 :   if (childRect.width &lt; mHelper.mScrollPort.width ||</span>
<span class="lineNum">    5165 </span><span class="lineCov">         17 :       childRect.height &lt; mHelper.mScrollPort.height)</span>
<span class="lineNum">    5166 </span>            :   {
<span class="lineNum">    5167 </span><span class="lineNoCov">          0 :     childRect.width = std::max(childRect.width, mHelper.mScrollPort.width);</span>
<span class="lineNum">    5168 </span><span class="lineNoCov">          0 :     childRect.height = std::max(childRect.height, mHelper.mScrollPort.height);</span>
<span class="lineNum">    5169 </span>            : 
<span class="lineNum">    5170 </span>            :     // remove overflow areas when we update the bounds,
<span class="lineNum">    5171 </span>            :     // because we've already accounted for it
<span class="lineNum">    5172 </span>            :     // REVIEW: Have we accounted for both?
<span class="lineNum">    5173 </span><span class="lineNoCov">          0 :     ClampAndSetBounds(aState, childRect, aScrollPosition, true);</span>
<span class="lineNum">    5174 </span>            :   }
<span class="lineNum">    5175 </span>            : 
<span class="lineNum">    5176 </span><span class="lineCov">         34 :   aState.SetLayoutFlags(oldflags);</span>
<span class="lineNum">    5177 </span>            : 
<span class="lineNum">    5178 </span><span class="lineCov">         17 : }</span>
<span class="lineNum">    5179 </span>            : 
<span class="lineNum">    5180 </span><span class="lineCov">         59 : void ScrollFrameHelper::PostOverflowEvent()</span>
<span class="lineNum">    5181 </span>            : {
<span class="lineNum">    5182 </span><span class="lineNoCov">          0 :   if (mAsyncScrollPortEvent.IsPending()) {</span>
<span class="lineNum">    5183 </span>            :     return;
<span class="lineNum">    5184 </span>            :   }
<span class="lineNum">    5185 </span>            : 
<span class="lineNum">    5186 </span>            :   // Keep this in sync with FireScrollPortEvent().
<span class="lineNum">    5187 </span><span class="lineNoCov">          0 :   nsSize scrollportSize = mScrollPort.Size();</span>
<span class="lineNum">    5188 </span><span class="lineCov">        116 :   nsSize childSize = GetScrolledRect().Size();</span>
<span class="lineNum">    5189 </span>            : 
<span class="lineNum">    5190 </span><span class="lineCov">         58 :   bool newVerticalOverflow = childSize.height &gt; scrollportSize.height;</span>
<span class="lineNum">    5191 </span><span class="lineNoCov">          0 :   bool vertChanged = mVerticalOverflow != newVerticalOverflow;</span>
<span class="lineNum">    5192 </span>            : 
<span class="lineNum">    5193 </span><span class="lineNoCov">          0 :   bool newHorizontalOverflow = childSize.width &gt; scrollportSize.width;</span>
<span class="lineNum">    5194 </span><span class="lineCov">         58 :   bool horizChanged = mHorizontalOverflow != newHorizontalOverflow;</span>
<span class="lineNum">    5195 </span>            : 
<span class="lineNum">    5196 </span><span class="lineCov">         58 :   if (!vertChanged &amp;&amp; !horizChanged) {</span>
<span class="lineNum">    5197 </span>            :     return;
<span class="lineNum">    5198 </span>            :   }
<span class="lineNum">    5199 </span>            : 
<span class="lineNum">    5200 </span><span class="lineCov">          4 :   nsRootPresContext* rpc = mOuter-&gt;PresContext()-&gt;GetRootPresContext();</span>
<span class="lineNum">    5201 </span><span class="lineCov">          2 :   if (!rpc) {</span>
<span class="lineNum">    5202 </span>            :     return;
<span class="lineNum">    5203 </span>            :   }
<span class="lineNum">    5204 </span>            : 
<span class="lineNum">    5205 </span><span class="lineNoCov">          0 :   mAsyncScrollPortEvent = new AsyncScrollPortEvent(this);</span>
<span class="lineNum">    5206 </span><span class="lineNoCov">          0 :   rpc-&gt;AddWillPaintObserver(mAsyncScrollPortEvent.get());</span>
<span class="lineNum">    5207 </span>            : }
<span class="lineNum">    5208 </span>            : 
<span class="lineNum">    5209 </span>            : nsIFrame*
<span class="lineNum">    5210 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetFrameForDir() const</span>
<span class="lineNum">    5211 </span>            : {
<span class="lineNum">    5212 </span><span class="lineNoCov">          0 :   nsIFrame *frame = mOuter;</span>
<span class="lineNum">    5213 </span>            :   // XXX This is a bit on the slow side.
<span class="lineNum">    5214 </span><span class="lineCov">        716 :   if (mIsRoot) {</span>
<span class="lineNum">    5215 </span>            :     // If we're the root scrollframe, we need the root element's style data.
<span class="lineNum">    5216 </span><span class="lineCov">        398 :     nsPresContext *presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    5217 </span><span class="lineCov">        199 :     nsIDocument *document = presContext-&gt;Document();</span>
<span class="lineNum">    5218 </span><span class="lineNoCov">          0 :     Element *root = document-&gt;GetRootElement();</span>
<span class="lineNum">    5219 </span>            : 
<span class="lineNum">    5220 </span>            :     // But for HTML and XHTML we want the body element.
<span class="lineNum">    5221 </span><span class="lineCov">        398 :     nsCOMPtr&lt;nsIHTMLDocument&gt; htmlDoc = do_QueryInterface(document);</span>
<span class="lineNum">    5222 </span><span class="lineNoCov">          0 :     if (htmlDoc) {</span>
<span class="lineNum">    5223 </span><span class="lineCov">         29 :       Element *bodyElement = document-&gt;GetBodyElement();</span>
<span class="lineNum">    5224 </span><span class="lineNoCov">          0 :       if (bodyElement) {</span>
<span class="lineNum">    5225 </span><span class="lineCov">         29 :         root = bodyElement; // we can trust the document to hold on to it</span>
<span class="lineNum">    5226 </span>            :       }
<span class="lineNum">    5227 </span>            :     }
<span class="lineNum">    5228 </span>            : 
<span class="lineNum">    5229 </span><span class="lineNoCov">          0 :     if (root) {</span>
<span class="lineNum">    5230 </span><span class="lineNoCov">          0 :       nsIFrame *rootsFrame = root-&gt;GetPrimaryFrame();</span>
<span class="lineNum">    5231 </span><span class="lineCov">        199 :       if (rootsFrame) {</span>
<span class="lineNum">    5232 </span><span class="lineNoCov">          0 :         frame = rootsFrame;</span>
<span class="lineNum">    5233 </span>            :       }
<span class="lineNum">    5234 </span>            :     }
<span class="lineNum">    5235 </span>            :   }
<span class="lineNum">    5236 </span>            : 
<span class="lineNum">    5237 </span><span class="lineCov">        716 :   return frame;</span>
<span class="lineNum">    5238 </span>            : }
<span class="lineNum">    5239 </span>            : 
<span class="lineNum">    5240 </span>            : bool
<span class="lineNum">    5241 </span><span class="lineCov">        115 : ScrollFrameHelper::IsScrollbarOnRight() const</span>
<span class="lineNum">    5242 </span>            : {
<span class="lineNum">    5243 </span><span class="lineCov">        230 :   nsPresContext *presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    5244 </span>            : 
<span class="lineNum">    5245 </span>            :   // The position of the scrollbar in top-level windows depends on the pref
<span class="lineNum">    5246 </span>            :   // layout.scrollbar.side. For non-top-level elements, it depends only on the
<span class="lineNum">    5247 </span>            :   // directionaliy of the element (equivalent to a value of &quot;1&quot; for the pref).
<span class="lineNum">    5248 </span><span class="lineCov">        115 :   if (!mIsRoot) {</span>
<span class="lineNum">    5249 </span><span class="lineNoCov">          0 :     return IsPhysicalLTR();</span>
<span class="lineNum">    5250 </span>            :   }
<span class="lineNum">    5251 </span><span class="lineCov">         64 :   switch (presContext-&gt;GetCachedIntPref(kPresContext_ScrollbarSide)) {</span>
<span class="lineNum">    5252 </span>            :     default:
<span class="lineNum">    5253 </span>            :     case 0: // UI directionality
<span class="lineNum">    5254 </span><span class="lineNoCov">          0 :       return presContext-&gt;GetCachedIntPref(kPresContext_BidiDirection)</span>
<span class="lineNum">    5255 </span><span class="lineNoCov">          0 :              == IBMBIDI_TEXTDIRECTION_LTR;</span>
<span class="lineNum">    5256 </span>            :     case 1: // Document / content directionality
<span class="lineNum">    5257 </span><span class="lineNoCov">          0 :       return IsPhysicalLTR();</span>
<span class="lineNum">    5258 </span>            :     case 2: // Always right
<span class="lineNum">    5259 </span>            :       return true;
<span class="lineNum">    5260 </span>            :     case 3: // Always left
<span class="lineNum">    5261 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5262 </span>            :   }
<span class="lineNum">    5263 </span>            : }
<span class="lineNum">    5264 </span>            : 
<span class="lineNum">    5265 </span>            : bool
<span class="lineNum">    5266 </span><span class="lineNoCov">          0 : ScrollFrameHelper::IsMaybeScrollingActive() const</span>
<span class="lineNum">    5267 </span>            : {
<span class="lineNum">    5268 </span><span class="lineCov">         65 :   const nsStyleDisplay* disp = mOuter-&gt;StyleDisplay();</span>
<span class="lineNum">    5269 </span><span class="lineCov">         65 :   if (disp &amp;&amp; (disp-&gt;mWillChangeBitField &amp; NS_STYLE_WILL_CHANGE_SCROLL)) {</span>
<span class="lineNum">    5270 </span>            :     return true;
<span class="lineNum">    5271 </span>            :   }
<span class="lineNum">    5272 </span>            : 
<span class="lineNum">    5273 </span><span class="lineNoCov">          0 :   nsIContent* content = mOuter-&gt;GetContent();</span>
<span class="lineNum">    5274 </span><span class="lineNoCov">          0 :   return mHasBeenScrolledRecently ||</span>
<span class="lineNum">    5275 </span><span class="lineCov">        130 :          IsAlwaysActive() ||</span>
<span class="lineNum">    5276 </span><span class="lineCov">        195 :          nsLayoutUtils::HasDisplayPort(content) ||</span>
<span class="lineNum">    5277 </span><span class="lineCov">         65 :          nsContentUtils::HasScrollgrab(content);</span>
<span class="lineNum">    5278 </span>            : }
<span class="lineNum">    5279 </span>            : 
<span class="lineNum">    5280 </span>            : bool
<span class="lineNum">    5281 </span><span class="lineCov">         65 : ScrollFrameHelper::IsScrollingActive(nsDisplayListBuilder* aBuilder) const</span>
<span class="lineNum">    5282 </span>            : {
<span class="lineNum">    5283 </span><span class="lineCov">         65 :   const nsStyleDisplay* disp = mOuter-&gt;StyleDisplay();</span>
<span class="lineNum">    5284 </span><span class="lineNoCov">          0 :   if (disp &amp;&amp; (disp-&gt;mWillChangeBitField &amp; NS_STYLE_WILL_CHANGE_SCROLL) &amp;&amp;</span>
<span class="lineNum">    5285 </span><span class="lineNoCov">          0 :     aBuilder-&gt;IsInWillChangeBudget(mOuter, GetScrollPositionClampingScrollPortSize())) {</span>
<span class="lineNum">    5286 </span>            :     return true;
<span class="lineNum">    5287 </span>            :   }
<span class="lineNum">    5288 </span>            : 
<span class="lineNum">    5289 </span><span class="lineNoCov">          0 :   nsIContent* content = mOuter-&gt;GetContent();</span>
<span class="lineNum">    5290 </span><span class="lineCov">        130 :   return mHasBeenScrolledRecently ||</span>
<span class="lineNum">    5291 </span><span class="lineNoCov">          0 :          IsAlwaysActive() ||</span>
<span class="lineNum">    5292 </span><span class="lineNoCov">          0 :          nsLayoutUtils::HasDisplayPort(content) ||</span>
<span class="lineNum">    5293 </span><span class="lineCov">         65 :          nsContentUtils::HasScrollgrab(content);</span>
<span class="lineNum">    5294 </span>            : }
<span class="lineNum">    5295 </span>            : 
<span class="lineNum">    5296 </span>            : /**
<span class="lineNum">    5297 </span>            :  * Reflow the scroll area if it needs it and return its size. Also determine if the reflow will
<span class="lineNum">    5298 </span>            :  * cause any of the scrollbars to need to be reflowed.
<span class="lineNum">    5299 </span>            :  */
<span class="lineNum">    5300 </span>            : nsresult
<span class="lineNum">    5301 </span><span class="lineCov">         17 : nsXULScrollFrame::XULLayout(nsBoxLayoutState&amp; aState)</span>
<span class="lineNum">    5302 </span>            : {
<span class="lineNum">    5303 </span><span class="lineCov">         17 :   bool scrollbarRight = IsScrollbarOnRight();</span>
<span class="lineNum">    5304 </span><span class="lineCov">         17 :   bool scrollbarBottom = true;</span>
<span class="lineNum">    5305 </span>            : 
<span class="lineNum">    5306 </span>            :   // get the content rect
<span class="lineNum">    5307 </span><span class="lineCov">         34 :   nsRect clientRect(0,0,0,0);</span>
<span class="lineNum">    5308 </span><span class="lineCov">         17 :   GetXULClientRect(clientRect);</span>
<span class="lineNum">    5309 </span>            : 
<span class="lineNum">    5310 </span><span class="lineCov">         34 :   nsRect oldScrollAreaBounds = mHelper.mScrollPort;</span>
<span class="lineNum">    5311 </span><span class="lineCov">         17 :   nsPoint oldScrollPosition = mHelper.GetLogicalScrollPosition();</span>
<span class="lineNum">    5312 </span>            : 
<span class="lineNum">    5313 </span>            :   // the scroll area size starts off as big as our content area
<span class="lineNum">    5314 </span><span class="lineCov">         17 :   mHelper.mScrollPort = clientRect;</span>
<span class="lineNum">    5315 </span>            : 
<span class="lineNum">    5316 </span>            :   /**************
<span class="lineNum">    5317 </span>            :    Our basic strategy here is to first try laying out the content with
<span class="lineNum">    5318 </span>            :    the scrollbars in their current state. We're hoping that that will
<span class="lineNum">    5319 </span>            :    just &quot;work&quot;; the content will overflow wherever there's a scrollbar
<span class="lineNum">    5320 </span>            :    already visible. If that does work, then there's no need to lay out
<span class="lineNum">    5321 </span>            :    the scrollarea. Otherwise we fix up the scrollbars; first we add a
<span class="lineNum">    5322 </span>            :    vertical one to scroll the content if necessary, or remove it if
<span class="lineNum">    5323 </span>            :    it's not needed. Then we reflow the content if the scrollbar
<span class="lineNum">    5324 </span>            :    changed.  Then we add a horizontal scrollbar if necessary (or
<span class="lineNum">    5325 </span>            :    remove if not needed), and if that changed, we reflow the content
<span class="lineNum">    5326 </span>            :    again. At this point, any scrollbars that are needed to scroll the
<span class="lineNum">    5327 </span>            :    content have been added.
<span class="lineNum">    5328 </span>            : 
<span class="lineNum">    5329 </span>            :    In the second phase we check to see if any scrollbars are too small
<span class="lineNum">    5330 </span>            :    to display, and if so, we remove them. We check the horizontal
<span class="lineNum">    5331 </span>            :    scrollbar first; removing it might make room for the vertical
<span class="lineNum">    5332 </span>            :    scrollbar, and if we have room for just one scrollbar we'll save
<span class="lineNum">    5333 </span>            :    the vertical one.
<span class="lineNum">    5334 </span>            : 
<span class="lineNum">    5335 </span>            :    Finally we position and size the scrollbars and scrollcorner (the
<span class="lineNum">    5336 </span>            :    square that is needed in the corner of the window when two
<span class="lineNum">    5337 </span>            :    scrollbars are visible), and reflow any fixed position views
<span class="lineNum">    5338 </span>            :    (if we're the viewport and we added or removed a scrollbar).
<span class="lineNum">    5339 </span>            :    **************/
<span class="lineNum">    5340 </span>            : 
<span class="lineNum">    5341 </span><span class="lineCov">         34 :   ScrollbarStyles styles = GetScrollbarStyles();</span>
<span class="lineNum">    5342 </span>            : 
<span class="lineNum">    5343 </span>            :   // Look at our style do we always have vertical or horizontal scrollbars?
<span class="lineNum">    5344 </span><span class="lineCov">         17 :   if (styles.mHorizontal == NS_STYLE_OVERFLOW_SCROLL)</span>
<span class="lineNum">    5345 </span><span class="lineNoCov">          0 :     mHelper.mHasHorizontalScrollbar = true;</span>
<span class="lineNum">    5346 </span><span class="lineCov">         17 :   if (styles.mVertical == NS_STYLE_OVERFLOW_SCROLL)</span>
<span class="lineNum">    5347 </span><span class="lineNoCov">          0 :     mHelper.mHasVerticalScrollbar = true;</span>
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span><span class="lineNoCov">          0 :   if (mHelper.mHasHorizontalScrollbar)</span>
<span class="lineNum">    5350 </span><span class="lineNoCov">          0 :     AddHorizontalScrollbar(aState, scrollbarBottom);</span>
<span class="lineNum">    5351 </span>            : 
<span class="lineNum">    5352 </span><span class="lineCov">         17 :   if (mHelper.mHasVerticalScrollbar)</span>
<span class="lineNum">    5353 </span><span class="lineNoCov">          0 :     AddVerticalScrollbar(aState, scrollbarRight);</span>
<span class="lineNum">    5354 </span>            : 
<span class="lineNum">    5355 </span>            :   // layout our the scroll area
<span class="lineNum">    5356 </span><span class="lineCov">         17 :   LayoutScrollArea(aState, oldScrollPosition);</span>
<span class="lineNum">    5357 </span>            : 
<span class="lineNum">    5358 </span>            :   // now look at the content area and see if we need scrollbars or not
<span class="lineNum">    5359 </span><span class="lineCov">         17 :   bool needsLayout = false;</span>
<span class="lineNum">    5360 </span>            : 
<span class="lineNum">    5361 </span>            :   // if we have 'auto' scrollbars look at the vertical case
<span class="lineNum">    5362 </span><span class="lineCov">         17 :   if (styles.mVertical != NS_STYLE_OVERFLOW_SCROLL) {</span>
<span class="lineNum">    5363 </span>            :     // These are only good until the call to LayoutScrollArea.
<span class="lineNum">    5364 </span><span class="lineCov">         34 :     nsRect scrolledRect = mHelper.GetScrolledRect();</span>
<span class="lineNum">    5365 </span>            : 
<span class="lineNum">    5366 </span>            :     // There are two cases to consider
<span class="lineNum">    5367 </span><span class="lineNoCov">          0 :     if (scrolledRect.height &lt;= mHelper.mScrollPort.height ||</span>
<span class="lineNum">    5368 </span><span class="lineNoCov">          0 :         styles.mVertical != NS_STYLE_OVERFLOW_AUTO) {</span>
<span class="lineNum">    5369 </span><span class="lineNoCov">          0 :       if (mHelper.mHasVerticalScrollbar) {</span>
<span class="lineNum">    5370 </span>            :         // We left room for the vertical scrollbar, but it's not needed;
<span class="lineNum">    5371 </span>            :         // remove it.
<span class="lineNum">    5372 </span><span class="lineNoCov">          0 :         RemoveVerticalScrollbar(aState, scrollbarRight);</span>
<span class="lineNum">    5373 </span><span class="lineNoCov">          0 :         needsLayout = true;</span>
<span class="lineNum">    5374 </span>            :       }
<span class="lineNum">    5375 </span>            :     } else {
<span class="lineNum">    5376 </span><span class="lineNoCov">          0 :       if (!mHelper.mHasVerticalScrollbar) {</span>
<span class="lineNum">    5377 </span>            :         // We didn't leave room for the vertical scrollbar, but it turns
<span class="lineNum">    5378 </span>            :         // out we needed it
<span class="lineNum">    5379 </span><span class="lineNoCov">          0 :         if (AddVerticalScrollbar(aState, scrollbarRight)) {</span>
<span class="lineNum">    5380 </span><span class="lineNoCov">          0 :           needsLayout = true;</span>
<span class="lineNum">    5381 </span>            :         }
<span class="lineNum">    5382 </span>            :       }
<span class="lineNum">    5383 </span>            :     }
<span class="lineNum">    5384 </span>            : 
<span class="lineNum">    5385 </span>            :     // ok layout at the right size
<span class="lineNum">    5386 </span><span class="lineNoCov">          0 :     if (needsLayout) {</span>
<span class="lineNum">    5387 </span><span class="lineNoCov">          0 :       nsBoxLayoutState resizeState(aState);</span>
<span class="lineNum">    5388 </span><span class="lineNoCov">          0 :       LayoutScrollArea(resizeState, oldScrollPosition);</span>
<span class="lineNum">    5389 </span><span class="lineNoCov">          0 :       needsLayout = false;</span>
<span class="lineNum">    5390 </span>            :     }
<span class="lineNum">    5391 </span>            :   }
<span class="lineNum">    5392 </span>            : 
<span class="lineNum">    5393 </span>            : 
<span class="lineNum">    5394 </span>            :   // if scrollbars are auto look at the horizontal case
<span class="lineNum">    5395 </span><span class="lineCov">         17 :   if (styles.mHorizontal != NS_STYLE_OVERFLOW_SCROLL)</span>
<span class="lineNum">    5396 </span>            :   {
<span class="lineNum">    5397 </span>            :     // These are only good until the call to LayoutScrollArea.
<span class="lineNum">    5398 </span><span class="lineCov">         34 :     nsRect scrolledRect = mHelper.GetScrolledRect();</span>
<span class="lineNum">    5399 </span>            : 
<span class="lineNum">    5400 </span>            :     // if the child is wider that the scroll area
<span class="lineNum">    5401 </span>            :     // and we don't have a scrollbar add one.
<span class="lineNum">    5402 </span><span class="lineCov">         17 :     if ((scrolledRect.width &gt; mHelper.mScrollPort.width)</span>
<span class="lineNum">    5403 </span><span class="lineCov">          2 :         &amp;&amp; styles.mHorizontal == NS_STYLE_OVERFLOW_AUTO) {</span>
<span class="lineNum">    5404 </span>            : 
<span class="lineNum">    5405 </span><span class="lineNoCov">          0 :       if (!mHelper.mHasHorizontalScrollbar) {</span>
<span class="lineNum">    5406 </span>            :         // no scrollbar?
<span class="lineNum">    5407 </span><span class="lineNoCov">          0 :         if (AddHorizontalScrollbar(aState, scrollbarBottom)) {</span>
<span class="lineNum">    5408 </span>            : 
<span class="lineNum">    5409 </span>            :           // if we added a horizontal scrollbar and we did not have a vertical
<span class="lineNum">    5410 </span>            :           // there is a chance that by adding the horizontal scrollbar we will
<span class="lineNum">    5411 </span>            :           // suddenly need a vertical scrollbar. Is a special case but it's
<span class="lineNum">    5412 </span>            :           // important.
<span class="lineNum">    5413 </span>            :           //
<span class="lineNum">    5414 </span>            :           // But before we do that we need to relayout, since it's
<span class="lineNum">    5415 </span>            :           // possible that the contents will flex as a result of adding a
<span class="lineNum">    5416 </span>            :           // horizontal scrollbar and avoid the need for a vertical
<span class="lineNum">    5417 </span>            :           // scrollbar.
<span class="lineNum">    5418 </span>            :           //
<span class="lineNum">    5419 </span>            :           // So instead of setting needsLayout to true here, do the
<span class="lineNum">    5420 </span>            :           // layout immediately, and then consider whether to add the
<span class="lineNum">    5421 </span>            :           // vertical scrollbar (and then maybe layout again).
<span class="lineNum">    5422 </span>            :           {
<span class="lineNum">    5423 </span><span class="lineNoCov">          0 :             nsBoxLayoutState resizeState(aState);</span>
<span class="lineNum">    5424 </span><span class="lineNoCov">          0 :             LayoutScrollArea(resizeState, oldScrollPosition);</span>
<span class="lineNum">    5425 </span><span class="lineNoCov">          0 :             needsLayout = false;</span>
<span class="lineNum">    5426 </span>            :           }
<span class="lineNum">    5427 </span>            : 
<span class="lineNum">    5428 </span>            :           // Refresh scrolledRect because we called LayoutScrollArea.
<span class="lineNum">    5429 </span><span class="lineNoCov">          0 :           scrolledRect = mHelper.GetScrolledRect();</span>
<span class="lineNum">    5430 </span>            : 
<span class="lineNum">    5431 </span><span class="lineNoCov">          0 :           if (styles.mVertical == NS_STYLE_OVERFLOW_AUTO &amp;&amp;</span>
<span class="lineNum">    5432 </span><span class="lineNoCov">          0 :               !mHelper.mHasVerticalScrollbar &amp;&amp;</span>
<span class="lineNum">    5433 </span><span class="lineNoCov">          0 :               scrolledRect.height &gt; mHelper.mScrollPort.height) {</span>
<span class="lineNum">    5434 </span><span class="lineNoCov">          0 :             if (AddVerticalScrollbar(aState, scrollbarRight)) {</span>
<span class="lineNum">    5435 </span><span class="lineNoCov">          0 :               needsLayout = true;</span>
<span class="lineNum">    5436 </span>            :             }
<span class="lineNum">    5437 </span>            :           }
<span class="lineNum">    5438 </span>            :         }
<span class="lineNum">    5439 </span>            : 
<span class="lineNum">    5440 </span>            :       }
<span class="lineNum">    5441 </span>            :     } else {
<span class="lineNum">    5442 </span>            :       // if the area is smaller or equal to and we have a scrollbar then
<span class="lineNum">    5443 </span>            :       // remove it.
<span class="lineNum">    5444 </span><span class="lineNoCov">          0 :       if (mHelper.mHasHorizontalScrollbar) {</span>
<span class="lineNum">    5445 </span><span class="lineNoCov">          0 :         RemoveHorizontalScrollbar(aState, scrollbarBottom);</span>
<span class="lineNum">    5446 </span><span class="lineNoCov">          0 :         needsLayout = true;</span>
<span class="lineNum">    5447 </span>            :       }
<span class="lineNum">    5448 </span>            :     }
<span class="lineNum">    5449 </span>            :   }
<span class="lineNum">    5450 </span>            : 
<span class="lineNum">    5451 </span>            :   // we only need to set the rect. The inner child stays the same size.
<span class="lineNum">    5452 </span><span class="lineCov">         17 :   if (needsLayout) {</span>
<span class="lineNum">    5453 </span><span class="lineNoCov">          0 :     nsBoxLayoutState resizeState(aState);</span>
<span class="lineNum">    5454 </span><span class="lineNoCov">          0 :     LayoutScrollArea(resizeState, oldScrollPosition);</span>
<span class="lineNum">    5455 </span><span class="lineNoCov">          0 :     needsLayout = false;</span>
<span class="lineNum">    5456 </span>            :   }
<span class="lineNum">    5457 </span>            : 
<span class="lineNum">    5458 </span>            :   // get the preferred size of the scrollbars
<span class="lineNum">    5459 </span><span class="lineCov">         17 :   nsSize hMinSize(0, 0);</span>
<span class="lineNum">    5460 </span><span class="lineCov">         17 :   if (mHelper.mHScrollbarBox &amp;&amp; mHelper.mHasHorizontalScrollbar) {</span>
<span class="lineNum">    5461 </span><span class="lineNoCov">          0 :     GetScrollbarMetrics(aState, mHelper.mHScrollbarBox, &amp;hMinSize, nullptr, false);</span>
<span class="lineNum">    5462 </span>            :   }
<span class="lineNum">    5463 </span><span class="lineNoCov">          0 :   nsSize vMinSize(0, 0);</span>
<span class="lineNum">    5464 </span><span class="lineNoCov">          0 :   if (mHelper.mVScrollbarBox &amp;&amp; mHelper.mHasVerticalScrollbar) {</span>
<span class="lineNum">    5465 </span><span class="lineNoCov">          0 :     GetScrollbarMetrics(aState, mHelper.mVScrollbarBox, &amp;vMinSize, nullptr, true);</span>
<span class="lineNum">    5466 </span>            :   }
<span class="lineNum">    5467 </span>            : 
<span class="lineNum">    5468 </span>            :   // Disable scrollbars that are too small
<span class="lineNum">    5469 </span>            :   // Disable horizontal scrollbar first. If we have to disable only one
<span class="lineNum">    5470 </span>            :   // scrollbar, we'd rather keep the vertical scrollbar.
<span class="lineNum">    5471 </span>            :   // Note that we always give horizontal scrollbars their preferred height,
<span class="lineNum">    5472 </span>            :   // never their min-height. So check that there's room for the preferred height.
<span class="lineNum">    5473 </span><span class="lineCov">         17 :   if (mHelper.mHasHorizontalScrollbar &amp;&amp;</span>
<span class="lineNum">    5474 </span><span class="lineNoCov">          0 :       (hMinSize.width &gt; clientRect.width - vMinSize.width</span>
<span class="lineNum">    5475 </span><span class="lineNoCov">          0 :        || hMinSize.height &gt; clientRect.height)) {</span>
<span class="lineNum">    5476 </span><span class="lineNoCov">          0 :     RemoveHorizontalScrollbar(aState, scrollbarBottom);</span>
<span class="lineNum">    5477 </span><span class="lineNoCov">          0 :     needsLayout = true;</span>
<span class="lineNum">    5478 </span>            :   }
<span class="lineNum">    5479 </span>            :   // Now disable vertical scrollbar if necessary
<span class="lineNum">    5480 </span><span class="lineCov">          1 :   if (mHelper.mHasVerticalScrollbar &amp;&amp;</span>
<span class="lineNum">    5481 </span><span class="lineNoCov">          0 :       (vMinSize.height &gt; clientRect.height - hMinSize.height</span>
<span class="lineNum">    5482 </span><span class="lineNoCov">          0 :        || vMinSize.width &gt; clientRect.width)) {</span>
<span class="lineNum">    5483 </span><span class="lineNoCov">          0 :     RemoveVerticalScrollbar(aState, scrollbarRight);</span>
<span class="lineNum">    5484 </span><span class="lineNoCov">          0 :     needsLayout = true;</span>
<span class="lineNum">    5485 </span>            :   }
<span class="lineNum">    5486 </span>            : 
<span class="lineNum">    5487 </span>            :   // we only need to set the rect. The inner child stays the same size.
<span class="lineNum">    5488 </span><span class="lineCov">         17 :   if (needsLayout) {</span>
<span class="lineNum">    5489 </span><span class="lineNoCov">          0 :     nsBoxLayoutState resizeState(aState);</span>
<span class="lineNum">    5490 </span><span class="lineNoCov">          0 :     LayoutScrollArea(resizeState, oldScrollPosition);</span>
<span class="lineNum">    5491 </span>            :   }
<span class="lineNum">    5492 </span>            : 
<span class="lineNum">    5493 </span><span class="lineNoCov">          0 :   if (!mHelper.mSuppressScrollbarUpdate) {</span>
<span class="lineNum">    5494 </span><span class="lineNoCov">          0 :     mHelper.LayoutScrollbars(aState, clientRect, oldScrollAreaBounds);</span>
<span class="lineNum">    5495 </span>            :   }
<span class="lineNum">    5496 </span><span class="lineNoCov">          0 :   if (!mHelper.mPostedReflowCallback) {</span>
<span class="lineNum">    5497 </span>            :     // Make sure we'll try scrolling to restored position
<span class="lineNum">    5498 </span><span class="lineNoCov">          0 :     PresShell()-&gt;PostReflowCallback(&amp;mHelper);</span>
<span class="lineNum">    5499 </span><span class="lineNoCov">          0 :     mHelper.mPostedReflowCallback = true;</span>
<span class="lineNum">    5500 </span>            :   }
<span class="lineNum">    5501 </span><span class="lineCov">         34 :   if (!(GetStateBits() &amp; NS_FRAME_FIRST_REFLOW)) {</span>
<span class="lineNum">    5502 </span><span class="lineNoCov">          0 :     mHelper.mHadNonInitialReflow = true;</span>
<span class="lineNum">    5503 </span>            :   }
<span class="lineNum">    5504 </span>            : 
<span class="lineNum">    5505 </span><span class="lineNoCov">          0 :   mHelper.UpdateSticky();</span>
<span class="lineNum">    5506 </span>            : 
<span class="lineNum">    5507 </span>            :   // Set up overflow areas for block frames for the benefit of
<span class="lineNum">    5508 </span>            :   // text-overflow.
<span class="lineNum">    5509 </span><span class="lineNoCov">          0 :   nsIFrame* f = mHelper.mScrolledFrame-&gt;GetContentInsertionFrame();</span>
<span class="lineNum">    5510 </span><span class="lineCov">         17 :   if (nsLayoutUtils::GetAsBlock(f)) {</span>
<span class="lineNum">    5511 </span><span class="lineNoCov">          0 :     nsRect origRect = f-&gt;GetRect();</span>
<span class="lineNum">    5512 </span><span class="lineNoCov">          0 :     nsRect clippedRect = origRect;</span>
<span class="lineNum">    5513 </span><span class="lineNoCov">          0 :     clippedRect.MoveBy(mHelper.mScrollPort.TopLeft());</span>
<span class="lineNum">    5514 </span><span class="lineNoCov">          0 :     clippedRect.IntersectRect(clippedRect, mHelper.mScrollPort);</span>
<span class="lineNum">    5515 </span><span class="lineNoCov">          0 :     nsOverflowAreas overflow = f-&gt;GetOverflowAreas();</span>
<span class="lineNum">    5516 </span><span class="lineNoCov">          0 :     f-&gt;FinishAndStoreOverflow(overflow, clippedRect.Size());</span>
<span class="lineNum">    5517 </span><span class="lineNoCov">          0 :     clippedRect.MoveTo(origRect.TopLeft());</span>
<span class="lineNum">    5518 </span><span class="lineNoCov">          0 :     f-&gt;SetRect(clippedRect);</span>
<span class="lineNum">    5519 </span>            :   }
<span class="lineNum">    5520 </span>            : 
<span class="lineNum">    5521 </span><span class="lineNoCov">          0 :   mHelper.UpdatePrevScrolledRect();</span>
<span class="lineNum">    5522 </span>            : 
<span class="lineNum">    5523 </span><span class="lineCov">         17 :   mHelper.PostOverflowEvent();</span>
<span class="lineNum">    5524 </span><span class="lineNoCov">          0 :   return NS_OK;</span>
<span class="lineNum">    5525 </span>            : }
<span class="lineNum">    5526 </span>            : 
<span class="lineNum">    5527 </span>            : void
<span class="lineNum">    5528 </span><span class="lineNoCov">          0 : ScrollFrameHelper::FinishReflowForScrollbar(Element* aElement,</span>
<span class="lineNum">    5529 </span>            :                                             nscoord aMinXY, nscoord aMaxXY,
<span class="lineNum">    5530 </span>            :                                             nscoord aCurPosXY,
<span class="lineNum">    5531 </span>            :                                             nscoord aPageIncrement,
<span class="lineNum">    5532 </span>            :                                             nscoord aIncrement)
<span class="lineNum">    5533 </span>            : {
<span class="lineNum">    5534 </span>            :   // Scrollbars assume zero is the minimum position, so translate for them.
<span class="lineNum">    5535 </span><span class="lineNoCov">          0 :   SetCoordAttribute(aElement, nsGkAtoms::curpos, aCurPosXY - aMinXY);</span>
<span class="lineNum">    5536 </span><span class="lineCov">         10 :   SetScrollbarEnabled(aElement, aMaxXY - aMinXY);</span>
<span class="lineNum">    5537 </span><span class="lineNoCov">          0 :   SetCoordAttribute(aElement, nsGkAtoms::maxpos, aMaxXY - aMinXY);</span>
<span class="lineNum">    5538 </span><span class="lineNoCov">          0 :   SetCoordAttribute(aElement, nsGkAtoms::pageincrement, aPageIncrement);</span>
<span class="lineNum">    5539 </span><span class="lineCov">         10 :   SetCoordAttribute(aElement, nsGkAtoms::increment, aIncrement);</span>
<span class="lineNum">    5540 </span><span class="lineCov">         10 : }</span>
<span class="lineNum">    5541 </span>            : 
<span class="lineNum">    5542 </span>            : bool
<span class="lineNum">    5543 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ReflowFinished()</span>
<span class="lineNum">    5544 </span>            : {
<span class="lineNum">    5545 </span><span class="lineCov">         57 :   mPostedReflowCallback = false;</span>
<span class="lineNum">    5546 </span>            : 
<span class="lineNum">    5547 </span><span class="lineCov">         57 :   bool doScroll = true;</span>
<span class="lineNum">    5548 </span><span class="lineNoCov">          0 :   if (NS_SUBTREE_DIRTY(mOuter)) {</span>
<span class="lineNum">    5549 </span>            :     // We will get another call after the next reflow and scrolling
<span class="lineNum">    5550 </span>            :     // later is less janky.
<span class="lineNum">    5551 </span><span class="lineCov">          1 :     doScroll = false;</span>
<span class="lineNum">    5552 </span>            :   }
<span class="lineNum">    5553 </span>            : 
<span class="lineNum">    5554 </span><span class="lineCov">        171 :   nsAutoScriptBlocker scriptBlocker;</span>
<span class="lineNum">    5555 </span>            : 
<span class="lineNum">    5556 </span><span class="lineCov">         57 :   if (doScroll) {</span>
<span class="lineNum">    5557 </span><span class="lineCov">         56 :     ScrollToRestoredPosition();</span>
<span class="lineNum">    5558 </span>            : 
<span class="lineNum">    5559 </span>            :     // Clamp current scroll position to new bounds. Normally this won't
<span class="lineNum">    5560 </span>            :     // do anything.
<span class="lineNum">    5561 </span><span class="lineNoCov">          0 :     nsPoint currentScrollPos = GetScrollPosition();</span>
<span class="lineNum">    5562 </span><span class="lineNoCov">          0 :     ScrollToImpl(currentScrollPos, nsRect(currentScrollPos, nsSize(0, 0)));</span>
<span class="lineNum">    5563 </span><span class="lineNoCov">          0 :     if (!mAsyncScroll &amp;&amp; !mAsyncSmoothMSDScroll &amp;&amp; !mApzSmoothScrollDestination) {</span>
<span class="lineNum">    5564 </span>            :       // We need to have mDestination track the current scroll position,
<span class="lineNum">    5565 </span>            :       // in case it falls outside the new reflow area. mDestination is used
<span class="lineNum">    5566 </span>            :       // by ScrollBy as its starting position.
<span class="lineNum">    5567 </span><span class="lineNoCov">          0 :       mDestination = GetScrollPosition();</span>
<span class="lineNum">    5568 </span>            :     }
<span class="lineNum">    5569 </span>            :   }
<span class="lineNum">    5570 </span>            : 
<span class="lineNum">    5571 </span><span class="lineCov">         57 :   if (!mUpdateScrollbarAttributes) {</span>
<span class="lineNum">    5572 </span>            :     return false;
<span class="lineNum">    5573 </span>            :   }
<span class="lineNum">    5574 </span><span class="lineNoCov">          0 :   mUpdateScrollbarAttributes = false;</span>
<span class="lineNum">    5575 </span>            : 
<span class="lineNum">    5576 </span>            :   // Update scrollbar attributes.
<span class="lineNum">    5577 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    5578 </span>            : 
<span class="lineNum">    5579 </span><span class="lineCov">         51 :   if (mMayHaveDirtyFixedChildren) {</span>
<span class="lineNum">    5580 </span><span class="lineCov">         11 :     mMayHaveDirtyFixedChildren = false;</span>
<span class="lineNum">    5581 </span><span class="lineNoCov">          0 :     nsIFrame* parentFrame = mOuter-&gt;GetParent();</span>
<span class="lineNum">    5582 </span><span class="lineNoCov">          0 :     for (nsIFrame* fixedChild =</span>
<span class="lineNum">    5583 </span><span class="lineCov">         11 :            parentFrame-&gt;GetChildList(nsIFrame::kFixedList).FirstChild();</span>
<span class="lineNum">    5584 </span><span class="lineCov">         11 :          fixedChild; fixedChild = fixedChild-&gt;GetNextSibling()) {</span>
<span class="lineNum">    5585 </span>            :       // force a reflow of the fixed child
<span class="lineNum">    5586 </span><span class="lineNoCov">          0 :       presContext-&gt;PresShell()-&gt;</span>
<span class="lineNum">    5587 </span>            :         FrameNeedsReflow(fixedChild, nsIPresShell::eResize,
<span class="lineNum">    5588 </span><span class="lineNoCov">          0 :                          NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    5589 </span>            :     }
<span class="lineNum">    5590 </span>            :   }
<span class="lineNum">    5591 </span>            : 
<span class="lineNum">    5592 </span><span class="lineCov">        102 :   nsRect scrolledContentRect = GetScrolledRect();</span>
<span class="lineNum">    5593 </span><span class="lineNoCov">          0 :   nsSize scrollClampingScrollPort = GetScrollPositionClampingScrollPortSize();</span>
<span class="lineNum">    5594 </span><span class="lineNoCov">          0 :   nscoord minX = scrolledContentRect.x;</span>
<span class="lineNum">    5595 </span><span class="lineNoCov">          0 :   nscoord maxX = scrolledContentRect.XMost() - scrollClampingScrollPort.width;</span>
<span class="lineNum">    5596 </span><span class="lineNoCov">          0 :   nscoord minY = scrolledContentRect.y;</span>
<span class="lineNum">    5597 </span><span class="lineNoCov">          0 :   nscoord maxY = scrolledContentRect.YMost() - scrollClampingScrollPort.height;</span>
<span class="lineNum">    5598 </span>            : 
<span class="lineNum">    5599 </span>            :   // Suppress handling of the curpos attribute changes we make here.
<span class="lineNum">    5600 </span><span class="lineNoCov">          0 :   NS_ASSERTION(!mFrameIsUpdatingScrollbar, &quot;We shouldn't be reentering here&quot;);</span>
<span class="lineNum">    5601 </span><span class="lineNoCov">          0 :   mFrameIsUpdatingScrollbar = true;</span>
<span class="lineNum">    5602 </span>            : 
<span class="lineNum">    5603 </span>            :   // FIXME(emilio): Why this instead of mHScrollbarContent / mVScrollbarContent?
<span class="lineNum">    5604 </span>            :   RefPtr&lt;Element&gt; vScroll =
<span class="lineNum">    5605 </span><span class="lineCov">        107 :     mVScrollbarBox ? mVScrollbarBox-&gt;GetContent()-&gt;AsElement() : nullptr;</span>
<span class="lineNum">    5606 </span>            :   RefPtr&lt;Element&gt; hScroll =
<span class="lineNum">    5607 </span><span class="lineCov">        107 :     mHScrollbarBox ? mHScrollbarBox-&gt;GetContent()-&gt;AsElement() : nullptr;</span>
<span class="lineNum">    5608 </span>            : 
<span class="lineNum">    5609 </span>            :   // Note, in some cases mOuter may get deleted while finishing reflow
<span class="lineNum">    5610 </span>            :   // for scrollbars. XXXmats is this still true now that we have a script
<span class="lineNum">    5611 </span>            :   // blocker in this scope? (if not, remove the weak frame checks below).
<span class="lineNum">    5612 </span><span class="lineNoCov">          0 :   if (vScroll || hScroll) {</span>
<span class="lineNum">    5613 </span><span class="lineNoCov">          0 :     AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    5614 </span><span class="lineCov">          5 :     nsPoint scrollPos = GetScrollPosition();</span>
<span class="lineNum">    5615 </span><span class="lineNoCov">          0 :     nsSize lineScrollAmount = GetLineScrollAmount();</span>
<span class="lineNum">    5616 </span><span class="lineCov">          5 :     if (vScroll) {</span>
<span class="lineNum">    5617 </span>            :       const double kScrollMultiplier =
<span class="lineNum">    5618 </span><span class="lineNoCov">          0 :         Preferences::GetInt(&quot;toolkit.scrollbox.verticalScrollDistance&quot;,</span>
<span class="lineNum">    5619 </span><span class="lineNoCov">          0 :                             NS_DEFAULT_VERTICAL_SCROLL_DISTANCE);</span>
<span class="lineNum">    5620 </span><span class="lineNoCov">          0 :       nscoord increment = lineScrollAmount.height * kScrollMultiplier;</span>
<span class="lineNum">    5621 </span>            :       // We normally use (scrollArea.height - increment) for height
<span class="lineNum">    5622 </span>            :       // of page scrolling.  However, it is too small when
<span class="lineNum">    5623 </span>            :       // increment is very large. (If increment is larger than
<span class="lineNum">    5624 </span>            :       // scrollArea.height, direction of scrolling will be opposite).
<span class="lineNum">    5625 </span>            :       // To avoid it, we use (float(scrollArea.height) * 0.8) as
<span class="lineNum">    5626 </span>            :       // lower bound value of height of page scrolling. (bug 383267)
<span class="lineNum">    5627 </span>            :       // XXX shouldn't we use GetPageScrollAmount here?
<span class="lineNum">    5628 </span><span class="lineCov">          5 :       nscoord pageincrement = nscoord(scrollClampingScrollPort.height - increment);</span>
<span class="lineNum">    5629 </span><span class="lineCov">          5 :       nscoord pageincrementMin = nscoord(float(scrollClampingScrollPort.height) * 0.8);</span>
<span class="lineNum">    5630 </span><span class="lineCov">         10 :       FinishReflowForScrollbar(vScroll, minY, maxY, scrollPos.y,</span>
<span class="lineNum">    5631 </span><span class="lineCov">          5 :                                std::max(pageincrement, pageincrementMin),</span>
<span class="lineNum">    5632 </span><span class="lineCov">          5 :                                increment);</span>
<span class="lineNum">    5633 </span>            :     }
<span class="lineNum">    5634 </span><span class="lineCov">          5 :     if (hScroll) {</span>
<span class="lineNum">    5635 </span>            :       const double kScrollMultiplier =
<span class="lineNum">    5636 </span><span class="lineCov">          5 :         Preferences::GetInt(&quot;toolkit.scrollbox.horizontalScrollDistance&quot;,</span>
<span class="lineNum">    5637 </span><span class="lineCov">          5 :                             NS_DEFAULT_HORIZONTAL_SCROLL_DISTANCE);</span>
<span class="lineNum">    5638 </span><span class="lineCov">          5 :       nscoord increment = lineScrollAmount.width * kScrollMultiplier;</span>
<span class="lineNum">    5639 </span><span class="lineNoCov">          0 :       FinishReflowForScrollbar(hScroll, minX, maxX, scrollPos.x,</span>
<span class="lineNum">    5640 </span><span class="lineCov">          5 :                                nscoord(float(scrollClampingScrollPort.width) * 0.8),</span>
<span class="lineNum">    5641 </span><span class="lineNoCov">          0 :                                increment);</span>
<span class="lineNum">    5642 </span>            :     }
<span class="lineNum">    5643 </span><span class="lineNoCov">          0 :     NS_ENSURE_TRUE(weakFrame.IsAlive(), false);</span>
<span class="lineNum">    5644 </span>            :   }
<span class="lineNum">    5645 </span>            : 
<span class="lineNum">    5646 </span><span class="lineCov">         51 :   mFrameIsUpdatingScrollbar = false;</span>
<span class="lineNum">    5647 </span>            :   // We used to rely on the curpos attribute changes above to scroll the
<span class="lineNum">    5648 </span>            :   // view.  However, for scrolling to the left of the viewport, we
<span class="lineNum">    5649 </span>            :   // rescale the curpos attribute, which means that operations like
<span class="lineNum">    5650 </span>            :   // resizing the window while it is scrolled all the way to the left
<span class="lineNum">    5651 </span>            :   // hold the curpos attribute constant at 0 while still requiring
<span class="lineNum">    5652 </span>            :   // scrolling.  So we suppress the effect of the changes above with
<span class="lineNum">    5653 </span>            :   // mFrameIsUpdatingScrollbar and call CurPosAttributeChanged here.
<span class="lineNum">    5654 </span>            :   // (It actually even works some of the time without this, thanks to
<span class="lineNum">    5655 </span>            :   // nsSliderFrame::AttributeChanged's handling of maxpos, but not when
<span class="lineNum">    5656 </span>            :   // we hide the scrollbar on a large size change, such as
<span class="lineNum">    5657 </span>            :   // maximization.)
<span class="lineNum">    5658 </span><span class="lineCov">         51 :   if (!mHScrollbarBox &amp;&amp; !mVScrollbarBox)</span>
<span class="lineNum">    5659 </span>            :     return false;
<span class="lineNum">    5660 </span><span class="lineCov">         10 :   CurPosAttributeChanged(mVScrollbarBox ? mVScrollbarBox-&gt;GetContent()-&gt;AsElement()</span>
<span class="lineNum">    5661 </span><span class="lineNoCov">          0 :                                         : mHScrollbarBox-&gt;GetContent()-&gt;AsElement(),</span>
<span class="lineNum">    5662 </span><span class="lineNoCov">          0 :                          doScroll);</span>
<span class="lineNum">    5663 </span><span class="lineNoCov">          0 :   return doScroll;</span>
<span class="lineNum">    5664 </span>            : }
<span class="lineNum">    5665 </span>            : 
<span class="lineNum">    5666 </span>            : void
<span class="lineNum">    5667 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ReflowCallbackCanceled()</span>
<span class="lineNum">    5668 </span>            : {
<span class="lineNum">    5669 </span><span class="lineNoCov">          0 :   mPostedReflowCallback = false;</span>
<span class="lineNum">    5670 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5671 </span>            : 
<span class="lineNum">    5672 </span>            : bool
<span class="lineNum">    5673 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ComputeCustomOverflow(nsOverflowAreas&amp; aOverflowAreas)</span>
<span class="lineNum">    5674 </span>            : {
<span class="lineNum">    5675 </span><span class="lineNoCov">          0 :   nsIScrollableFrame* sf = do_QueryFrame(mOuter);</span>
<span class="lineNum">    5676 </span><span class="lineNoCov">          0 :   ScrollbarStyles ss = sf-&gt;GetScrollbarStyles();</span>
<span class="lineNum">    5677 </span>            : 
<span class="lineNum">    5678 </span>            :   // Reflow when the change in overflow leads to one of our scrollbars
<span class="lineNum">    5679 </span>            :   // changing or might require repositioning the scrolled content due to
<span class="lineNum">    5680 </span>            :   // reduced extents.
<span class="lineNum">    5681 </span><span class="lineNoCov">          0 :   nsRect scrolledRect = GetScrolledRect();</span>
<span class="lineNum">    5682 </span><span class="lineNoCov">          0 :   uint32_t overflowChange = GetOverflowChange(scrolledRect, mPrevScrolledRect);</span>
<span class="lineNum">    5683 </span><span class="lineNoCov">          0 :   mPrevScrolledRect = scrolledRect;</span>
<span class="lineNum">    5684 </span>            : 
<span class="lineNum">    5685 </span><span class="lineNoCov">          0 :   bool needReflow = false;</span>
<span class="lineNum">    5686 </span><span class="lineNoCov">          0 :   nsPoint scrollPosition = GetScrollPosition();</span>
<span class="lineNum">    5687 </span><span class="lineNoCov">          0 :   if (overflowChange &amp; nsIScrollableFrame::HORIZONTAL) {</span>
<span class="lineNum">    5688 </span><span class="lineNoCov">          0 :     if (ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN || scrollPosition.x) {</span>
<span class="lineNum">    5689 </span><span class="lineNoCov">          0 :       needReflow = true;</span>
<span class="lineNum">    5690 </span>            :     }
<span class="lineNum">    5691 </span>            :   }
<span class="lineNum">    5692 </span><span class="lineNoCov">          0 :   if (overflowChange &amp; nsIScrollableFrame::VERTICAL) {</span>
<span class="lineNum">    5693 </span><span class="lineNoCov">          0 :     if (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN || scrollPosition.y) {</span>
<span class="lineNum">    5694 </span><span class="lineNoCov">          0 :       needReflow = true;</span>
<span class="lineNum">    5695 </span>            :     }
<span class="lineNum">    5696 </span>            :   }
<span class="lineNum">    5697 </span>            : 
<span class="lineNum">    5698 </span><span class="lineNoCov">          0 :   if (needReflow) {</span>
<span class="lineNum">    5699 </span>            :     // If there are scrollbars, or we're not at the beginning of the pane,
<span class="lineNum">    5700 </span>            :     // the scroll position may change. In this case, mark the frame as
<span class="lineNum">    5701 </span>            :     // needing reflow. Don't use NS_FRAME_IS_DIRTY as dirty as that means
<span class="lineNum">    5702 </span>            :     // we have to reflow the frame and all its descendants, and we don't
<span class="lineNum">    5703 </span>            :     // have to do that here. Only this frame needs to be reflowed.
<span class="lineNum">    5704 </span><span class="lineNoCov">          0 :     mOuter-&gt;PresShell()-&gt;FrameNeedsReflow(</span>
<span class="lineNum">    5705 </span><span class="lineNoCov">          0 :       mOuter, nsIPresShell::eResize, NS_FRAME_HAS_DIRTY_CHILDREN);</span>
<span class="lineNum">    5706 </span>            :     // Ensure that next time nsHTMLScrollFrame::Reflow runs, we don't skip
<span class="lineNum">    5707 </span>            :     // updating the scrollbars. (Because the overflow area of the scrolled
<span class="lineNum">    5708 </span>            :     // frame has probably just been updated, Reflow won't see it change.)
<span class="lineNum">    5709 </span><span class="lineNoCov">          0 :     mSkippedScrollbarLayout = true;</span>
<span class="lineNum">    5710 </span><span class="lineNoCov">          0 :     return false;  // reflowing will update overflow</span>
<span class="lineNum">    5711 </span>            :   }
<span class="lineNum">    5712 </span><span class="lineNoCov">          0 :   PostOverflowEvent();</span>
<span class="lineNum">    5713 </span><span class="lineNoCov">          0 :   return mOuter-&gt;nsContainerFrame::ComputeCustomOverflow(aOverflowAreas);</span>
<span class="lineNum">    5714 </span>            : }
<span class="lineNum">    5715 </span>            : 
<span class="lineNum">    5716 </span>            : void
<span class="lineNum">    5717 </span><span class="lineCov">         59 : ScrollFrameHelper::UpdateSticky()</span>
<span class="lineNum">    5718 </span>            : {
<span class="lineNum">    5719 </span>            :   StickyScrollContainer* ssc = StickyScrollContainer::
<span class="lineNum">    5720 </span><span class="lineNoCov">          0 :     GetStickyScrollContainerForScrollFrame(mOuter);</span>
<span class="lineNum">    5721 </span><span class="lineCov">         59 :   if (ssc) {</span>
<span class="lineNum">    5722 </span><span class="lineNoCov">          0 :     nsIScrollableFrame* scrollFrame = do_QueryFrame(mOuter);</span>
<span class="lineNum">    5723 </span><span class="lineNoCov">          0 :     ssc-&gt;UpdatePositions(scrollFrame-&gt;GetScrollPosition(), mOuter);</span>
<span class="lineNum">    5724 </span>            :   }
<span class="lineNum">    5725 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5726 </span>            : 
<span class="lineNum">    5727 </span>            : void
<span class="lineNum">    5728 </span><span class="lineCov">         59 : ScrollFrameHelper::UpdatePrevScrolledRect()</span>
<span class="lineNum">    5729 </span>            : {
<span class="lineNum">    5730 </span><span class="lineNoCov">          0 :   mPrevScrolledRect = GetScrolledRect();</span>
<span class="lineNum">    5731 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5732 </span>            : 
<span class="lineNum">    5733 </span>            : void
<span class="lineNum">    5734 </span><span class="lineNoCov">          0 : ScrollFrameHelper::AdjustScrollbarRectForResizer(</span>
<span class="lineNum">    5735 </span>            :                          nsIFrame* aFrame, nsPresContext* aPresContext,
<span class="lineNum">    5736 </span>            :                          nsRect&amp; aRect, bool aHasResizer, bool aVertical)
<span class="lineNum">    5737 </span>            : {
<span class="lineNum">    5738 </span><span class="lineCov">          1 :   if ((aVertical ? aRect.width : aRect.height) == 0) {</span>
<span class="lineNum">    5739 </span><span class="lineCov">         10 :     return;</span>
<span class="lineNum">    5740 </span>            :   }
<span class="lineNum">    5741 </span>            : 
<span class="lineNum">    5742 </span>            :   // if a content resizer is present, use its size. Otherwise, check if the
<span class="lineNum">    5743 </span>            :   // widget has a resizer.
<span class="lineNum">    5744 </span><span class="lineNoCov">          0 :   nsRect resizerRect;</span>
<span class="lineNum">    5745 </span><span class="lineNoCov">          0 :   if (aHasResizer) {</span>
<span class="lineNum">    5746 </span><span class="lineNoCov">          0 :     resizerRect = mResizerBox-&gt;GetRect();</span>
<span class="lineNum">    5747 </span>            :   }
<span class="lineNum">    5748 </span>            :   else {
<span class="lineNum">    5749 </span><span class="lineNoCov">          0 :     nsPoint offset;</span>
<span class="lineNum">    5750 </span><span class="lineNoCov">          0 :     nsIWidget* widget = aFrame-&gt;GetNearestWidget(offset);</span>
<span class="lineNum">    5751 </span><span class="lineNoCov">          0 :     LayoutDeviceIntRect widgetRect;</span>
<span class="lineNum">    5752 </span><span class="lineNoCov">          0 :     if (!widget || !widget-&gt;ShowsResizeIndicator(&amp;widgetRect)) {</span>
<span class="lineNum">    5753 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    5754 </span>            :     }
<span class="lineNum">    5755 </span>            : 
<span class="lineNum">    5756 </span><span class="lineNoCov">          0 :     resizerRect = nsRect(aPresContext-&gt;DevPixelsToAppUnits(widgetRect.x) - offset.x,</span>
<span class="lineNum">    5757 </span><span class="lineNoCov">          0 :                          aPresContext-&gt;DevPixelsToAppUnits(widgetRect.y) - offset.y,</span>
<span class="lineNum">    5758 </span>            :                          aPresContext-&gt;DevPixelsToAppUnits(widgetRect.width),
<span class="lineNum">    5759 </span>            :                          aPresContext-&gt;DevPixelsToAppUnits(widgetRect.height));
<span class="lineNum">    5760 </span>            :   }
<span class="lineNum">    5761 </span>            : 
<span class="lineNum">    5762 </span><span class="lineNoCov">          0 :   if (resizerRect.Contains(aRect.BottomRight() - nsPoint(1, 1))) {</span>
<span class="lineNum">    5763 </span><span class="lineNoCov">          0 :     if (aVertical) {</span>
<span class="lineNum">    5764 </span><span class="lineNoCov">          0 :       aRect.height = std::max(0, resizerRect.y - aRect.y);</span>
<span class="lineNum">    5765 </span>            :     } else {
<span class="lineNum">    5766 </span><span class="lineNoCov">          0 :       aRect.width = std::max(0, resizerRect.x - aRect.x);</span>
<span class="lineNum">    5767 </span>            :     }
<span class="lineNum">    5768 </span><span class="lineNoCov">          0 :   } else if (resizerRect.Contains(aRect.BottomLeft() + nsPoint(1, -1))) {</span>
<span class="lineNum">    5769 </span><span class="lineNoCov">          0 :     if (aVertical) {</span>
<span class="lineNum">    5770 </span><span class="lineNoCov">          0 :       aRect.height = std::max(0, resizerRect.y - aRect.y);</span>
<span class="lineNum">    5771 </span>            :     } else {
<span class="lineNum">    5772 </span><span class="lineNoCov">          0 :       nscoord xmost = aRect.XMost();</span>
<span class="lineNum">    5773 </span><span class="lineNoCov">          0 :       aRect.x = std::max(aRect.x, resizerRect.XMost());</span>
<span class="lineNum">    5774 </span><span class="lineNoCov">          0 :       aRect.width = xmost - aRect.x;</span>
<span class="lineNum">    5775 </span>            :     }
<span class="lineNum">    5776 </span>            :   }
<span class="lineNum">    5777 </span>            : }
<span class="lineNum">    5778 </span>            : 
<span class="lineNum">    5779 </span>            : static void
<span class="lineNum">    5780 </span><span class="lineCov">         53 : AdjustOverlappingScrollbars(nsRect&amp; aVRect, nsRect&amp; aHRect)</span>
<span class="lineNum">    5781 </span>            : {
<span class="lineNum">    5782 </span><span class="lineCov">        106 :   if (aVRect.IsEmpty() || aHRect.IsEmpty())</span>
<span class="lineNum">    5783 </span><span class="lineCov">         53 :     return;</span>
<span class="lineNum">    5784 </span>            : 
<span class="lineNum">    5785 </span><span class="lineNoCov">          0 :   const nsRect oldVRect = aVRect;</span>
<span class="lineNum">    5786 </span><span class="lineNoCov">          0 :   const nsRect oldHRect = aHRect;</span>
<span class="lineNum">    5787 </span><span class="lineNoCov">          0 :   if (oldVRect.Contains(oldHRect.BottomRight() - nsPoint(1, 1))) {</span>
<span class="lineNum">    5788 </span><span class="lineNoCov">          0 :     aHRect.width = std::max(0, oldVRect.x - oldHRect.x);</span>
<span class="lineNum">    5789 </span><span class="lineNoCov">          0 :   } else if (oldVRect.Contains(oldHRect.BottomLeft() - nsPoint(0, 1))) {</span>
<span class="lineNum">    5790 </span><span class="lineNoCov">          0 :     nscoord overlap = std::min(oldHRect.width, oldVRect.XMost() - oldHRect.x);</span>
<span class="lineNum">    5791 </span><span class="lineNoCov">          0 :     aHRect.x += overlap;</span>
<span class="lineNum">    5792 </span><span class="lineNoCov">          0 :     aHRect.width -= overlap;</span>
<span class="lineNum">    5793 </span>            :   }
<span class="lineNum">    5794 </span><span class="lineNoCov">          0 :   if (oldHRect.Contains(oldVRect.BottomRight() - nsPoint(1, 1))) {</span>
<span class="lineNum">    5795 </span><span class="lineNoCov">          0 :     aVRect.height = std::max(0, oldHRect.y - oldVRect.y);</span>
<span class="lineNum">    5796 </span>            :   }
<span class="lineNum">    5797 </span>            : }
<span class="lineNum">    5798 </span>            : 
<span class="lineNum">    5799 </span>            : void
<span class="lineNum">    5800 </span><span class="lineCov">          1 : ScrollFrameHelper::LayoutScrollbars(nsBoxLayoutState&amp; aState,</span>
<span class="lineNum">    5801 </span>            :                                         const nsRect&amp; aContentArea,
<span class="lineNum">    5802 </span>            :                                         const nsRect&amp; aOldScrollArea)
<span class="lineNum">    5803 </span>            : {
<span class="lineNum">    5804 </span><span class="lineNoCov">          0 :   NS_ASSERTION(!mSuppressScrollbarUpdate,</span>
<span class="lineNum">    5805 </span>            :                &quot;This should have been suppressed&quot;);
<span class="lineNum">    5806 </span>            : 
<span class="lineNum">    5807 </span><span class="lineNoCov">          0 :   nsIPresShell* presShell = mOuter-&gt;PresShell();</span>
<span class="lineNum">    5808 </span>            : 
<span class="lineNum">    5809 </span><span class="lineCov">         53 :   bool hasResizer = HasResizer();</span>
<span class="lineNum">    5810 </span><span class="lineNoCov">          0 :   bool scrollbarOnLeft = !IsScrollbarOnRight();</span>
<span class="lineNum">    5811 </span>            :   bool overlayScrollBarsWithZoom =
<span class="lineNum">    5812 </span><span class="lineNoCov">          0 :     mIsRoot &amp;&amp; LookAndFeel::GetInt(LookAndFeel::eIntID_UseOverlayScrollbars) &amp;&amp;</span>
<span class="lineNum">    5813 </span><span class="lineCov">         53 :     presShell-&gt;IsScrollPositionClampingScrollPortSizeSet();</span>
<span class="lineNum">    5814 </span>            : 
<span class="lineNum">    5815 </span><span class="lineNoCov">          0 :   nsSize scrollPortClampingSize = mScrollPort.Size();</span>
<span class="lineNum">    5816 </span><span class="lineNoCov">          0 :   double res = 1.0;</span>
<span class="lineNum">    5817 </span><span class="lineNoCov">          0 :   if (overlayScrollBarsWithZoom) {</span>
<span class="lineNum">    5818 </span><span class="lineNoCov">          0 :     scrollPortClampingSize = presShell-&gt;GetScrollPositionClampingScrollPortSize();</span>
<span class="lineNum">    5819 </span><span class="lineNoCov">          0 :     res = presShell-&gt;GetCumulativeResolution();</span>
<span class="lineNum">    5820 </span>            :   }
<span class="lineNum">    5821 </span>            : 
<span class="lineNum">    5822 </span>            :   // place the scrollcorner
<span class="lineNum">    5823 </span><span class="lineNoCov">          0 :   if (mScrollCornerBox || mResizerBox) {</span>
<span class="lineNum">    5824 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(!mScrollCornerBox || mScrollCornerBox-&gt;IsXULBoxFrame(), &quot;Must be a box frame!&quot;);</span>
<span class="lineNum">    5825 </span>            : 
<span class="lineNum">    5826 </span><span class="lineCov">         10 :     nsRect r(0, 0, 0, 0);</span>
<span class="lineNum">    5827 </span><span class="lineCov">          5 :     if (aContentArea.x != mScrollPort.x || scrollbarOnLeft) {</span>
<span class="lineNum">    5828 </span>            :       // scrollbar (if any) on left
<span class="lineNum">    5829 </span><span class="lineNoCov">          0 :       r.x = aContentArea.x;</span>
<span class="lineNum">    5830 </span><span class="lineNoCov">          0 :       r.width = mScrollPort.x - aContentArea.x;</span>
<span class="lineNum">    5831 </span><span class="lineNoCov">          0 :       NS_ASSERTION(r.width &gt;= 0, &quot;Scroll area should be inside client rect&quot;);</span>
<span class="lineNum">    5832 </span>            :     } else {
<span class="lineNum">    5833 </span>            :       // scrollbar (if any) on right
<span class="lineNum">    5834 </span><span class="lineNoCov">          0 :       r.width = aContentArea.XMost() - mScrollPort.XMost();</span>
<span class="lineNum">    5835 </span><span class="lineNoCov">          0 :       r.x = aContentArea.XMost() - r.width;</span>
<span class="lineNum">    5836 </span><span class="lineCov">          5 :       NS_ASSERTION(r.width &gt;= 0, &quot;Scroll area should be inside client rect&quot;);</span>
<span class="lineNum">    5837 </span>            :     }
<span class="lineNum">    5838 </span><span class="lineNoCov">          0 :     if (aContentArea.y != mScrollPort.y) {</span>
<span class="lineNum">    5839 </span><span class="lineNoCov">          0 :       NS_ERROR(&quot;top scrollbars not supported&quot;);</span>
<span class="lineNum">    5840 </span>            :     } else {
<span class="lineNum">    5841 </span>            :       // scrollbar (if any) on bottom
<span class="lineNum">    5842 </span><span class="lineCov">         15 :       r.height = aContentArea.YMost() - mScrollPort.YMost();</span>
<span class="lineNum">    5843 </span><span class="lineCov">          5 :       r.y = aContentArea.YMost() - r.height;</span>
<span class="lineNum">    5844 </span><span class="lineNoCov">          0 :       NS_ASSERTION(r.height &gt;= 0, &quot;Scroll area should be inside client rect&quot;);</span>
<span class="lineNum">    5845 </span>            :     }
<span class="lineNum">    5846 </span>            : 
<span class="lineNum">    5847 </span><span class="lineNoCov">          0 :     if (mScrollCornerBox) {</span>
<span class="lineNum">    5848 </span><span class="lineNoCov">          0 :       nsBoxFrame::LayoutChildAt(aState, mScrollCornerBox, r);</span>
<span class="lineNum">    5849 </span>            :     }
<span class="lineNum">    5850 </span>            : 
<span class="lineNum">    5851 </span><span class="lineNoCov">          0 :     if (hasResizer) {</span>
<span class="lineNum">    5852 </span>            :       // if a resizer is present, get its size. Assume a default size of 15 pixels.
<span class="lineNum">    5853 </span><span class="lineNoCov">          0 :       nscoord defaultSize = nsPresContext::CSSPixelsToAppUnits(15);</span>
<span class="lineNum">    5854 </span><span class="lineNoCov">          0 :       nsSize resizerMinSize = mResizerBox-&gt;GetXULMinSize(aState);</span>
<span class="lineNum">    5855 </span>            : 
<span class="lineNum">    5856 </span><span class="lineNoCov">          0 :       nscoord vScrollbarWidth = mVScrollbarBox ?</span>
<span class="lineNum">    5857 </span><span class="lineNoCov">          0 :         mVScrollbarBox-&gt;GetXULPrefSize(aState).width : defaultSize;</span>
<span class="lineNum">    5858 </span><span class="lineNoCov">          0 :       r.width = std::max(std::max(r.width, vScrollbarWidth), resizerMinSize.width);</span>
<span class="lineNum">    5859 </span><span class="lineNoCov">          0 :       if (aContentArea.x == mScrollPort.x &amp;&amp; !scrollbarOnLeft) {</span>
<span class="lineNum">    5860 </span><span class="lineNoCov">          0 :         r.x = aContentArea.XMost() - r.width;</span>
<span class="lineNum">    5861 </span>            :       }
<span class="lineNum">    5862 </span>            : 
<span class="lineNum">    5863 </span><span class="lineNoCov">          0 :       nscoord hScrollbarHeight = mHScrollbarBox ?</span>
<span class="lineNum">    5864 </span><span class="lineNoCov">          0 :         mHScrollbarBox-&gt;GetXULPrefSize(aState).height : defaultSize;</span>
<span class="lineNum">    5865 </span><span class="lineNoCov">          0 :       r.height = std::max(std::max(r.height, hScrollbarHeight), resizerMinSize.height);</span>
<span class="lineNum">    5866 </span><span class="lineNoCov">          0 :       if (aContentArea.y == mScrollPort.y) {</span>
<span class="lineNum">    5867 </span><span class="lineNoCov">          0 :         r.y = aContentArea.YMost() - r.height;</span>
<span class="lineNum">    5868 </span>            :       }
<span class="lineNum">    5869 </span>            : 
<span class="lineNum">    5870 </span><span class="lineNoCov">          0 :       nsBoxFrame::LayoutChildAt(aState, mResizerBox, r);</span>
<span class="lineNum">    5871 </span><span class="lineNoCov">          0 :     } else if (mResizerBox) {</span>
<span class="lineNum">    5872 </span>            :       // otherwise lay out the resizer with an empty rectangle
<span class="lineNum">    5873 </span><span class="lineNoCov">          0 :       nsBoxFrame::LayoutChildAt(aState, mResizerBox, nsRect());</span>
<span class="lineNum">    5874 </span>            :     }
<span class="lineNum">    5875 </span>            :   }
<span class="lineNum">    5876 </span>            : 
<span class="lineNum">    5877 </span><span class="lineNoCov">          0 :   nsPresContext* presContext = mScrolledFrame-&gt;PresContext();</span>
<span class="lineNum">    5878 </span><span class="lineNoCov">          0 :   nsRect vRect;</span>
<span class="lineNum">    5879 </span><span class="lineNoCov">          0 :   if (mVScrollbarBox) {</span>
<span class="lineNum">    5880 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mVScrollbarBox-&gt;IsXULBoxFrame(), &quot;Must be a box frame!&quot;);</span>
<span class="lineNum">    5881 </span><span class="lineCov">          1 :     vRect = mScrollPort;</span>
<span class="lineNum">    5882 </span><span class="lineCov">          5 :     if (overlayScrollBarsWithZoom) {</span>
<span class="lineNum">    5883 </span><span class="lineNoCov">          0 :       vRect.height = NSToCoordRound(res * scrollPortClampingSize.height);</span>
<span class="lineNum">    5884 </span>            :     }
<span class="lineNum">    5885 </span><span class="lineNoCov">          0 :     vRect.width = aContentArea.width - mScrollPort.width;</span>
<span class="lineNum">    5886 </span><span class="lineNoCov">          0 :     vRect.x = scrollbarOnLeft ? aContentArea.x : mScrollPort.x + NSToCoordRound(res * scrollPortClampingSize.width);</span>
<span class="lineNum">    5887 </span><span class="lineNoCov">          0 :     if (mHasVerticalScrollbar) {</span>
<span class="lineNum">    5888 </span><span class="lineNoCov">          0 :       nsMargin margin;</span>
<span class="lineNum">    5889 </span><span class="lineNoCov">          0 :       mVScrollbarBox-&gt;GetXULMargin(margin);</span>
<span class="lineNum">    5890 </span><span class="lineNoCov">          0 :       vRect.Deflate(margin);</span>
<span class="lineNum">    5891 </span>            :     }
<span class="lineNum">    5892 </span><span class="lineCov">          5 :     AdjustScrollbarRectForResizer(mOuter, presContext, vRect, hasResizer, true);</span>
<span class="lineNum">    5893 </span>            :   }
<span class="lineNum">    5894 </span>            : 
<span class="lineNum">    5895 </span><span class="lineCov">        106 :   nsRect hRect;</span>
<span class="lineNum">    5896 </span><span class="lineNoCov">          0 :   if (mHScrollbarBox) {</span>
<span class="lineNum">    5897 </span><span class="lineNoCov">          0 :     MOZ_ASSERT(mHScrollbarBox-&gt;IsXULBoxFrame(), &quot;Must be a box frame!&quot;);</span>
<span class="lineNum">    5898 </span><span class="lineCov">          5 :     hRect = mScrollPort;</span>
<span class="lineNum">    5899 </span><span class="lineNoCov">          0 :     if (overlayScrollBarsWithZoom) {</span>
<span class="lineNum">    5900 </span><span class="lineNoCov">          0 :       hRect.width = NSToCoordRound(res * scrollPortClampingSize.width);</span>
<span class="lineNum">    5901 </span>            :     }
<span class="lineNum">    5902 </span><span class="lineCov">          5 :     hRect.height = aContentArea.height - mScrollPort.height;</span>
<span class="lineNum">    5903 </span><span class="lineCov">          5 :     hRect.y = mScrollPort.y + NSToCoordRound(res * scrollPortClampingSize.height);</span>
<span class="lineNum">    5904 </span><span class="lineCov">          5 :     if (mHasHorizontalScrollbar) {</span>
<span class="lineNum">    5905 </span><span class="lineNoCov">          0 :       nsMargin margin;</span>
<span class="lineNum">    5906 </span><span class="lineNoCov">          0 :       mHScrollbarBox-&gt;GetXULMargin(margin);</span>
<span class="lineNum">    5907 </span><span class="lineNoCov">          0 :       hRect.Deflate(margin);</span>
<span class="lineNum">    5908 </span>            :     }
<span class="lineNum">    5909 </span><span class="lineNoCov">          0 :     AdjustScrollbarRectForResizer(mOuter, presContext, hRect, hasResizer, false);</span>
<span class="lineNum">    5910 </span>            :   }
<span class="lineNum">    5911 </span>            : 
<span class="lineNum">    5912 </span><span class="lineCov">         53 :   if (!LookAndFeel::GetInt(LookAndFeel::eIntID_AllowOverlayScrollbarsOverlap)) {</span>
<span class="lineNum">    5913 </span><span class="lineCov">         53 :     AdjustOverlappingScrollbars(vRect, hRect);</span>
<span class="lineNum">    5914 </span>            :   }
<span class="lineNum">    5915 </span><span class="lineNoCov">          0 :   if (mVScrollbarBox) {</span>
<span class="lineNum">    5916 </span><span class="lineNoCov">          0 :     nsBoxFrame::LayoutChildAt(aState, mVScrollbarBox, vRect);</span>
<span class="lineNum">    5917 </span>            :   }
<span class="lineNum">    5918 </span><span class="lineCov">         53 :   if (mHScrollbarBox) {</span>
<span class="lineNum">    5919 </span><span class="lineNoCov">          0 :     nsBoxFrame::LayoutChildAt(aState, mHScrollbarBox, hRect);</span>
<span class="lineNum">    5920 </span>            :   }
<span class="lineNum">    5921 </span>            : 
<span class="lineNum">    5922 </span>            :   // may need to update fixed position children of the viewport,
<span class="lineNum">    5923 </span>            :   // if the client area changed size because of an incremental
<span class="lineNum">    5924 </span>            :   // reflow of a descendant.  (If the outer frame is dirty, the fixed
<span class="lineNum">    5925 </span>            :   // children will be re-laid out anyway)
<span class="lineNum">    5926 </span><span class="lineCov">        241 :   if (aOldScrollArea.Size() != mScrollPort.Size() &amp;&amp;</span>
<span class="lineNum">    5927 </span><span class="lineCov">         99 :       !(mOuter-&gt;GetStateBits() &amp; NS_FRAME_IS_DIRTY) &amp;&amp;</span>
<span class="lineNum">    5928 </span><span class="lineCov">         17 :       mIsRoot) {</span>
<span class="lineNum">    5929 </span><span class="lineCov">         11 :     mMayHaveDirtyFixedChildren = true;</span>
<span class="lineNum">    5930 </span>            :   }
<span class="lineNum">    5931 </span>            : 
<span class="lineNum">    5932 </span>            :   // post reflow callback to modify scrollbar attributes
<span class="lineNum">    5933 </span><span class="lineNoCov">          0 :   mUpdateScrollbarAttributes = true;</span>
<span class="lineNum">    5934 </span><span class="lineNoCov">          0 :   if (!mPostedReflowCallback) {</span>
<span class="lineNum">    5935 </span><span class="lineNoCov">          0 :     aState.PresShell()-&gt;PostReflowCallback(this);</span>
<span class="lineNum">    5936 </span><span class="lineCov">         17 :     mPostedReflowCallback = true;</span>
<span class="lineNum">    5937 </span>            :   }
<span class="lineNum">    5938 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5939 </span>            : 
<span class="lineNum">    5940 </span>            : #if DEBUG
<span class="lineNum">    5941 </span><span class="lineNoCov">          0 : static bool ShellIsAlive(nsWeakPtr&amp; aWeakPtr)</span>
<span class="lineNum">    5942 </span>            : {
<span class="lineNum">    5943 </span><span class="lineCov">        150 :   nsCOMPtr&lt;nsIPresShell&gt; shell(do_QueryReferent(aWeakPtr));</span>
<span class="lineNum">    5944 </span><span class="lineNoCov">          0 :   return !!shell;</span>
<span class="lineNum">    5945 </span>            : }
<span class="lineNum">    5946 </span>            : #endif
<span class="lineNum">    5947 </span>            : 
<span class="lineNum">    5948 </span>            : void
<span class="lineNum">    5949 </span><span class="lineCov">         10 : ScrollFrameHelper::SetScrollbarEnabled(Element* aElement, nscoord aMaxPos)</span>
<span class="lineNum">    5950 </span>            : {
<span class="lineNum">    5951 </span>            :   DebugOnly&lt;nsWeakPtr&gt; weakShell(
<span class="lineNum">    5952 </span><span class="lineCov">         30 :     do_GetWeakReference(mOuter-&gt;PresShell()));</span>
<span class="lineNum">    5953 </span><span class="lineCov">         10 :   if (aMaxPos) {</span>
<span class="lineNum">    5954 </span><span class="lineNoCov">          0 :     aElement-&gt;UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, true);</span>
<span class="lineNum">    5955 </span>            :   } else {
<span class="lineNum">    5956 </span><span class="lineCov">         10 :     aElement-&gt;SetAttr(kNameSpaceID_None, nsGkAtoms::disabled,</span>
<span class="lineNum">    5957 </span><span class="lineNoCov">          0 :                       NS_LITERAL_STRING(&quot;true&quot;), true);</span>
<span class="lineNum">    5958 </span>            :   }
<span class="lineNum">    5959 </span><span class="lineCov">         10 :   MOZ_ASSERT(ShellIsAlive(weakShell), &quot;pres shell was destroyed by scrolling&quot;);</span>
<span class="lineNum">    5960 </span><span class="lineCov">         10 : }</span>
<span class="lineNum">    5961 </span>            : 
<span class="lineNum">    5962 </span>            : void
<span class="lineNum">    5963 </span><span class="lineNoCov">          0 : ScrollFrameHelper::SetCoordAttribute(Element* aElement, nsAtom* aAtom,</span>
<span class="lineNum">    5964 </span>            :                                      nscoord aSize)
<span class="lineNum">    5965 </span>            : {
<span class="lineNum">    5966 </span>            :   DebugOnly&lt;nsWeakPtr&gt; weakShell(
<span class="lineNum">    5967 </span><span class="lineCov">        120 :     do_GetWeakReference(mOuter-&gt;PresShell()));</span>
<span class="lineNum">    5968 </span>            :   // convert to pixels
<span class="lineNum">    5969 </span><span class="lineNoCov">          0 :   int32_t pixelSize = nsPresContext::AppUnitsToIntCSSPixels(aSize);</span>
<span class="lineNum">    5970 </span>            : 
<span class="lineNum">    5971 </span>            :   // only set the attribute if it changed.
<span class="lineNum">    5972 </span>            : 
<span class="lineNum">    5973 </span><span class="lineCov">         80 :   nsAutoString newValue;</span>
<span class="lineNum">    5974 </span><span class="lineCov">         40 :   newValue.AppendInt(pixelSize);</span>
<span class="lineNum">    5975 </span>            : 
<span class="lineNum">    5976 </span><span class="lineNoCov">          0 :   if (aElement-&gt;AttrValueIs(kNameSpaceID_None, aAtom, newValue, eCaseMatters)) {</span>
<span class="lineNum">    5977 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5978 </span>            :   }
<span class="lineNum">    5979 </span>            : 
<span class="lineNum">    5980 </span><span class="lineCov">         80 :   AutoWeakFrame weakFrame(mOuter);</span>
<span class="lineNum">    5981 </span><span class="lineNoCov">          0 :   RefPtr&lt;Element&gt; kungFuDeathGrip = aElement;</span>
<span class="lineNum">    5982 </span><span class="lineCov">         40 :   aElement-&gt;SetAttr(kNameSpaceID_None, aAtom, newValue, true);</span>
<span class="lineNum">    5983 </span><span class="lineCov">         40 :   MOZ_ASSERT(ShellIsAlive(weakShell), &quot;pres shell was destroyed by scrolling&quot;);</span>
<span class="lineNum">    5984 </span><span class="lineCov">         40 :   if (!weakFrame.IsAlive()) {</span>
<span class="lineNum">    5985 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5986 </span>            :   }
<span class="lineNum">    5987 </span>            : 
<span class="lineNum">    5988 </span><span class="lineNoCov">          0 :   if (mScrollbarActivity) {</span>
<span class="lineNum">    5989 </span><span class="lineNoCov">          0 :     RefPtr&lt;ScrollbarActivity&gt; scrollbarActivity(mScrollbarActivity);</span>
<span class="lineNum">    5990 </span><span class="lineNoCov">          0 :     scrollbarActivity-&gt;ActivityOccurred();</span>
<span class="lineNum">    5991 </span>            :   }
<span class="lineNum">    5992 </span>            : }
<span class="lineNum">    5993 </span>            : 
<span class="lineNum">    5994 </span>            : static void
<span class="lineNum">    5995 </span><span class="lineNoCov">          0 : ReduceRadii(nscoord aXBorder, nscoord aYBorder,</span>
<span class="lineNum">    5996 </span>            :             nscoord&amp; aXRadius, nscoord&amp; aYRadius)
<span class="lineNum">    5997 </span>            : {
<span class="lineNum">    5998 </span>            :   // In order to ensure that the inside edge of the border has no
<span class="lineNum">    5999 </span>            :   // curvature, we need at least one of its radii to be zero.
<span class="lineNum">    6000 </span><span class="lineNoCov">          0 :   if (aXRadius &lt;= aXBorder || aYRadius &lt;= aYBorder)</span>
<span class="lineNum">    6001 </span>            :     return;
<span class="lineNum">    6002 </span>            : 
<span class="lineNum">    6003 </span>            :   // For any corner where we reduce the radii, preserve the corner's shape.
<span class="lineNum">    6004 </span><span class="lineNoCov">          0 :   double ratio = std::max(double(aXBorder) / aXRadius,</span>
<span class="lineNum">    6005 </span><span class="lineNoCov">          0 :                         double(aYBorder) / aYRadius);</span>
<span class="lineNum">    6006 </span><span class="lineNoCov">          0 :   aXRadius *= ratio;</span>
<span class="lineNum">    6007 </span><span class="lineNoCov">          0 :   aYRadius *= ratio;</span>
<span class="lineNum">    6008 </span>            : }
<span class="lineNum">    6009 </span>            : 
<span class="lineNum">    6010 </span>            : /**
<span class="lineNum">    6011 </span>            :  * Implement an override for nsIFrame::GetBorderRadii to ensure that
<span class="lineNum">    6012 </span>            :  * the clipping region for the border radius does not clip the scrollbars.
<span class="lineNum">    6013 </span>            :  *
<span class="lineNum">    6014 </span>            :  * In other words, we require that the border radius be reduced until the
<span class="lineNum">    6015 </span>            :  * inner border radius at the inner edge of the border is 0 wherever we
<span class="lineNum">    6016 </span>            :  * have scrollbars.
<span class="lineNum">    6017 </span>            :  */
<span class="lineNum">    6018 </span>            : bool
<span class="lineNum">    6019 </span><span class="lineCov">          1 : ScrollFrameHelper::GetBorderRadii(const nsSize&amp; aFrameSize,</span>
<span class="lineNum">    6020 </span>            :                                   const nsSize&amp; aBorderArea,
<span class="lineNum">    6021 </span>            :                                   Sides aSkipSides,
<span class="lineNum">    6022 </span>            :                                   nscoord aRadii[8]) const
<span class="lineNum">    6023 </span>            : {
<span class="lineNum">    6024 </span><span class="lineNoCov">          0 :   if (!mOuter-&gt;nsContainerFrame::GetBorderRadii(aFrameSize, aBorderArea,</span>
<span class="lineNum">    6025 </span>            :                                                 aSkipSides, aRadii)) {
<span class="lineNum">    6026 </span>            :     return false;
<span class="lineNum">    6027 </span>            :   }
<span class="lineNum">    6028 </span>            : 
<span class="lineNum">    6029 </span>            :   // Since we can use GetActualScrollbarSizes (rather than
<span class="lineNum">    6030 </span>            :   // GetDesiredScrollbarSizes) since this doesn't affect reflow, we
<span class="lineNum">    6031 </span>            :   // probably should.
<span class="lineNum">    6032 </span><span class="lineNoCov">          0 :   nsMargin sb = GetActualScrollbarSizes();</span>
<span class="lineNum">    6033 </span><span class="lineNoCov">          0 :   nsMargin border = mOuter-&gt;GetUsedBorder();</span>
<span class="lineNum">    6034 </span>            : 
<span class="lineNum">    6035 </span><span class="lineNoCov">          0 :   if (sb.left &gt; 0 || sb.top &gt; 0) {</span>
<span class="lineNum">    6036 </span><span class="lineNoCov">          0 :     ReduceRadii(border.left, border.top,</span>
<span class="lineNum">    6037 </span>            :                 aRadii[eCornerTopLeftX],
<span class="lineNum">    6038 </span><span class="lineNoCov">          0 :                 aRadii[eCornerTopLeftY]);</span>
<span class="lineNum">    6039 </span>            :   }
<span class="lineNum">    6040 </span>            : 
<span class="lineNum">    6041 </span><span class="lineNoCov">          0 :   if (sb.top &gt; 0 || sb.right &gt; 0) {</span>
<span class="lineNum">    6042 </span><span class="lineNoCov">          0 :     ReduceRadii(border.right, border.top,</span>
<span class="lineNum">    6043 </span><span class="lineNoCov">          0 :                 aRadii[eCornerTopRightX],</span>
<span class="lineNum">    6044 </span><span class="lineNoCov">          0 :                 aRadii[eCornerTopRightY]);</span>
<span class="lineNum">    6045 </span>            :   }
<span class="lineNum">    6046 </span>            : 
<span class="lineNum">    6047 </span><span class="lineNoCov">          0 :   if (sb.right &gt; 0 || sb.bottom &gt; 0) {</span>
<span class="lineNum">    6048 </span><span class="lineNoCov">          0 :     ReduceRadii(border.right, border.bottom,</span>
<span class="lineNum">    6049 </span><span class="lineNoCov">          0 :                 aRadii[eCornerBottomRightX],</span>
<span class="lineNum">    6050 </span><span class="lineNoCov">          0 :                 aRadii[eCornerBottomRightY]);</span>
<span class="lineNum">    6051 </span>            :   }
<span class="lineNum">    6052 </span>            : 
<span class="lineNum">    6053 </span><span class="lineNoCov">          0 :   if (sb.bottom &gt; 0 || sb.left &gt; 0) {</span>
<span class="lineNum">    6054 </span><span class="lineNoCov">          0 :     ReduceRadii(border.left, border.bottom,</span>
<span class="lineNum">    6055 </span><span class="lineNoCov">          0 :                 aRadii[eCornerBottomLeftX],</span>
<span class="lineNum">    6056 </span><span class="lineNoCov">          0 :                 aRadii[eCornerBottomLeftY]);</span>
<span class="lineNum">    6057 </span>            :   }
<span class="lineNum">    6058 </span>            : 
<span class="lineNum">    6059 </span>            :   return true;
<span class="lineNum">    6060 </span>            : }
<span class="lineNum">    6061 </span>            : 
<span class="lineNum">    6062 </span>            : static nscoord
<span class="lineNum">    6063 </span><span class="lineCov">        228 : SnapCoord(nscoord aCoord, double aRes, nscoord aAppUnitsPerPixel)</span>
<span class="lineNum">    6064 </span>            : {
<span class="lineNum">    6065 </span><span class="lineCov">        228 :   double snappedToLayerPixels = NS_round((aRes*aCoord)/aAppUnitsPerPixel);</span>
<span class="lineNum">    6066 </span><span class="lineCov">        228 :   return NSToCoordRoundWithClamp(snappedToLayerPixels*aAppUnitsPerPixel/aRes);</span>
<span class="lineNum">    6067 </span>            : }
<span class="lineNum">    6068 </span>            : 
<span class="lineNum">    6069 </span>            : nsRect
<span class="lineNum">    6070 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetScrolledRect() const</span>
<span class="lineNum">    6071 </span>            : {
<span class="lineNum">    6072 </span>            :   nsRect result =
<span class="lineNum">    6073 </span><span class="lineCov">        832 :     GetUnsnappedScrolledRectInternal(mScrolledFrame-&gt;GetScrollableOverflowRect(),</span>
<span class="lineNum">    6074 </span><span class="lineCov">       1664 :                                      mScrollPort.Size());</span>
<span class="lineNum">    6075 </span>            : 
<span class="lineNum">    6076 </span><span class="lineCov">        416 :   if (result.width &lt; mScrollPort.width) {</span>
<span class="lineNum">    6077 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;Scrolled rect smaller than scrollport?&quot;);</span>
<span class="lineNum">    6078 </span>            :   }
<span class="lineNum">    6079 </span><span class="lineNoCov">          0 :   if (result.height &lt; mScrollPort.height) {</span>
<span class="lineNum">    6080 </span><span class="lineNoCov">          0 :     NS_WARNING(&quot;Scrolled rect smaller than scrollport?&quot;);</span>
<span class="lineNum">    6081 </span>            :   }
<span class="lineNum">    6082 </span>            : 
<span class="lineNum">    6083 </span>            :   // Expand / contract the result by up to half a layer pixel so that scrolling
<span class="lineNum">    6084 </span>            :   // to the right / bottom edge does not change the layer pixel alignment of
<span class="lineNum">    6085 </span>            :   // the scrolled contents.
<span class="lineNum">    6086 </span>            : 
<span class="lineNum">    6087 </span><span class="lineCov">        832 :   if (result.x == 0 &amp;&amp; result.y == 0 &amp;&amp;</span>
<span class="lineNum">    6088 </span><span class="lineCov">        801 :       result.width == mScrollPort.width &amp;&amp;</span>
<span class="lineNum">    6089 </span><span class="lineCov">        385 :       result.height == mScrollPort.height) {</span>
<span class="lineNum">    6090 </span>            :     // The edges that we would snap are already aligned with the scroll port,
<span class="lineNum">    6091 </span>            :     // so we can skip all the work below.
<span class="lineNum">    6092 </span>            :     return result;
<span class="lineNum">    6093 </span>            :   }
<span class="lineNum">    6094 </span>            : 
<span class="lineNum">    6095 </span>            :   // For that, we first convert the scroll port and the scrolled rect to rects
<span class="lineNum">    6096 </span>            :   // relative to the reference frame, since that's the space where painting does
<span class="lineNum">    6097 </span>            :   // snapping.
<span class="lineNum">    6098 </span><span class="lineCov">         57 :   nsSize scrollPortSize = GetScrollPositionClampingScrollPortSize();</span>
<span class="lineNum">    6099 </span>            :   const nsIFrame* referenceFrame =
<span class="lineNum">    6100 </span><span class="lineNoCov">          0 :     mReferenceFrameDuringPainting ? mReferenceFrameDuringPainting : nsLayoutUtils::GetReferenceFrame(mOuter);</span>
<span class="lineNum">    6101 </span><span class="lineNoCov">          0 :   nsPoint toReferenceFrame = mOuter-&gt;GetOffsetToCrossDoc(referenceFrame);</span>
<span class="lineNum">    6102 </span><span class="lineNoCov">          0 :   nsRect scrollPort(mScrollPort.TopLeft() + toReferenceFrame, scrollPortSize);</span>
<span class="lineNum">    6103 </span><span class="lineNoCov">          0 :   nsRect scrolledRect = result + scrollPort.TopLeft();</span>
<span class="lineNum">    6104 </span>            : 
<span class="lineNum">    6105 </span><span class="lineNoCov">          0 :   if (scrollPort.Overflows() || scrolledRect.Overflows()) {</span>
<span class="lineNum">    6106 </span>            :     return result;
<span class="lineNum">    6107 </span>            :   }
<span class="lineNum">    6108 </span>            : 
<span class="lineNum">    6109 </span>            :   // Now, snap the bottom right corner of both of these rects.
<span class="lineNum">    6110 </span>            :   // We snap to layer pixels, so we need to respect the layer's scale.
<span class="lineNum">    6111 </span><span class="lineCov">        114 :   nscoord appUnitsPerDevPixel = mScrolledFrame-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    6112 </span><span class="lineCov">         57 :   gfxSize scale = FrameLayerBuilder::GetPaintedLayerScaleForFrame(mScrolledFrame);</span>
<span class="lineNum">    6113 </span><span class="lineCov">         57 :   if (scale.IsEmpty()) {</span>
<span class="lineNum">    6114 </span><span class="lineNoCov">          0 :     scale = gfxSize(1.0f, 1.0f);</span>
<span class="lineNum">    6115 </span>            :   }
<span class="lineNum">    6116 </span>            : 
<span class="lineNum">    6117 </span>            :   // Compute bounds for the scroll position, and computed the snapped scrolled
<span class="lineNum">    6118 </span>            :   // rect from the scroll position bounds.
<span class="lineNum">    6119 </span><span class="lineCov">        114 :   nscoord snappedScrolledAreaBottom = SnapCoord(scrolledRect.YMost(), scale.height, appUnitsPerDevPixel);</span>
<span class="lineNum">    6120 </span><span class="lineCov">        114 :   nscoord snappedScrollPortBottom = SnapCoord(scrollPort.YMost(), scale.height, appUnitsPerDevPixel);</span>
<span class="lineNum">    6121 </span><span class="lineCov">         57 :   nscoord maximumScrollOffsetY = snappedScrolledAreaBottom - snappedScrollPortBottom;</span>
<span class="lineNum">    6122 </span><span class="lineCov">        114 :   result.SetBottomEdge(scrollPort.height + maximumScrollOffsetY);</span>
<span class="lineNum">    6123 </span>            : 
<span class="lineNum">    6124 </span><span class="lineCov">         57 :   if (GetScrolledFrameDir() == NS_STYLE_DIRECTION_LTR) {</span>
<span class="lineNum">    6125 </span><span class="lineCov">        114 :     nscoord snappedScrolledAreaRight = SnapCoord(scrolledRect.XMost(), scale.width, appUnitsPerDevPixel);</span>
<span class="lineNum">    6126 </span><span class="lineNoCov">          0 :     nscoord snappedScrollPortRight = SnapCoord(scrollPort.XMost(), scale.width, appUnitsPerDevPixel);</span>
<span class="lineNum">    6127 </span><span class="lineCov">         57 :     nscoord maximumScrollOffsetX = snappedScrolledAreaRight - snappedScrollPortRight;</span>
<span class="lineNum">    6128 </span><span class="lineCov">         57 :     result.SetRightEdge(scrollPort.width + maximumScrollOffsetX);</span>
<span class="lineNum">    6129 </span>            :   } else {
<span class="lineNum">    6130 </span>            :     // In RTL, the scrolled area's right edge is at scrollPort.XMost(),
<span class="lineNum">    6131 </span>            :     // and the scrolled area's x position is zero or negative. We want
<span class="lineNum">    6132 </span>            :     // the right edge to stay flush with the scroll port, so we snap the
<span class="lineNum">    6133 </span>            :     // left edge.
<span class="lineNum">    6134 </span><span class="lineNoCov">          0 :     nscoord snappedScrolledAreaLeft = SnapCoord(scrolledRect.x, scale.width, appUnitsPerDevPixel);</span>
<span class="lineNum">    6135 </span><span class="lineNoCov">          0 :     nscoord snappedScrollPortLeft = SnapCoord(scrollPort.x, scale.width, appUnitsPerDevPixel);</span>
<span class="lineNum">    6136 </span><span class="lineNoCov">          0 :     nscoord minimumScrollOffsetX = snappedScrolledAreaLeft - snappedScrollPortLeft;</span>
<span class="lineNum">    6137 </span><span class="lineNoCov">          0 :     result.SetLeftEdge(minimumScrollOffsetX);</span>
<span class="lineNum">    6138 </span>            :   }
<span class="lineNum">    6139 </span>            : 
<span class="lineNum">    6140 </span>            :   return result;
<span class="lineNum">    6141 </span>            : }
<span class="lineNum">    6142 </span>            : 
<span class="lineNum">    6143 </span>            : 
<span class="lineNum">    6144 </span>            : uint8_t
<span class="lineNum">    6145 </span><span class="lineCov">        627 : ScrollFrameHelper::GetScrolledFrameDir() const</span>
<span class="lineNum">    6146 </span>            : {
<span class="lineNum">    6147 </span>            :   // If the scrolled frame has unicode-bidi: plaintext, the paragraph
<span class="lineNum">    6148 </span>            :   // direction set by the text content overrides the direction of the frame
<span class="lineNum">    6149 </span><span class="lineCov">        627 :   if (mScrolledFrame-&gt;StyleTextReset()-&gt;mUnicodeBidi &amp;</span>
<span class="lineNum">    6150 </span>            :       NS_STYLE_UNICODE_BIDI_PLAINTEXT) {
<span class="lineNum">    6151 </span><span class="lineNoCov">          0 :     nsIFrame* childFrame = mScrolledFrame-&gt;PrincipalChildList().FirstChild();</span>
<span class="lineNum">    6152 </span><span class="lineNoCov">          0 :     if (childFrame) {</span>
<span class="lineNum">    6153 </span><span class="lineNoCov">          0 :       return (nsBidiPresUtils::ParagraphDirection(childFrame) == NSBIDI_LTR)</span>
<span class="lineNum">    6154 </span><span class="lineNoCov">          0 :              ? NS_STYLE_DIRECTION_LTR : NS_STYLE_DIRECTION_RTL;</span>
<span class="lineNum">    6155 </span>            :     }
<span class="lineNum">    6156 </span>            :   }
<span class="lineNum">    6157 </span>            : 
<span class="lineNum">    6158 </span><span class="lineNoCov">          0 :   return IsBidiLTR() ? NS_STYLE_DIRECTION_LTR : NS_STYLE_DIRECTION_RTL;</span>
<span class="lineNum">    6159 </span>            : }
<span class="lineNum">    6160 </span>            : 
<span class="lineNum">    6161 </span>            : nsRect
<span class="lineNum">    6162 </span><span class="lineCov">        570 : ScrollFrameHelper::GetUnsnappedScrolledRectInternal(const nsRect&amp; aScrolledFrameOverflowArea,</span>
<span class="lineNum">    6163 </span>            :                                                     const nsSize&amp; aScrollPortSize) const
<span class="lineNum">    6164 </span>            : {
<span class="lineNum">    6165 </span><span class="lineNoCov">          0 :   return nsLayoutUtils::GetScrolledRect(mScrolledFrame,</span>
<span class="lineNum">    6166 </span>            :                                         aScrolledFrameOverflowArea,
<span class="lineNum">    6167 </span><span class="lineCov">       1140 :                                         aScrollPortSize, GetScrolledFrameDir());</span>
<span class="lineNum">    6168 </span>            : }
<span class="lineNum">    6169 </span>            : 
<span class="lineNum">    6170 </span>            : nsMargin
<span class="lineNum">    6171 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetActualScrollbarSizes() const</span>
<span class="lineNum">    6172 </span>            : {
<span class="lineNum">    6173 </span><span class="lineNoCov">          0 :   nsRect r = mOuter-&gt;GetPaddingRect() - mOuter-&gt;GetPosition();</span>
<span class="lineNum">    6174 </span>            : 
<span class="lineNum">    6175 </span>            :   return nsMargin(mScrollPort.y - r.y,
<span class="lineNum">    6176 </span><span class="lineNoCov">          0 :                   r.XMost() - mScrollPort.XMost(),</span>
<span class="lineNum">    6177 </span><span class="lineNoCov">          0 :                   r.YMost() - mScrollPort.YMost(),</span>
<span class="lineNum">    6178 </span><span class="lineNoCov">          0 :                   mScrollPort.x - r.x);</span>
<span class="lineNum">    6179 </span>            : }
<span class="lineNum">    6180 </span>            : 
<span class="lineNum">    6181 </span>            : void
<span class="lineNum">    6182 </span><span class="lineNoCov">          0 : ScrollFrameHelper::SetScrollbarVisibility(nsIFrame* aScrollbar, bool aVisible)</span>
<span class="lineNum">    6183 </span>            : {
<span class="lineNum">    6184 </span><span class="lineCov">         72 :   nsScrollbarFrame* scrollbar = do_QueryFrame(aScrollbar);</span>
<span class="lineNum">    6185 </span><span class="lineNoCov">          0 :   if (scrollbar) {</span>
<span class="lineNum">    6186 </span>            :     // See if we have a mediator.
<span class="lineNum">    6187 </span><span class="lineNoCov">          0 :     nsIScrollbarMediator* mediator = scrollbar-&gt;GetScrollbarMediator();</span>
<span class="lineNum">    6188 </span><span class="lineCov">         10 :     if (mediator) {</span>
<span class="lineNum">    6189 </span>            :       // Inform the mediator of the visibility change.
<span class="lineNum">    6190 </span><span class="lineCov">         10 :       mediator-&gt;VisibilityChanged(aVisible);</span>
<span class="lineNum">    6191 </span>            :     }
<span class="lineNum">    6192 </span>            :   }
<span class="lineNum">    6193 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6194 </span>            : 
<span class="lineNum">    6195 </span>            : nscoord
<span class="lineNum">    6196 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetCoordAttribute(nsIFrame* aBox, nsAtom* aAtom,</span>
<span class="lineNum">    6197 </span>            :                                          nscoord aDefaultValue,
<span class="lineNum">    6198 </span>            :                                          nscoord* aRangeStart,
<span class="lineNum">    6199 </span>            :                                          nscoord* aRangeLength)
<span class="lineNum">    6200 </span>            : {
<span class="lineNum">    6201 </span><span class="lineCov">         10 :   if (aBox) {</span>
<span class="lineNum">    6202 </span><span class="lineCov">         10 :     nsIContent* content = aBox-&gt;GetContent();</span>
<span class="lineNum">    6203 </span>            : 
<span class="lineNum">    6204 </span><span class="lineNoCov">          0 :     nsAutoString value;</span>
<span class="lineNum">    6205 </span><span class="lineNoCov">          0 :     if (content-&gt;IsElement()) {</span>
<span class="lineNum">    6206 </span><span class="lineCov">         10 :       content-&gt;AsElement()-&gt;GetAttr(kNameSpaceID_None, aAtom, value);</span>
<span class="lineNum">    6207 </span>            :     }
<span class="lineNum">    6208 </span><span class="lineCov">         10 :     if (!value.IsEmpty()) {</span>
<span class="lineNum">    6209 </span>            :       nsresult error;
<span class="lineNum">    6210 </span>            :       // convert it to appunits
<span class="lineNum">    6211 </span><span class="lineNoCov">          0 :       nscoord result = nsPresContext::CSSPixelsToAppUnits(value.ToInteger(&amp;error));</span>
<span class="lineNum">    6212 </span><span class="lineNoCov">          0 :       nscoord halfPixel = nsPresContext::CSSPixelsToAppUnits(0.5f);</span>
<span class="lineNum">    6213 </span>            :       // Any nscoord value that would round to the attribute value when converted
<span class="lineNum">    6214 </span>            :       // to CSS pixels is allowed.
<span class="lineNum">    6215 </span><span class="lineCov">         10 :       *aRangeStart = result - halfPixel;</span>
<span class="lineNum">    6216 </span><span class="lineCov">         10 :       *aRangeLength = halfPixel*2 - 1;</span>
<span class="lineNum">    6217 </span>            :       return result;
<span class="lineNum">    6218 </span>            :     }
<span class="lineNum">    6219 </span>            :   }
<span class="lineNum">    6220 </span>            : 
<span class="lineNum">    6221 </span>            :   // Only this exact default value is allowed.
<span class="lineNum">    6222 </span><span class="lineNoCov">          0 :   *aRangeStart = aDefaultValue;</span>
<span class="lineNum">    6223 </span><span class="lineNoCov">          0 :   *aRangeLength = 0;</span>
<span class="lineNum">    6224 </span><span class="lineNoCov">          0 :   return aDefaultValue;</span>
<span class="lineNum">    6225 </span>            : }
<span class="lineNum">    6226 </span>            : 
<span class="lineNum">    6227 </span>            : UniquePtr&lt;PresState&gt;
<span class="lineNum">    6228 </span><span class="lineCov">          7 : ScrollFrameHelper::SaveState() const</span>
<span class="lineNum">    6229 </span>            : {
<span class="lineNum">    6230 </span><span class="lineCov">         14 :   nsIScrollbarMediator* mediator = do_QueryFrame(GetScrolledFrame());</span>
<span class="lineNum">    6231 </span><span class="lineCov">          7 :   if (mediator) {</span>
<span class="lineNum">    6232 </span>            :     // child handles its own scroll state, so don't bother saving state here
<span class="lineNum">    6233 </span>            :     return nullptr;
<span class="lineNum">    6234 </span>            :   }
<span class="lineNum">    6235 </span>            : 
<span class="lineNum">    6236 </span>            :   // Don't store a scroll state if we never have been scrolled or restored
<span class="lineNum">    6237 </span>            :   // a previous scroll state, and we're not in the middle of a smooth scroll.
<span class="lineNum">    6238 </span><span class="lineNoCov">          0 :   bool isInSmoothScroll = IsProcessingAsyncScroll() || mLastSmoothScrollOrigin;</span>
<span class="lineNum">    6239 </span><span class="lineNoCov">          0 :   if (!mHasBeenScrolled &amp;&amp; !mDidHistoryRestore &amp;&amp; !isInSmoothScroll) {</span>
<span class="lineNum">    6240 </span>            :     return nullptr;
<span class="lineNum">    6241 </span>            :   }
<span class="lineNum">    6242 </span>            : 
<span class="lineNum">    6243 </span><span class="lineNoCov">          0 :   UniquePtr&lt;PresState&gt; state = NewPresState();</span>
<span class="lineNum">    6244 </span>            :   bool allowScrollOriginDowngrade =
<span class="lineNum">    6245 </span><span class="lineNoCov">          0 :     !nsLayoutUtils::CanScrollOriginClobberApz(mLastScrollOrigin) ||</span>
<span class="lineNum">    6246 </span><span class="lineNoCov">          0 :     mAllowScrollOriginDowngrade;</span>
<span class="lineNum">    6247 </span>            :   // Save mRestorePos instead of our actual current scroll position, if it's
<span class="lineNum">    6248 </span>            :   // valid and we haven't moved since the last update of mLastPos (same check
<span class="lineNum">    6249 </span>            :   // that ScrollToRestoredPosition uses). This ensures if a reframe occurs
<span class="lineNum">    6250 </span>            :   // while we're in the process of loading content to scroll to a restored
<span class="lineNum">    6251 </span>            :   // position, we'll keep trying after the reframe. Similarly, if we're in the
<span class="lineNum">    6252 </span>            :   // middle of a smooth scroll, store the destination so that when we restore
<span class="lineNum">    6253 </span>            :   // we'll jump straight to the end of the scroll animation, rather than
<span class="lineNum">    6254 </span>            :   // effectively dropping it. Note that the mRestorePos will override the
<span class="lineNum">    6255 </span>            :   // smooth scroll destination if both are present.
<span class="lineNum">    6256 </span><span class="lineNoCov">          0 :   nsPoint pt = GetLogicalScrollPosition();</span>
<span class="lineNum">    6257 </span><span class="lineNoCov">          0 :   if (isInSmoothScroll) {</span>
<span class="lineNum">    6258 </span><span class="lineNoCov">          0 :     pt = mDestination;</span>
<span class="lineNum">    6259 </span><span class="lineNoCov">          0 :     allowScrollOriginDowngrade = false;</span>
<span class="lineNum">    6260 </span>            :   }
<span class="lineNum">    6261 </span><span class="lineNoCov">          0 :   if (mRestorePos.y != -1 &amp;&amp; pt == mLastPos) {</span>
<span class="lineNum">    6262 </span><span class="lineNoCov">          0 :     pt = mRestorePos;</span>
<span class="lineNum">    6263 </span>            :   }
<span class="lineNum">    6264 </span><span class="lineNoCov">          0 :   state-&gt;scrollState() = pt;</span>
<span class="lineNum">    6265 </span><span class="lineNoCov">          0 :   state-&gt;allowScrollOriginDowngrade() = allowScrollOriginDowngrade;</span>
<span class="lineNum">    6266 </span><span class="lineNoCov">          0 :   if (mIsRoot) {</span>
<span class="lineNum">    6267 </span>            :     // Only save resolution properties for root scroll frames
<span class="lineNum">    6268 </span><span class="lineNoCov">          0 :     nsIPresShell* shell = mOuter-&gt;PresShell();</span>
<span class="lineNum">    6269 </span><span class="lineNoCov">          0 :     state-&gt;resolution() = shell-&gt;GetResolution();</span>
<span class="lineNum">    6270 </span><span class="lineNoCov">          0 :     state-&gt;scaleToResolution() = shell-&gt;ScaleToResolution();</span>
<span class="lineNum">    6271 </span>            :   }
<span class="lineNum">    6272 </span><span class="lineNoCov">          0 :   return state;</span>
<span class="lineNum">    6273 </span>            : }
<span class="lineNum">    6274 </span>            : 
<span class="lineNum">    6275 </span>            : void
<span class="lineNum">    6276 </span><span class="lineNoCov">          0 : ScrollFrameHelper::RestoreState(PresState* aState)</span>
<span class="lineNum">    6277 </span>            : {
<span class="lineNum">    6278 </span><span class="lineNoCov">          0 :   mRestorePos = aState-&gt;scrollState();</span>
<span class="lineNum">    6279 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mLastScrollOrigin == nsGkAtoms::other);</span>
<span class="lineNum">    6280 </span><span class="lineNoCov">          0 :   mAllowScrollOriginDowngrade = aState-&gt;allowScrollOriginDowngrade();</span>
<span class="lineNum">    6281 </span><span class="lineNoCov">          0 :   mDidHistoryRestore = true;</span>
<span class="lineNum">    6282 </span><span class="lineNoCov">          0 :   mLastPos = mScrolledFrame ? GetLogicalScrollPosition() : nsPoint(0,0);</span>
<span class="lineNum">    6283 </span>            : 
<span class="lineNum">    6284 </span>            :   // Resolution properties should only exist on root scroll frames.
<span class="lineNum">    6285 </span><span class="lineNoCov">          0 :   MOZ_ASSERT(mIsRoot || (!aState-&gt;scaleToResolution() &amp;&amp;</span>
<span class="lineNum">    6286 </span>            :                          aState-&gt;resolution() == 1.0));
<span class="lineNum">    6287 </span>            : 
<span class="lineNum">    6288 </span><span class="lineNoCov">          0 :   if (mIsRoot) {</span>
<span class="lineNum">    6289 </span><span class="lineNoCov">          0 :     nsIPresShell* presShell = mOuter-&gt;PresShell();</span>
<span class="lineNum">    6290 </span><span class="lineNoCov">          0 :     if (aState-&gt;scaleToResolution()) {</span>
<span class="lineNum">    6291 </span><span class="lineNoCov">          0 :       presShell-&gt;SetResolutionAndScaleTo(aState-&gt;resolution());</span>
<span class="lineNum">    6292 </span>            :     } else {
<span class="lineNum">    6293 </span><span class="lineNoCov">          0 :       presShell-&gt;SetResolution(aState-&gt;resolution());</span>
<span class="lineNum">    6294 </span>            :     }
<span class="lineNum">    6295 </span>            :   }
<span class="lineNum">    6296 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6297 </span>            : 
<span class="lineNum">    6298 </span>            : void
<span class="lineNum">    6299 </span><span class="lineCov">         12 : ScrollFrameHelper::PostScrolledAreaEvent()</span>
<span class="lineNum">    6300 </span>            : {
<span class="lineNum">    6301 </span><span class="lineCov">         24 :   if (mScrolledAreaEvent.IsPending()) {</span>
<span class="lineNum">    6302 </span>            :     return;
<span class="lineNum">    6303 </span>            :   }
<span class="lineNum">    6304 </span><span class="lineNoCov">          0 :   mScrolledAreaEvent = new ScrolledAreaEvent(this);</span>
<span class="lineNum">    6305 </span><span class="lineCov">         24 :   nsContentUtils::AddScriptRunner(mScrolledAreaEvent.get());</span>
<span class="lineNum">    6306 </span>            : }
<span class="lineNum">    6307 </span>            : 
<span class="lineNum">    6308 </span>            : ////////////////////////////////////////////////////////////////////////////////
<span class="lineNum">    6309 </span>            : // ScrolledArea change event dispatch
<span class="lineNum">    6310 </span>            : 
<span class="lineNum">    6311 </span>            : NS_IMETHODIMP
<span class="lineNum">    6312 </span><span class="lineNoCov">          0 : ScrollFrameHelper::ScrolledAreaEvent::Run()</span>
<span class="lineNum">    6313 </span>            : {
<span class="lineNum">    6314 </span><span class="lineNoCov">          0 :   if (mHelper) {</span>
<span class="lineNum">    6315 </span><span class="lineCov">         12 :     mHelper-&gt;FireScrolledAreaEvent();</span>
<span class="lineNum">    6316 </span>            :   }
<span class="lineNum">    6317 </span><span class="lineCov">         12 :   return NS_OK;</span>
<span class="lineNum">    6318 </span>            : }
<span class="lineNum">    6319 </span>            : 
<span class="lineNum">    6320 </span>            : void
<span class="lineNum">    6321 </span><span class="lineNoCov">          0 : ScrollFrameHelper::FireScrolledAreaEvent()</span>
<span class="lineNum">    6322 </span>            : {
<span class="lineNum">    6323 </span><span class="lineNoCov">          0 :   mScrolledAreaEvent.Forget();</span>
<span class="lineNum">    6324 </span>            : 
<span class="lineNum">    6325 </span><span class="lineNoCov">          0 :   InternalScrollAreaEvent event(true, eScrolledAreaChanged, nullptr);</span>
<span class="lineNum">    6326 </span><span class="lineCov">         24 :   nsPresContext *prescontext = mOuter-&gt;PresContext();</span>
<span class="lineNum">    6327 </span><span class="lineNoCov">          0 :   nsIContent* content = mOuter-&gt;GetContent();</span>
<span class="lineNum">    6328 </span>            : 
<span class="lineNum">    6329 </span><span class="lineCov">         12 :   event.mArea = mScrolledFrame-&gt;GetScrollableOverflowRectRelativeToParent();</span>
<span class="lineNum">    6330 </span>            : 
<span class="lineNum">    6331 </span><span class="lineCov">         12 :   nsIDocument *doc = content-&gt;GetUncomposedDoc();</span>
<span class="lineNum">    6332 </span><span class="lineCov">         12 :   if (doc) {</span>
<span class="lineNum">    6333 </span><span class="lineCov">         12 :     EventDispatcher::Dispatch(doc, prescontext, &amp;event, nullptr);</span>
<span class="lineNum">    6334 </span>            :   }
<span class="lineNum">    6335 </span><span class="lineCov">         12 : }</span>
<span class="lineNum">    6336 </span>            : 
<span class="lineNum">    6337 </span>            : uint32_t
<span class="lineNum">    6338 </span><span class="lineNoCov">          0 : nsIScrollableFrame::GetPerceivedScrollingDirections() const</span>
<span class="lineNum">    6339 </span>            : {
<span class="lineNum">    6340 </span><span class="lineCov">          6 :   nscoord oneDevPixel = GetScrolledFrame()-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    6341 </span><span class="lineNoCov">          0 :   uint32_t directions = GetScrollbarVisibility();</span>
<span class="lineNum">    6342 </span><span class="lineNoCov">          0 :   nsRect scrollRange = GetScrollRange();</span>
<span class="lineNum">    6343 </span><span class="lineNoCov">          0 :   if (scrollRange.width &gt;= oneDevPixel) {</span>
<span class="lineNum">    6344 </span><span class="lineNoCov">          0 :     directions |= HORIZONTAL;</span>
<span class="lineNum">    6345 </span>            :   }
<span class="lineNum">    6346 </span><span class="lineCov">          3 :   if (scrollRange.height &gt;= oneDevPixel) {</span>
<span class="lineNum">    6347 </span><span class="lineNoCov">          0 :     directions |= VERTICAL;</span>
<span class="lineNum">    6348 </span>            :   }
<span class="lineNum">    6349 </span><span class="lineCov">          3 :   return directions;</span>
<span class="lineNum">    6350 </span>            : }
<span class="lineNum">    6351 </span>            : 
<span class="lineNum">    6352 </span>            : /**
<span class="lineNum">    6353 </span>            :  * Collect the scroll-snap-coordinates of frames in the subtree rooted at
<span class="lineNum">    6354 </span>            :  * |aFrame|, relative to |aScrolledFrame|, into |aOutCoords|.
<span class="lineNum">    6355 </span>            :  */
<span class="lineNum">    6356 </span>            : static void
<span class="lineNum">    6357 </span><span class="lineNoCov">          0 : CollectScrollSnapCoordinates(nsIFrame* aFrame, nsIFrame* aScrolledFrame,</span>
<span class="lineNum">    6358 </span>            :                              nsTArray&lt;nsPoint&gt;&amp; aOutCoords)
<span class="lineNum">    6359 </span>            : {
<span class="lineNum">    6360 </span><span class="lineNoCov">          0 :   nsIFrame::ChildListIterator childLists(aFrame);</span>
<span class="lineNum">    6361 </span><span class="lineNoCov">          0 :   for (; !childLists.IsDone(); childLists.Next()) {</span>
<span class="lineNum">    6362 </span><span class="lineNoCov">          0 :     nsFrameList::Enumerator childFrames(childLists.CurrentList());</span>
<span class="lineNum">    6363 </span><span class="lineNoCov">          0 :     for (; !childFrames.AtEnd(); childFrames.Next()) {</span>
<span class="lineNum">    6364 </span><span class="lineNoCov">          0 :       nsIFrame* f = childFrames.get();</span>
<span class="lineNum">    6365 </span>            : 
<span class="lineNum">    6366 </span><span class="lineNoCov">          0 :       const nsStyleDisplay* styleDisplay = f-&gt;StyleDisplay();</span>
<span class="lineNum">    6367 </span><span class="lineNoCov">          0 :       size_t coordCount = styleDisplay-&gt;mScrollSnapCoordinate.Length();</span>
<span class="lineNum">    6368 </span>            : 
<span class="lineNum">    6369 </span><span class="lineNoCov">          0 :       if (coordCount) {</span>
<span class="lineNum">    6370 </span><span class="lineNoCov">          0 :         nsRect frameRect = f-&gt;GetRect();</span>
<span class="lineNum">    6371 </span><span class="lineNoCov">          0 :         nsPoint offset = f-&gt;GetOffsetTo(aScrolledFrame);</span>
<span class="lineNum">    6372 </span><span class="lineNoCov">          0 :         nsRect edgesRect = nsRect(offset, frameRect.Size());</span>
<span class="lineNum">    6373 </span><span class="lineNoCov">          0 :         for (size_t coordNum = 0; coordNum &lt; coordCount; coordNum++) {</span>
<span class="lineNum">    6374 </span>            :           const Position&amp; coordPosition =
<span class="lineNum">    6375 </span><span class="lineNoCov">          0 :             f-&gt;StyleDisplay()-&gt;mScrollSnapCoordinate[coordNum];</span>
<span class="lineNum">    6376 </span><span class="lineNoCov">          0 :           nsPoint coordPoint = edgesRect.TopLeft();</span>
<span class="lineNum">    6377 </span><span class="lineNoCov">          0 :           coordPoint += nsPoint(coordPosition.mXPosition.mLength,</span>
<span class="lineNum">    6378 </span><span class="lineNoCov">          0 :                                 coordPosition.mYPosition.mLength);</span>
<span class="lineNum">    6379 </span><span class="lineNoCov">          0 :           if (coordPosition.mXPosition.mHasPercent) {</span>
<span class="lineNum">    6380 </span><span class="lineNoCov">          0 :             coordPoint.x += NSToCoordRound(coordPosition.mXPosition.mPercent *</span>
<span class="lineNum">    6381 </span><span class="lineNoCov">          0 :                                            frameRect.width);</span>
<span class="lineNum">    6382 </span>            :           }
<span class="lineNum">    6383 </span><span class="lineNoCov">          0 :           if (coordPosition.mYPosition.mHasPercent) {</span>
<span class="lineNum">    6384 </span><span class="lineNoCov">          0 :             coordPoint.y += NSToCoordRound(coordPosition.mYPosition.mPercent *</span>
<span class="lineNum">    6385 </span><span class="lineNoCov">          0 :                                            frameRect.height);</span>
<span class="lineNum">    6386 </span>            :           }
<span class="lineNum">    6387 </span>            : 
<span class="lineNum">    6388 </span><span class="lineNoCov">          0 :           aOutCoords.AppendElement(coordPoint);</span>
<span class="lineNum">    6389 </span>            :         }
<span class="lineNum">    6390 </span>            :       }
<span class="lineNum">    6391 </span>            : 
<span class="lineNum">    6392 </span><span class="lineNoCov">          0 :       CollectScrollSnapCoordinates(f, aScrolledFrame, aOutCoords);</span>
<span class="lineNum">    6393 </span>            :     }
<span class="lineNum">    6394 </span>            :   }
<span class="lineNum">    6395 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6396 </span>            : 
<span class="lineNum">    6397 </span>            : static layers::ScrollSnapInfo
<span class="lineNum">    6398 </span><span class="lineNoCov">          0 : ComputeScrollSnapInfo(const ScrollFrameHelper&amp; aScrollFrame)</span>
<span class="lineNum">    6399 </span>            : {
<span class="lineNum">    6400 </span><span class="lineNoCov">          0 :   ScrollSnapInfo result;</span>
<span class="lineNum">    6401 </span>            : 
<span class="lineNum">    6402 </span><span class="lineNoCov">          0 :   ScrollbarStyles styles = aScrollFrame.GetScrollbarStylesFromFrame();</span>
<span class="lineNum">    6403 </span>            : 
<span class="lineNum">    6404 </span><span class="lineNoCov">          0 :   if (styles.mScrollSnapTypeY == NS_STYLE_SCROLL_SNAP_TYPE_NONE &amp;&amp;</span>
<span class="lineNum">    6405 </span>            :       styles.mScrollSnapTypeX == NS_STYLE_SCROLL_SNAP_TYPE_NONE) {
<span class="lineNum">    6406 </span>            :     // We won't be snapping, short-circuit the computation.
<span class="lineNum">    6407 </span>            :     return result;
<span class="lineNum">    6408 </span>            :   }
<span class="lineNum">    6409 </span>            : 
<span class="lineNum">    6410 </span><span class="lineNoCov">          0 :   result.mScrollSnapTypeX = styles.mScrollSnapTypeX;</span>
<span class="lineNum">    6411 </span><span class="lineNoCov">          0 :   result.mScrollSnapTypeY = styles.mScrollSnapTypeY;</span>
<span class="lineNum">    6412 </span>            : 
<span class="lineNum">    6413 </span><span class="lineNoCov">          0 :   nsSize scrollPortSize = aScrollFrame.GetScrollPortRect().Size();</span>
<span class="lineNum">    6414 </span>            : 
<span class="lineNum">    6415 </span><span class="lineNoCov">          0 :   result.mScrollSnapDestination = nsPoint(styles.mScrollSnapDestinationX.mLength,</span>
<span class="lineNum">    6416 </span>            :                                           styles.mScrollSnapDestinationY.mLength);
<span class="lineNum">    6417 </span><span class="lineNoCov">          0 :   if (styles.mScrollSnapDestinationX.mHasPercent) {</span>
<span class="lineNum">    6418 </span><span class="lineNoCov">          0 :     result.mScrollSnapDestination.x +=</span>
<span class="lineNum">    6419 </span><span class="lineNoCov">          0 :         NSToCoordFloorClamped(styles.mScrollSnapDestinationX.mPercent *</span>
<span class="lineNum">    6420 </span><span class="lineNoCov">          0 :                               scrollPortSize.width);</span>
<span class="lineNum">    6421 </span>            :   }
<span class="lineNum">    6422 </span><span class="lineNoCov">          0 :   if (styles.mScrollSnapDestinationY.mHasPercent) {</span>
<span class="lineNum">    6423 </span><span class="lineNoCov">          0 :     result.mScrollSnapDestination.y +=</span>
<span class="lineNum">    6424 </span><span class="lineNoCov">          0 :         NSToCoordFloorClamped(styles.mScrollSnapDestinationY.mPercent *</span>
<span class="lineNum">    6425 </span><span class="lineNoCov">          0 :                               scrollPortSize.height);</span>
<span class="lineNum">    6426 </span>            :   }
<span class="lineNum">    6427 </span>            : 
<span class="lineNum">    6428 </span><span class="lineNoCov">          0 :   if (styles.mScrollSnapPointsX.GetUnit() != eStyleUnit_None) {</span>
<span class="lineNum">    6429 </span><span class="lineNoCov">          0 :     result.mScrollSnapIntervalX = Some(</span>
<span class="lineNum">    6430 </span><span class="lineNoCov">          0 :       styles.mScrollSnapPointsX.ComputeCoordPercentCalc(scrollPortSize.width));</span>
<span class="lineNum">    6431 </span>            :   }
<span class="lineNum">    6432 </span><span class="lineNoCov">          0 :   if (styles.mScrollSnapPointsY.GetUnit() != eStyleUnit_None) {</span>
<span class="lineNum">    6433 </span><span class="lineNoCov">          0 :     result.mScrollSnapIntervalY = Some(</span>
<span class="lineNum">    6434 </span><span class="lineNoCov">          0 :       styles.mScrollSnapPointsY.ComputeCoordPercentCalc(scrollPortSize.height));</span>
<span class="lineNum">    6435 </span>            :   }
<span class="lineNum">    6436 </span>            : 
<span class="lineNum">    6437 </span><span class="lineNoCov">          0 :   CollectScrollSnapCoordinates(aScrollFrame.GetScrolledFrame(),</span>
<span class="lineNum">    6438 </span>            :                                aScrollFrame.GetScrolledFrame(),
<span class="lineNum">    6439 </span><span class="lineNoCov">          0 :                                result.mScrollSnapCoordinates);</span>
<span class="lineNum">    6440 </span>            : 
<span class="lineNum">    6441 </span><span class="lineNoCov">          0 :   return result;</span>
<span class="lineNum">    6442 </span>            : }
<span class="lineNum">    6443 </span>            : 
<span class="lineNum">    6444 </span>            : layers::ScrollSnapInfo
<span class="lineNum">    6445 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetScrollSnapInfo() const</span>
<span class="lineNum">    6446 </span>            : {
<span class="lineNum">    6447 </span>            :   // TODO(botond): Should we cache it?
<span class="lineNum">    6448 </span><span class="lineNoCov">          0 :   return ComputeScrollSnapInfo(*this);</span>
<span class="lineNum">    6449 </span>            : }
<span class="lineNum">    6450 </span>            : 
<span class="lineNum">    6451 </span>            : bool
<span class="lineNum">    6452 </span><span class="lineNoCov">          0 : ScrollFrameHelper::GetSnapPointForDestination(nsIScrollableFrame::ScrollUnit aUnit,</span>
<span class="lineNum">    6453 </span>            :                                               nsPoint aStartPos,
<span class="lineNum">    6454 </span>            :                                               nsPoint &amp;aDestination)
<span class="lineNum">    6455 </span>            : {
<span class="lineNum">    6456 </span>            :   Maybe&lt;nsPoint&gt; snapPoint = ScrollSnapUtils::GetSnapPointForDestination(
<span class="lineNum">    6457 </span><span class="lineNoCov">          0 :       GetScrollSnapInfo(), aUnit, mScrollPort.Size(),</span>
<span class="lineNum">    6458 </span><span class="lineNoCov">          0 :       GetScrollRangeForClamping(), aStartPos, aDestination);</span>
<span class="lineNum">    6459 </span><span class="lineNoCov">          0 :   if (snapPoint) {</span>
<span class="lineNum">    6460 </span><span class="lineNoCov">          0 :     aDestination = snapPoint.ref();</span>
<span class="lineNum">    6461 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    6462 </span>            :   }
<span class="lineNum">    6463 </span>            :   return false;
<span class="lineNum">    6464 </span>            : }
<span class="lineNum">    6465 </span>            : 
<span class="lineNum">    6466 </span>            : bool
<span class="lineNum">    6467 </span><span class="lineNoCov">          0 : ScrollFrameHelper::UsesContainerScrolling() const</span>
<span class="lineNum">    6468 </span>            : {
<span class="lineNum">    6469 </span><span class="lineNoCov">          0 :   if (gfxPrefs::LayoutUseContainersForRootFrames()) {</span>
<span class="lineNum">    6470 </span><span class="lineNoCov">          0 :     return mIsRoot;</span>
<span class="lineNum">    6471 </span>            :   }
<span class="lineNum">    6472 </span>            :   return false;
<span class="lineNum">    6473 </span>            : }
<span class="lineNum">    6474 </span>            : 
<span class="lineNum">    6475 </span>            : bool
<span class="lineNum">    6476 </span><span class="lineNoCov">          0 : ScrollFrameHelper::DragScroll(WidgetEvent* aEvent)</span>
<span class="lineNum">    6477 </span>            : {
<span class="lineNum">    6478 </span>            :   // Dragging is allowed while within a 20 pixel border. Note that device pixels
<span class="lineNum">    6479 </span>            :   // are used so that the same margin is used even when zoomed in or out.
<span class="lineNum">    6480 </span><span class="lineNoCov">          0 :   nscoord margin = 20 * mOuter-&gt;PresContext()-&gt;AppUnitsPerDevPixel();</span>
<span class="lineNum">    6481 </span>            : 
<span class="lineNum">    6482 </span>            :   // Don't drag scroll for small scrollareas.
<span class="lineNum">    6483 </span><span class="lineNoCov">          0 :   if (mScrollPort.width &lt; margin * 2 || mScrollPort.height &lt; margin * 2) {</span>
<span class="lineNum">    6484 </span>            :     return false;
<span class="lineNum">    6485 </span>            :   }
<span class="lineNum">    6486 </span>            : 
<span class="lineNum">    6487 </span>            :   // If willScroll is computed as false, then the frame is already scrolled as
<span class="lineNum">    6488 </span>            :   // far as it can go in both directions. Return false so that an ancestor
<span class="lineNum">    6489 </span>            :   // scrollframe can scroll instead.
<span class="lineNum">    6490 </span><span class="lineNoCov">          0 :   bool willScroll = false;</span>
<span class="lineNum">    6491 </span><span class="lineNoCov">          0 :   nsPoint pnt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, mOuter);</span>
<span class="lineNum">    6492 </span><span class="lineNoCov">          0 :   nsPoint scrollPoint = GetScrollPosition();</span>
<span class="lineNum">    6493 </span><span class="lineNoCov">          0 :   nsRect rangeRect = GetScrollRangeForClamping();</span>
<span class="lineNum">    6494 </span>            : 
<span class="lineNum">    6495 </span>            :   // Only drag scroll when a scrollbar is present.
<span class="lineNum">    6496 </span><span class="lineNoCov">          0 :   nsPoint offset;</span>
<span class="lineNum">    6497 </span><span class="lineNoCov">          0 :   if (mHasHorizontalScrollbar) {</span>
<span class="lineNum">    6498 </span><span class="lineNoCov">          0 :     if (pnt.x &gt;= mScrollPort.x &amp;&amp; pnt.x &lt;= mScrollPort.x + margin) {</span>
<span class="lineNum">    6499 </span><span class="lineNoCov">          0 :       offset.x = -margin;</span>
<span class="lineNum">    6500 </span><span class="lineNoCov">          0 :       if (scrollPoint.x &gt; 0) {</span>
<span class="lineNum">    6501 </span><span class="lineNoCov">          0 :         willScroll = true;</span>
<span class="lineNum">    6502 </span>            :       }
<span class="lineNum">    6503 </span><span class="lineNoCov">          0 :     } else if (pnt.x &gt;= mScrollPort.XMost() - margin &amp;&amp; pnt.x &lt;= mScrollPort.XMost()) {</span>
<span class="lineNum">    6504 </span><span class="lineNoCov">          0 :       offset.x = margin;</span>
<span class="lineNum">    6505 </span><span class="lineNoCov">          0 :       if (scrollPoint.x &lt; rangeRect.width) {</span>
<span class="lineNum">    6506 </span><span class="lineNoCov">          0 :         willScroll = true;</span>
<span class="lineNum">    6507 </span>            :       }
<span class="lineNum">    6508 </span>            :     }
<span class="lineNum">    6509 </span>            :   }
<span class="lineNum">    6510 </span>            : 
<span class="lineNum">    6511 </span><span class="lineNoCov">          0 :   if (mHasVerticalScrollbar) {</span>
<span class="lineNum">    6512 </span><span class="lineNoCov">          0 :     if (pnt.y &gt;= mScrollPort.y &amp;&amp; pnt.y &lt;= mScrollPort.y + margin) {</span>
<span class="lineNum">    6513 </span><span class="lineNoCov">          0 :       offset.y = -margin;</span>
<span class="lineNum">    6514 </span><span class="lineNoCov">          0 :       if (scrollPoint.y &gt; 0) {</span>
<span class="lineNum">    6515 </span><span class="lineNoCov">          0 :         willScroll = true;</span>
<span class="lineNum">    6516 </span>            :       }
<span class="lineNum">    6517 </span><span class="lineNoCov">          0 :     } else if (pnt.y &gt;= mScrollPort.YMost() - margin &amp;&amp; pnt.y &lt;= mScrollPort.YMost()) {</span>
<span class="lineNum">    6518 </span><span class="lineNoCov">          0 :       offset.y = margin;</span>
<span class="lineNum">    6519 </span><span class="lineNoCov">          0 :       if (scrollPoint.y &lt; rangeRect.height) {</span>
<span class="lineNum">    6520 </span><span class="lineNoCov">          0 :         willScroll = true;</span>
<span class="lineNum">    6521 </span>            :       }
<span class="lineNum">    6522 </span>            :     }
<span class="lineNum">    6523 </span>            :   }
<span class="lineNum">    6524 </span>            : 
<span class="lineNum">    6525 </span><span class="lineNoCov">          0 :   if (offset.x || offset.y) {</span>
<span class="lineNum">    6526 </span><span class="lineNoCov">          0 :     ScrollTo(GetScrollPosition() + offset, nsIScrollableFrame::NORMAL);</span>
<span class="lineNum">    6527 </span>            :   }
<span class="lineNum">    6528 </span>            : 
<span class="lineNum">    6529 </span>            :   return willScroll;
<span class="lineNum">    6530 </span>            : }
<span class="lineNum">    6531 </span>            : 
<span class="lineNum">    6532 </span>            : static void
<span class="lineNum">    6533 </span><span class="lineNoCov">          0 : AsyncScrollbarDragRejected(nsIFrame* aScrollbar)</span>
<span class="lineNum">    6534 </span>            : {
<span class="lineNum">    6535 </span><span class="lineNoCov">          0 :   if (!aScrollbar) {</span>
<span class="lineNum">    6536 </span>            :     return;
<span class="lineNum">    6537 </span>            :   }
<span class="lineNum">    6538 </span>            : 
<span class="lineNum">    6539 </span>            :   for (nsIFrame::ChildListIterator childLists(aScrollbar);
<span class="lineNum">    6540 </span>            :        !childLists.IsDone();
<span class="lineNum">    6541 </span>            :        childLists.Next()) {
<span class="lineNum">    6542 </span>            :     for (nsIFrame* frame : childLists.CurrentList()) {
<span class="lineNum">    6543 </span>            :       if (nsSliderFrame* sliderFrame = do_QueryFrame(frame)) {
<span class="lineNum">    6544 </span>            :         sliderFrame-&gt;AsyncScrollbarDragRejected();
<span class="lineNum">    6545 </span>            :       }
<span class="lineNum">    6546 </span>            :     }
<span class="lineNum">    6547 </span>            :   }
<span class="lineNum">    6548 </span>            : }
<span class="lineNum">    6549 </span>            : 
<span class="lineNum">    6550 </span>            : void
<span class="lineNum">    6551 </span>            : ScrollFrameHelper::AsyncScrollbarDragRejected()
<span class="lineNum">    6552 </span>            : {
<span class="lineNum">    6553 </span>            :   // We don't get told which scrollbar requested the async drag,
<span class="lineNum">    6554 </span>            :   // so we notify both.
<span class="lineNum">    6555 </span>            :   ::AsyncScrollbarDragRejected(mHScrollbarBox);
<span class="lineNum">    6556 </span>            :   ::AsyncScrollbarDragRejected(mVScrollbarBox);
<span class="lineNum">    6557 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13-14-ga5dd952</a></td></tr>
  </table>
  <br>

</body>
</html>
